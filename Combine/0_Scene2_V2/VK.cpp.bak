#include<stdio.h>	// For Win32 API
#include<stdlib.h> 	// For FILE-IO
#include<windows.h>	// For exit()
#include<mmsystem.h>
// Header file for texture
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#include "VK.h"

// Vulkan related header file
#define VK_USE_PLATFORM_WIN32_KHR // XLIB_KHR, MACOS_KHR & MOLTEN something
#include <vulkan/vulkan.h> //(Only those members are enabled connected with above macro {conditional compilation using #ifdef internally})

// GLM related MACROS and header files
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#define GLM_ENABLE_EXPERIMENTAL 

#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtc/constants.hpp"     // NEW
#include "glm/gtc/quaternion.hpp"    // NEW
#include "glm/gtx/quaternion.hpp"    // NEW

// vulkan related library
#pragma comment(lib, "vulkan-1.lib")
#pragma comment(lib,"winmm.lib")

// Macros
#define WIN_WIDTH 800
#define WIN_HEIGHT 600

// Global Function Declarations
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
const char* gpszAppName = "ARTR";

// Global Variable declarations
FILE* gpFILE = NULL;

BOOL gbActive = FALSE;
HWND ghwnd = NULL;
DWORD dwStyle = 0;
WINDOWPLACEMENT wpPrev;// = { sizeof(WINDOWPLACEMENT) }; //dont do this as cpp style
BOOL gbFullscreen = FALSE;
BOOL bWindowMininized = FALSE;

// Vulkan related global variables
// Instance Extension related variables
uint32_t enableInstanceExtensionCount = 0;

// VK_KHR_SURFACE_EXTENSION_NAME And VK_KHR_WIN32_SURFACE_EXTENSION_NAME and VK_EXT_DEBUG_REPORT_EXTENSION_NAME
const char* enabledInstanceExtensionNames_array[3];

// vulkan instance
VkInstance vkInstance = VK_NULL_HANDLE;

// Vulkan presentation surface
VkSurfaceKHR vkSurfaceKHR = VK_NULL_HANDLE;

// Vulkan physical device related global variables
VkPhysicalDevice vkPhysicalDevice_selected = VK_NULL_HANDLE;
uint32_t graphicsQueueFamilyIndex_selected = UINT32_MAX;
VkPhysicalDeviceMemoryProperties vkPhysicalDeviceMemoryProperties;

uint32_t physicalDeviceCount = 0;
VkPhysicalDevice* vkPhysicalDevice_array = NULL;

// Device Extension related variables
uint32_t enabledDeviceExtensionCount = 0;

// VK_KHR_SWAPCHAIN_EXTENSION_NAME
const char* enabledDeviceExtensionNames_array[1];

// At top with other globals
static bool gCmdBuffersDirty = false;

// Vulkan device
VkDevice vkDevice = VK_NULL_HANDLE;

// Device Queue
VkQueue vkQueue = VK_NULL_HANDLE;

// Descriptor set (global so multiple functions can use it)
VkDescriptorSet vkDescriptorSet = VK_NULL_HANDLE;

// Color format and color space
VkFormat vkFormat_color = VK_FORMAT_UNDEFINED;
VkColorSpaceKHR vkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;

// Presentation mode
VkPresentModeKHR vkPresentModeKHR = VK_PRESENT_MODE_FIFO_KHR;

// Swapchain related global variable
int winWidth = WIN_WIDTH;
int winHeight = WIN_HEIGHT;
VkSwapchainKHR vkSwapchainKHR = VK_NULL_HANDLE;
VkExtent2D vkExtent2D_swapchain;

// Swapchain image and image views
uint32_t swapchainImageCount = UINT32_MAX;
VkImage* swapchainImage_array = NULL;
VkImageView* swapchainImageView_array = NULL;

// For Depth image
VkFormat vkFormat_depth 			= VK_FORMAT_UNDEFINED;
VkImage vkImage_depth 				= VK_NULL_HANDLE;
VkDeviceMemory vkDeviceMemory_depth = VK_NULL_HANDLE;
VkImageView vkImageView_depth 		= VK_NULL_HANDLE;


// Command pool
VkCommandPool vkCommandPool = VK_NULL_HANDLE;

// Command buffer
VkCommandBuffer* vkCommandBuffer_array = NULL;

// Render PASS
VkRenderPass vkRenderPass = VK_NULL_HANDLE;

// Framebuffers
VkFramebuffer* vkFramebuffer_array = NULL;

// Semaphore
VkSemaphore vkSemaphore_backBuffer = VK_NULL_HANDLE;
VkSemaphore vkSemaphore_renderComplete = VK_NULL_HANDLE;

// Fence
VkFence* vkFence_array = NULL;

// clear colors values
VkClearColorValue vkClearColorValue; // this structure have 3 array 
VkClearDepthStencilValue vkClearDepthStencilValue;

// Blue screen
BOOL bInitialized = FALSE;
uint32_t currentImageIndex = UINT32_MAX;

// Validation
BOOL bValidation = TRUE;
uint32_t enabledValidationLayerCount = 0;
const char* enabledValidationLayerNames_array[1];	// For VK_LAYER_KHRONOS_validation
VkDebugReportCallbackEXT vkDebugReportCallbackEXT = VK_NULL_HANDLE;
PFN_vkDestroyDebugReportCallbackEXT vkDestroyDebugReportCallbackEXT_fnptr = NULL;

const char *images[] = {"right.png", "left.png", "top.png", "bottom.png", "front.png", "back.png"};

// NEW: camera animation helpers
static void BeginNewPan();
static void UpdateCameraAnim();
static glm::quat RandomOrientationQuat();


// --- Overlay (show only during first HOLD) ---
static bool       gOverlayActive = false;              // on only during the first hold
static glm::vec3  gOverlayDir    = glm::vec3(0,0,-1);  // where to center the decal

// Overlay fade timings (ms)
static const DWORD kOverlayLeadMs  = 450;   // fade-in during last 450 ms of a PAN
static const DWORD kOverlayFadeMs  = 450;   // fade-out during last 450 ms of a HOLD

// On-screen size of the overlay (fraction of the smaller screen dimension).
// The shader uses the *sign* of this value to select circular masking; we pass -kOverlaySizeFrac.
static const float kOverlaySizeFrac = 0.85f;

static const float kOverlayRadiusDeg  = 12.0f;
static const float kOverlayFeatherDeg = 2.0f;

// --- Camera animation config ---

// NEW: user‑controllable speed (deg/sec) and the duration computed per pan
static float gPanSpeedDegPerSec = 45.0f;     // change anytime (e.g., 15–180)
static DWORD gPanDurationMs     = 12;      // computed for each pan
static DWORD CalcPanDurationMs(const glm::quat& q0, const glm::quat& q1);
static void  SetPanSpeedDegPerSec(float s);

static const DWORD kHoldDurationMs = 3000;  // 1 second hold
static const int   kPanRepeats     = 12;    // number of pans

// NEW: require a big jump between consecutive stops (in degrees)
static const float kMinSeparationDeg = 90.0f;   // tweak: 80–120 feels “large”

enum CameraPhase { CAM_PAN, CAM_HOLD, CAM_STOPPED };
static CameraPhase gCamPhase = CAM_PAN;

// Orientations (unit quaternions)
static glm::quat gCamQ        = glm::quat(1.0f, 0.0f, 0.0f, 0.0f); // current
static glm::quat gCamQStart   = gCamQ;  // pan start
static glm::quat gCamQTarget  = gCamQ;  // pan target

// Timing
static DWORD gPhaseStartMs = 0;
static int   gPansDone     = 0;


// 2D overlay texture objects
VkImage        vkImage_overlay         = VK_NULL_HANDLE;
VkDeviceMemory vkDeviceMemory_overlay  = VK_NULL_HANDLE;
VkImageView    vkImageView_overlay     = VK_NULL_HANDLE;
VkSampler      vkSampler_overlay       = VK_NULL_HANDLE;

// --- Overlay gallery (one image per pan stop) ---
static const int kOverlayCount = 12;

// For now every slot points to the same image; replace strings later.
static const char* gOverlayPaths[kOverlayCount] = {
    "01_Mesh.png","02_Vrushabh.png","03_Mithun.png","04_Karka.png",
    "05_Simha.png","06_Kanya.png","07_Tula.png","08_Vruschik.png",
    "09_Dhanu.png","10_Makar.png","11_Kumbh.png","12_Meen.png"
};

VkImage        gOverlayImages   [kOverlayCount] = {};
VkDeviceMemory gOverlayMem      [kOverlayCount] = {};
VkImageView    gOverlayViews    [kOverlayCount] = {};
VkSampler      gOverlaySamplers [kOverlayCount] = {};

// Currently bound overlay index on descriptor binding #2
static int gOverlayBound = -1;

// Forward declarations (NEW)
static void  BindOverlayTexture(int which);       // 0 or 1
static float ComputeOverlayFadeForPan(int index); // 0 = first pan, 1 = second pan

// Runtime‑tweakable size fraction (initialised from the default above).
// Interpreted as a fraction of the smaller screen dimension.
// The shader uses the *sign* of this value to select circular masking (negative = circle).
static float gOverlaySizeFrac = kOverlaySizeFrac;

// Clamp helper to keep it reasonable (visible but not huge)
// Allow up to 2.0 (200% of min(screenW, screenH)) so users can overscan.
static inline void SetOverlaySizeFrac(float frac)
{
    gOverlaySizeFrac = glm::clamp(frac, 0.05f, 2.00f);
    fprintf(gpFILE, "Overlay size set to %.3f (fraction of min dimension)\n", gOverlaySizeFrac);
}

// Convenience nudge for keyboard controls
static inline void NudgeOverlaySizeFrac(float delta)
{
    SetOverlaySizeFrac(gOverlaySizeFrac + delta);
}

static inline float ease01(float x) { x = glm::clamp(x, 0.0f, 1.0f); return x*x*(3.0f - 2.0f*x); }

// Fade driver for a specific pan index (0-based: 0 = first pan, 1 = second, ...)
static float ComputeOverlayFadeForPan(int panIndex)
{
    DWORD now = timeGetTime();

    if (gCamPhase == CAM_PAN)
    {
        // The pan in progress is numbered by gPansDone (0-based)
        if ((int)gPansDone != panIndex) return 0.0f;

        DWORD panElapsed = now - gPhaseStartMs;
        DWORD lead = glm::min<DWORD>(kOverlayLeadMs, gPanDurationMs);
        if (panElapsed <= gPanDurationMs - lead) return 0.0f;

        float u = float(panElapsed - (gPanDurationMs - lead)) / float(lead);
        return ease01(glm::clamp(u, 0.0f, 1.0f)); // ease-in
    }
    else if (gCamPhase == CAM_HOLD)
    {
        // During the hold that follows that pan, gPansDone is still the pan index we want
        if ((int)gPansDone != panIndex) return 0.0f;

        DWORD t = now - gPhaseStartMs;
        DWORD out = glm::min<DWORD>(kOverlayFadeMs, kHoldDurationMs);
        if (t < (kHoldDurationMs - out)) return 1.0f;

        float u = float(kHoldDurationMs - t) / float(out);
        return ease01(glm::clamp(u, 0.0f, 1.0f)); // ease-out
    }
    return 0.0f;
}

static void BindOverlayTexture(int which)
{
    if (which < 0) return;
    if (which >= kOverlayCount) which = kOverlayCount - 1;
    if (gOverlayBound == which) return;

    gOverlayBound = which;

    VkDescriptorImageInfo overlay{};
    overlay.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    overlay.imageView   = gOverlayViews[which];
    overlay.sampler     = gOverlaySamplers[which];

    VkWriteDescriptorSet write{};
    write.sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    write.dstSet          = vkDescriptorSet;
    write.dstBinding      = 2; // overlay binding
    write.descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    write.descriptorCount = 1;
    write.pImageInfo      = &overlay;

    vkUpdateDescriptorSets(vkDevice, 1, &write, 0, nullptr);

    // Descriptor changed -> re-record before next submit
    gCmdBuffersDirty = true;
}

static inline float frand01() { return (float)rand() / (float)RAND_MAX; }

static DWORD CalcPanDurationMs(const glm::quat& q0, const glm::quat& q1)
{
    // Relative rotation from start to target
    glm::quat d = glm::normalize(q1 * glm::conjugate(q0));
    // Angle of that rotation (radians) -> degrees
    float angleRad = 2.0f * acosf(glm::clamp(d.w, -1.0f, 1.0f));
    float angleDeg = glm::degrees(angleRad);

    // Duration = angle / speed
    float ms = (angleDeg / glm::max(1e-3f, gPanSpeedDegPerSec)) * 1000.0f;

    // Clamp to keep things sane (fast but not teleport; slow but not forever)
    ms = glm::clamp(ms, 120.0f, 30000.0f);
    return (DWORD)(ms + 0.5f);
}

static void SetPanSpeedDegPerSec(float s)
{
    // Set a new speed and (if currently panning) keep progress visually continuous
    s = glm::clamp(s, 1.0f, 360.0f);
    if (gPanSpeedDegPerSec == s) return;

    DWORD now = timeGetTime();

    if (gCamPhase == CAM_PAN)
    {
        // Preserve current progress fraction while changing duration
        float oldDur = (float)gPanDurationMs;
        float prog   = glm::clamp((now - gPhaseStartMs) / oldDur, 0.0f, 1.0f);

        gPanSpeedDegPerSec = s;
        gPanDurationMs     = CalcPanDurationMs(gCamQStart, gCamQTarget);

        gPhaseStartMs = now - (DWORD)(prog * (float)gPanDurationMs);
    }
    else
    {
        gPanSpeedDegPerSec = s;
    }
}

// Return a random orientation whose forward dir is at least 'minSepDeg' away from 'from'
static glm::quat RandomOrientationFarFrom(const glm::quat& from, float minSepDeg)
{
    // camera forward for an orientation q is q * (0,0,-1)
    const glm::vec3 fPrev = from * glm::vec3(0.0f, 0.0f, -1.0f);
    const float minDot = cosf(glm::radians(minSepDeg));  // require dot <= minDot
    const int   kMaxAttempts = 64;

    for (int i = 0; i < kMaxAttempts; ++i)
    {
        glm::quat q = RandomOrientationQuat(); // your existing uniform random quat
        glm::vec3 f = q * glm::vec3(0.0f, 0.0f, -1.0f);
        float d = glm::dot(glm::normalize(fPrev), glm::normalize(f));
        if (d <= minDot)
            return glm::normalize(q);
    }

    // Fallback (very rare): flip 180° from previous forward to guarantee a big move
    glm::quat flip = glm::rotation(fPrev, -fPrev);   // from gtx/quaternion
    return glm::normalize(flip * from);
}

// NEW: uniform random orientation over SO(3)
static glm::quat RandomOrientationQuat()
{
    // Ken Shoemake method for uniform random quaternions
    float u1 = frand01();
    float u2 = frand01() * 2.0f * glm::pi<float>();
    float u3 = frand01() * 2.0f * glm::pi<float>();

    float s1 = sqrtf(1.0f - u1);
    float s2 = sqrtf(u1);

    float x = s1 * sinf(u2);
    float y = s1 * cosf(u2);
    float z = s2 * sinf(u3);
    float w = s2 * cosf(u3);
    return glm::normalize(glm::quat(w, x, y, z)); // glm::quat(w,x,y,z)
}

static void BeginNewPan()
{
    // Bind overlay for the upcoming pan index (0-based)
    // At this point, gPansDone equals the index of the pan we're about to start.
    BindOverlayTexture(glm::min(gPansDone, kOverlayCount - 1));

    gCamQStart     = gCamQ;
    gCamQTarget    = RandomOrientationFarFrom(gCamQ, kMinSeparationDeg);
    gPanDurationMs = CalcPanDurationMs(gCamQStart, gCamQTarget);

    // Where the screen center will face when the pan finishes (conceptual).
    gOverlayDir    = glm::normalize(gCamQTarget * glm::vec3(0.0f, 0.0f, -1.0f));

    gPhaseStartMs  = timeGetTime();
    gCamPhase      = CAM_PAN;
    gOverlayActive = false; // fade function will light it up near the tail
}

static void UpdateCameraAnim()
{
    DWORD now = timeGetTime();

    if (gCamPhase == CAM_PAN)
    {
        float t = (now - gPhaseStartMs) / (float)gPanDurationMs;
        if (t >= 1.0f)
        {
            // Snap to target and enter HOLD
            gCamQ         = gCamQTarget;
            gCamPhase     = CAM_HOLD;
            gPhaseStartMs = now;

            // Show overlay at every stop
            gOverlayActive = true;

            // Snap center to the actual stop direction too
            gOverlayDir = glm::normalize(gCamQ * glm::vec3(0.0f, 0.0f, -1.0f));
        }
        else
        {
            // Smooth slerp
            float s = t * t * (3.0f - 2.0f * t);
            gCamQ = glm::slerp(gCamQStart, gCamQTarget, s);
        }
    }
    else if (gCamPhase == CAM_HOLD)
    {
        if (now - gPhaseStartMs >= kHoldDurationMs)
        {
            // End of this stop
            gOverlayActive = false;

            if (++gPansDone >= kPanRepeats)
            {
                gCamPhase = CAM_STOPPED;
            }
            else
            {
                BeginNewPan();
            }

            // (Removed the old special-case overlay switch after first stop)
        }
    }
}

// vertex buffer related data
typedef struct{
	VkBuffer vkBuffer;
	VkDeviceMemory vkDeviceMemory;
}VertexData;

// position
VertexData vertexData_position;

// color
VertexData vertexData_texcoord;

// uniform related declarations
struct MyUniformData
{
    glm::mat4 modelMatrix;
    glm::mat4 viewMatrix;
    glm::mat4 projectionMatrix;

    glm::vec4 overlayParams; // x=fade, y=screenW, z=screenH, w=unused  <-- NEW
};

struct UniformData{
	VkBuffer vkBuffer;
	VkDeviceMemory vkDeviceMemory;
};

UniformData uniformData;

// Shader related variables
VkShaderModule vkShaderModule_vertex_shader = VK_NULL_HANDLE;
VkShaderModule vkShaderModule_fragment_shader = VK_NULL_HANDLE;

// Descriptor set layout
VkDescriptorSetLayout vkDescriptorSetLayout = VK_NULL_HANDLE;

// PipelineLayout
VkPipelineLayout vkPipelineLayout = VK_NULL_HANDLE;

// Descriptor pool
VkDescriptorPool vkDescriptorPool = VK_NULL_HANDLE;

// Pipeline
VkViewport vkViewport;
VkRect2D vkRect2D_scissor;
VkPipeline vkPipeline = VK_NULL_HANDLE;

// For rotation
float angle = 0.0f;

// Texture related global data
VkImage vkImage_texture 			= VK_NULL_HANDLE;
VkDeviceMemory vkDeviceMemory_texture = VK_NULL_HANDLE;
VkImageView vkImageView_texture 	= VK_NULL_HANDLE;
VkSampler vkSampler_texture 		= VK_NULL_HANDLE;

double eyex, eyey, centerx, centery, centerz, upx, upz;
double eyez, upy = 1;

static float ComputeOverlayFade()
{
    DWORD now = timeGetTime();

    if (gCamPhase == CAM_PAN)
    {
        // Fade-in during the trailing portion of ANY pan
        DWORD elapsed = now - gPhaseStartMs;
        DWORD lead    = glm::min<DWORD>(kOverlayLeadMs, gPanDurationMs);
        if (elapsed <= gPanDurationMs - lead) return 0.0f;

        float u = float(elapsed - (gPanDurationMs - lead)) / float(lead); // 0..1
        return ease01(glm::clamp(u, 0.0f, 1.0f)); // ease-in
    }
    else if (gCamPhase == CAM_HOLD)
    {
        // Stay up during the hold, fade-out just before the next pan
        DWORD t   = now - gPhaseStartMs;
        DWORD out = glm::min<DWORD>(kOverlayFadeMs, kHoldDurationMs);
        if (t < (kHoldDurationMs - out)) return 1.0f;

        float u = float(kHoldDurationMs - t) / float(out); // 1..0
        return ease01(glm::clamp(u, 0.0f, 1.0f)); // ease-out
    }
    return 0.0f;
}

// Entry-Point Function
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int iCmdShow)
{
	// Function Declarations
	VkResult initialize(void);
	void uninitialize(void);
	VkResult display(void);
	void update(void);

	// Local Variable declarations
	WNDCLASSEX wndclass;
	HWND hwnd;
	MSG msg;
	TCHAR  szAppName[255];
	int iResult = 0; // hungerian
	BOOL bDone = FALSE;

	int Screen_x, Screen_y;
	int Window_x = 800, Window_y = 600;
	
	VkResult vkResult = VK_SUCCESS;
	
	// Code
	
	// Retriving Screen Details
	Screen_x = GetSystemMetrics(SM_CXSCREEN);
	Screen_y = GetSystemMetrics(SM_CYSCREEN);

	gpFILE = fopen("Log.txt", "w");
	if (gpFILE == NULL)
	{
		MessageBox(NULL, TEXT("Log File Cannot be Open"), TEXT("ERROR"), MB_OK | MB_ICONERROR);
		exit(0);
	}
	fprintf(gpFILE, "--------------------Program Started Successfully-----------------------------\n\n");

	wsprintf(szAppName, TEXT("%s"), gpszAppName);

	// WNDCLASSEX Initialization
	wndclass.cbSize = sizeof(WNDCLASSEX);
	wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = 0;
	wndclass.lpfnWndProc = WndProc;
	wndclass.hInstance = hInstance;
	wndclass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
	wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(MYICON));
	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndclass.lpszClassName = szAppName;
	wndclass.lpszMenuName = NULL;
	wndclass.hIconSm = LoadIcon(hInstance, MAKEINTRESOURCE(MYICON));

	// Register WNDCLASSEX
	RegisterClassEx(&wndclass);

	// Create Window
	hwnd = CreateWindowEx(WS_EX_APPWINDOW,
		szAppName,
		TEXT("Sohel Husen Shaikh : Vulkan"),
		WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE,
		Screen_x / 2 - Window_x / 2, // x
		Screen_y / 2 - Window_y / 2, // y
		WIN_WIDTH, // width
		WIN_HEIGHT, // height
		NULL,
		NULL,
		hInstance,
		NULL);

	ghwnd = hwnd;

	//Initialization
	vkResult = initialize();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "WinMain() -> initialize() is failed\n");
		//MessageBox(hwnd, TEXT("Initialize() Failed"), TEXT("ERROR"), MB_OK | MB_ICONERROR);
		DestroyWindow(hwnd);
		/*uninitialize();  // initialize lach fail zal tar aapn uninitialize karun baaher padtoy meaasge loop la na jata.
		exit(0);*/
	}
	else{
		fprintf(gpFILE, "WinMain -> initialize() is Succeeded\n");
	}

	// Show The Window
	ShowWindow(hwnd, iCmdShow);
	SetForegroundWindow(hwnd);
	SetFocus(hwnd);

	// Game Loop
	while (bDone == FALSE)
	{
		if (PeekMessage(&msg,NULL,0,0,PM_REMOVE))
		{
			if (msg.message == WM_QUIT)
				bDone = TRUE;
			else
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		}
		else
		{
			if (gbActive == TRUE)
			{
				// Render !!!
				if(bWindowMininized == FALSE){
					vkResult = display();
					if (vkResult != VK_FALSE && vkResult != VK_SUCCESS && vkResult != VK_ERROR_OUT_OF_DATE_KHR && vkResult != VK_SUBOPTIMAL_KHR)
					{
						fprintf(gpFILE, "WinMain() -> Called to Display Failed\n");
						bDone = TRUE; 
						return vkResult;
					}
					else{
					
					}

					// update
					if(gbActive == TRUE){
						update();
					}
				}
			}
		}
	}

	// Uninitialization
	uninitialize();

	return (int)msg.wParam;
}

// CALL-BACK FUNCTION
LRESULT CALLBACK WndProc(HWND hwnd,
	UINT iMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	// Function declarations
	void ToggleFullscreen(void);
	VkResult resize(int, int);

	// Code
	switch (iMsg)
	{
	case WM_SETFOCUS:
		gbActive = TRUE;
		break;
	case WM_KILLFOCUS:
		gbActive = FALSE;
		break;
	case WM_SIZE:
		if(wParam == SIZE_MINIMIZED){
			bWindowMininized = TRUE;
		}
		else{
			bWindowMininized = FALSE;
			resize(LOWORD(lParam),HIWORD(lParam)); // Error checking not required
			
		}
		break;
	case WM_CREATE:
		memset((void*)&wpPrev, 0, sizeof(WINDOWPLACEMENT));
		wpPrev.length = sizeof(WINDOWPLACEMENT);
		break;
	case WM_KEYDOWN:
	switch (LOWORD(wParam))
	{
	case VK_ESCAPE:
		DestroyWindow(hwnd);
		break;
	}
	break;
	case WM_CHAR:
		switch (LOWORD(wParam))
		{
		case 'F':
		case 'f':
			if (gbFullscreen == FALSE)
			{
				ToggleFullscreen();
				gbFullscreen = TRUE;
			}
			
			else
			{
				ToggleFullscreen();
				gbFullscreen = FALSE;
			}
			break;
			
		case 0x30:  // slower
			SetPanSpeedDegPerSec(gPanSpeedDegPerSec - 10.0f);
			break;
	
		case 0x31:
			SetPanSpeedDegPerSec(gPanSpeedDegPerSec + 10.0f);
			break;
			
		case 0x32:
			NudgeOverlaySizeFrac(-0.02f);
			break;
			
		case 0x33:
			NudgeOverlaySizeFrac(+0.02f);
			break;
		}
		break;
	case WM_CLOSE:
		DestroyWindow(hwnd);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		break;
	}

	return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

void ToggleFullscreen(void)
{
	// local variable declarations
	MONITORINFO mi = { sizeof(MONITORINFO) };

	// code
	if (gbFullscreen == FALSE)
	{
		dwStyle = GetWindowLong(ghwnd, GWL_STYLE);
		if (dwStyle & WS_OVERLAPPEDWINDOW)
		{
			if (GetWindowPlacement(ghwnd, &wpPrev) && GetMonitorInfo(MonitorFromWindow(ghwnd, MONITORINFOF_PRIMARY), &mi))
			{
				SetWindowLong(ghwnd, GWL_STYLE, dwStyle & ~WS_OVERLAPPEDWINDOW);
				SetWindowPos(ghwnd, HWND_TOP, mi.rcMonitor.left, mi.rcMonitor.top, mi.rcMonitor.right - mi.rcMonitor.left, mi.rcMonitor.bottom - mi.rcMonitor.top, SWP_NOZORDER | SWP_FRAMECHANGED);
			}
		}
		ShowCursor(FALSE);
	}
	else
	{
		SetWindowPlacement(ghwnd, &wpPrev);
		SetWindowLong(ghwnd, GWL_STYLE, dwStyle | WS_OVERLAPPEDWINDOW);
		SetWindowPos(ghwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_FRAMECHANGED);
		ShowCursor(TRUE);
	}
}

VkResult createTexture2D(const char* path,
                         VkImage* outImg,
                         VkDeviceMemory* outMem,
                         VkImageView* outView,
                         VkSampler* outSampler)
{
    int w=0, h=0, ch=0;
    uint8_t* pixels = stbi_load(path, &w, &h, &ch, STBI_rgb_alpha);
    if (!pixels || w<=0 || h<=0) return VK_ERROR_INITIALIZATION_FAILED;

    VkDeviceSize imageSize = (VkDeviceSize)w * h * 4;

    // --- staging buffer ---
    VkBuffer staging = VK_NULL_HANDLE; VkDeviceMemory stagingMem = VK_NULL_HANDLE;
    {
        VkBufferCreateInfo ci{ VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
        ci.size  = imageSize;
        ci.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
        vkCreateBuffer(vkDevice, &ci, nullptr, &staging);

        VkMemoryRequirements mr{}; vkGetBufferMemoryRequirements(vkDevice, staging, &mr);

        VkMemoryAllocateInfo ai{ VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };
        ai.allocationSize  = mr.size;
        for (uint32_t i=0;i<vkPhysicalDeviceMemoryProperties.memoryTypeCount;++i){
            if ((mr.memoryTypeBits & (1u<<i)) &&
                ((vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags &
                 (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) ==
                 (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT))){
                ai.memoryTypeIndex = i; break;
            }
        }
        vkAllocateMemory(vkDevice, &ai, nullptr, &stagingMem);
        vkBindBufferMemory(vkDevice, staging, stagingMem, 0);

        void* data=nullptr; vkMapMemory(vkDevice, stagingMem, 0, imageSize, 0, &data);
        memcpy(data, pixels, (size_t)imageSize);
        vkUnmapMemory(vkDevice, stagingMem);
    }
    stbi_image_free(pixels);

    // --- device image ---
    {
        VkImageCreateInfo ci{ VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
        ci.imageType   = VK_IMAGE_TYPE_2D;
        ci.format      = VK_FORMAT_R8G8B8A8_UNORM;
        ci.extent      = { (uint32_t)w, (uint32_t)h, 1 };
        ci.mipLevels   = 1;
        ci.arrayLayers = 1;
        ci.samples     = VK_SAMPLE_COUNT_1_BIT;
        ci.tiling      = VK_IMAGE_TILING_OPTIMAL;
        ci.usage       = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
        ci.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        vkCreateImage(vkDevice, &ci, nullptr, outImg);

        VkMemoryRequirements mr{}; vkGetImageMemoryRequirements(vkDevice, *outImg, &mr);

        VkMemoryAllocateInfo ai{ VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };
        ai.allocationSize = mr.size;
        for (uint32_t i=0;i<vkPhysicalDeviceMemoryProperties.memoryTypeCount;++i){
            if ((mr.memoryTypeBits & (1u<<i)) &&
                (vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags &
                 VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)){
                ai.memoryTypeIndex = i; break;
            }
        }
        vkAllocateMemory(vkDevice, &ai, nullptr, outMem);
        vkBindImageMemory(vkDevice, *outImg, *outMem, 0);
    }

    // helper lambdas to do short one‑shot command buffers
    auto beginOneShot = [&](){
        VkCommandBufferAllocateInfo a{ VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO };
        a.commandPool = vkCommandPool; a.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; a.commandBufferCount = 1;
        VkCommandBuffer cb; vkAllocateCommandBuffers(vkDevice, &a, &cb);
        VkCommandBufferBeginInfo b{ VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO };
        b.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
        vkBeginCommandBuffer(cb, &b);
        return cb;
    };
    auto endOneShot = [&](VkCommandBuffer cb){
        vkEndCommandBuffer(cb);
        VkSubmitInfo s{ VK_STRUCTURE_TYPE_SUBMIT_INFO }; s.commandBufferCount = 1; s.pCommandBuffers = &cb;
        vkQueueSubmit(vkQueue, 1, &s, VK_NULL_HANDLE);
        vkQueueWaitIdle(vkQueue);
        vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &cb);
    };

    // layout: UNDEFINED -> TRANSFER_DST_OPTIMAL
    {
        VkCommandBuffer cb = beginOneShot();
        VkImageMemoryBarrier bar{ VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER };
        bar.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        bar.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        bar.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        bar.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        bar.image = *outImg;
        bar.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        bar.subresourceRange.baseMipLevel = 0; bar.subresourceRange.levelCount = 1;
        bar.subresourceRange.baseArrayLayer = 0; bar.subresourceRange.layerCount = 1;
        bar.srcAccessMask = 0;
        bar.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        vkCmdPipelineBarrier(cb,
            VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,
            0, 0,nullptr, 0,nullptr, 1,&bar);
        endOneShot(cb);
    }

    // copy staging -> image
    {
        VkCommandBuffer cb = beginOneShot();
        VkBufferImageCopy r{};
        r.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        r.imageSubresource.mipLevel   = 0;
        r.imageSubresource.baseArrayLayer = 0;
        r.imageSubresource.layerCount = 1;
        r.imageExtent = { (uint32_t)w, (uint32_t)h, 1 };
        vkCmdCopyBufferToImage(cb, staging, *outImg,
            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &r);
        endOneShot(cb);
    }

    // layout: TRANSFER_DST_OPTIMAL -> SHADER_READ_ONLY_OPTIMAL
    {
        VkCommandBuffer cb = beginOneShot();
        VkImageMemoryBarrier bar{ VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER };
        bar.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        bar.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        bar.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        bar.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        bar.image = *outImg;
        bar.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        bar.subresourceRange.baseMipLevel = 0; bar.subresourceRange.levelCount = 1;
        bar.subresourceRange.baseArrayLayer = 0; bar.subresourceRange.layerCount = 1;
        bar.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        bar.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
        vkCmdPipelineBarrier(cb,
            VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
            0, 0,nullptr, 0,nullptr, 1,&bar);
        endOneShot(cb);
    }

    // cleanup staging
    vkFreeMemory  (vkDevice, stagingMem, nullptr);
    vkDestroyBuffer(vkDevice, staging,    nullptr);

    // image view + sampler
    {
        VkImageViewCreateInfo vi{ VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO };
        vi.image = *outImg;
        vi.viewType = VK_IMAGE_VIEW_TYPE_2D;
        vi.format = VK_FORMAT_R8G8B8A8_UNORM;
        vi.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        vi.subresourceRange.levelCount = 1;
        vi.subresourceRange.layerCount = 1;
        vkCreateImageView(vkDevice, &vi, nullptr, outView);

        VkSamplerCreateInfo si{ VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO };
        si.magFilter = VK_FILTER_LINEAR;
        si.minFilter = VK_FILTER_LINEAR;
        si.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
        si.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
        si.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
        si.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
        si.maxAnisotropy = 16.0f;
        vkCreateSampler(vkDevice, &si, nullptr, outSampler);
    }
    return VK_SUCCESS;
}

VkResult initialize(void)
{
	// function declaration
	VkResult createVulkanInstance(void);
	VkResult getSupportedSurface(void);
	VkResult getPhysicalDevice(void);
	VkResult printVKInfo(void);
	VkResult createVulkanDevice(void);
	void getDeviceQueue(void);
	VkResult createSwapchain(VkBool32);
	VkResult createImagesAndImageViews(void);
	VkResult createCommandPool(void);
	VkResult createCommandBuffers(void);
	VkResult createVertexBuffer(void);
	VkResult createTexture(const char *[]);
	VkResult createTexture2D(const char* path, VkImage* outImg, VkDeviceMemory* outMem, VkImageView* outView, VkSampler* outSampler);
	VkResult createUniformBuffer(void);
	VkResult createShaders(void);
	VkResult createDescriptorSetLayout(void);
	VkResult createPipelineLayout(void);
	VkResult createDescriptorPool(void);
	VkResult createDescriptorSet(void);
	VkResult createRenderpass(void);
	VkResult createPipeline(void);
	VkResult createFrameBuffers(void);
	VkResult createSemaphore(void);
	VkResult createFences(void);
	VkResult buildCommandBuffers(void);



	// variable declaration
	VkResult vkResult = VK_SUCCESS;
	
	SetOverlaySizeFrac(0.40f); // 0.40 or 40% of min(screenW, screenH)
	
	// Code
	vkResult = createVulkanInstance();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createVulkanInstance() is failed\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createVulkanInstance() Succeeded\n");
	}

	// Create vulkan presentation surface
	vkResult = getSupportedSurface();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> getSupportedSurface() is failed\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> getSupportedSurface() Succeeded\n");
	}


	// Select required physical device and its queue family index
	vkResult = getPhysicalDevice();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> getPhysicalDevice() is failed %d\n", vkResult);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> getPhysicalDevice() Succeeded\n");
	}

	// Print Vulkan info
	vkResult = printVKInfo();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> printVKInfo() is failed %d\n", vkResult);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> printVKInfo() Succeeded\n");
	}

	vkResult = createVulkanDevice();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createVulkanDevice() is failed %d\n", vkResult);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createVulkanDevice() Succeeded\n");
	}

	// Get device queue
	getDeviceQueue();


	vkResult = createSwapchain(VK_FALSE);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createSwapchain() is failed %d\n", vkResult);
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createSwapchain() Succeeded\n");
	}

	// create vulkan images and view
	vkResult = createImagesAndImageViews();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createImagesAndImageViews() is failed %d\n", vkResult);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createImagesAndImageViews() gave swapchin image count %d (Succeeded)\n", swapchainImageCount);
	}

	// command pool
	vkResult = createCommandPool();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createCommandPool() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createCommandPool() Succeeded\n");
		fflush(gpFILE);
	}

	// Create command buffers
	vkResult = createCommandBuffers();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createCommandBuffers() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createCommandBuffers() Succeeded\n");
		fflush(gpFILE);
	}

	// create vertex buffer
	vkResult = createVertexBuffer();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createVertexBuffer() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createVertexBuffer() Succeeded\n");
		fflush(gpFILE);
	}

	// Create Texture
	vkResult = createTexture(images);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createTexture() for kundali is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createTexture() for kundali Succeeded\n");
		fflush(gpFILE);
	}
	
	/*
	vkResult = createTexture2D(gOverlayTexPath, &vkImage_overlayTexture, &vkDeviceMemory_overlayTexture, &vkImageView_overlayTexture, &vkSampler_overlayTexture);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createTexture2D(1_Mesh.png) failed %d\n", vkResult);
		return vkResult;
	}
	else
	{
		fprintf(gpFILE, "initialize() ->  createTexture2D(1_Mesh.png) for kundali Succeeded\n");
		fflush(gpFILE);
	}
	
	
	vkResult = createTexture2D(
			gOverlayTexPath2,
			&vkImage_overlayTexture2,
			&vkDeviceMemory_overlayTexture2,
			&vkImageView_overlayTexture2,
			&vkSampler_overlayTexture2);
			
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createTexture2D(%s) failed (%d), trying fallback 02_Vrushabh.png\n", gOverlayTexPath2, vkResult);
	}
	else
	{
		fprintf(gpFILE, "initialize() -> createTexture2D(%s) Succeeded\n", gOverlayTexPath2);
	}
	*/

	// create UinformBuffer
	vkResult = createUniformBuffer();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createUniformBuffer() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createUniformBuffer() Succeeded\n");
		fflush(gpFILE);
	}

	vkResult = createShaders();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createShaders() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createShaders() Succeeded\n");
		fflush(gpFILE);
	}

	// descriptorset layout
	vkResult = createDescriptorSetLayout();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createDescriptorSetLayout() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createDescriptorSetLayout() Succeeded\n");
		fflush(gpFILE);
	}

	// 
	vkResult = createPipelineLayout();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createPipelineLayout() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createPipelineLayout() Succeeded\n");
		fflush(gpFILE);
	}

	// create Descriptor Pool
	vkResult = createDescriptorPool();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createDescriptorPool() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createDescriptorPool() Succeeded\n");
		fflush(gpFILE);
	}
	
	// Load the 12 overlay textures (one per pan stop)
	for (int i = 0; i < kOverlayCount; ++i)
	{
		VkResult ov = createTexture2D(
			gOverlayPaths[i],
			&gOverlayImages[i],
			&gOverlayMem[i],
			&gOverlayViews[i],
			&gOverlaySamplers[i]);

		if (ov != VK_SUCCESS) {
			fprintf(gpFILE, "initialize() -> createTexture2D(%s) FAILED (%d)\n",
					gOverlayPaths[i], ov);
			// Optional: choose a fallback image here.
		} else {
			fprintf(gpFILE, "initialize() -> overlay[%d] loaded: %s\n",
					i, gOverlayPaths[i]);
		}
	}

	// create Descriptor Set
	vkResult = createDescriptorSet();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createDescriptorSet() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createDescriptorSet() Succeeded\n");
		fflush(gpFILE);
	}
	
	// Make sure the first overlay (01_Mesh) is bound initially
	BindOverlayTexture(0);

	// Create renderpass
	vkResult = createRenderpass();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createRenderpass() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createRenderpass() Succeeded\n");
		fflush(gpFILE);
	}

	vkResult = createPipeline();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createPipeline() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createPipeline() Succeeded\n");
		fflush(gpFILE);
	}

	vkResult = createFrameBuffers();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createFrameBuffer() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createFrameBuffer() Succeeded\n");
		fflush(gpFILE);
	}

	vkResult = createSemaphore();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createSemaphore() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createSemaphore() Succeeded\n");
		fflush(gpFILE);
	}

	// Create fences
	vkResult = createFences();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createFences() is failed %d\n", vkResult);
		fflush(gpFILE);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "initialize() -> createFences() Succeeded\n");
		fflush(gpFILE);
	}

	//Initialize clear color value
	memset((void*)&vkClearColorValue, 0, sizeof(VkClearColorValue));

	vkClearColorValue.float32[0] = 0.0f;
	vkClearColorValue.float32[1] = 0.0f;
	vkClearColorValue.float32[2] = 0.0f;
	vkClearColorValue.float32[3] = 1.0f; // analogouse to glClearcolor


	memset((void*)&vkClearDepthStencilValue, 0, sizeof(VkClearDepthStencilValue));
	// Set default clear depth
	vkClearDepthStencilValue.depth = 1.0f; // float

	// Set default stencil value
	vkClearDepthStencilValue.stencil = 0; // uint32_t

	// build command buffers
	vkResult = buildCommandBuffers();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> buildCommandBuffers() is failed %d\n", vkResult);
		
	}
	else{
		fprintf(gpFILE, "initialize() -> buildCommandBuffers() Succeeded\n");
	}

	// Initialization is completed
	bInitialized = TRUE;

	fprintf(gpFILE, "initialize() -> Initialization Completed Successfully\n");

	fprintf(gpFILE, "\n*********************************************************************************************************\n\n");

	// NEW: kick off timed camera panning
	timeBeginPeriod(1);
	srand((unsigned)timeGetTime());
	BeginNewPan();

	//PlaySound(MAKEINTRESOURCE(MYAUDIO), NULL, SND_ASYNC | SND_RESOURCE);
	
	return vkResult;
}

VkResult resize(int width, int height)
{
	// Function Declartion
	VkResult createSwapchain(VkBool32);
	VkResult createImagesAndImageViews(void);
	VkResult createCommandBuffers(void);
	VkResult createPipelineLayout(void);
	VkResult createRenderpass(void);
	VkResult createPipeline(void);
	VkResult createFrameBuffers(void);
	VkResult buildCommandBuffers(void);
	

	// Variable declaration
	VkResult vkResult = VK_SUCCESS;

	// code
	if (height <= 0)
	{
		height = 1;
	}

	// Check the bInitialized variable
	if(bInitialized == FALSE){
		fprintf(gpFILE, "resize() -> initialization yet not completed\n");
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}

	// As recreation of swapchain needed we are going to repeat many step of initialize again, hence set bInitialization = FALSE again
	bInitialized = FALSE;

	// Set global WIN_WIDTH and WIN_HEIGHT variable
	winWidth 	= width;
	winHeight 	= height;

	// wait for device to complete in hand task
	vkDeviceWaitIdle(vkDevice);

	// if(vkDevice){
	// 	vkDeviceWaitIdle(vkDevice);
	// }

	// Check presence of swapchain
	if(vkSwapchainKHR == VK_NULL_HANDLE){
		fprintf(gpFILE, "resize() -> swapchain is already NULL, cannot proceed\n");
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}

	// Destroy frameBuffer
	for(uint32_t i=0; i<swapchainImageCount; i++){
		vkDestroyFramebuffer(vkDevice, vkFramebuffer_array[i], NULL);
	}

	if(vkFramebuffer_array){
		free(vkFramebuffer_array);
		vkFramebuffer_array = NULL;
		fprintf(gpFILE, "resize() -> vkFramebuffer_array free\n");
	}

	if(vkRenderPass){
		vkDestroyRenderPass(vkDevice, vkRenderPass, NULL);
		vkRenderPass = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDestroyRenderPass\n");
	}


	//  Destroy Pipeline
	if(vkPipeline){
		vkDestroyPipeline(vkDevice, vkPipeline, NULL);
		vkPipeline = VK_NULL_HANDLE;
		fprintf(gpFILE, "resize() -> vkDestroyPipeline() free\n");
	}

	

	// Destroy pipeline layout
	if(vkPipelineLayout){
		vkDestroyPipelineLayout(vkDevice, vkPipelineLayout, NULL);
		vkPipelineLayout = VK_NULL_HANDLE;
		fprintf(gpFILE, "resize() -> vkDestroyPipelineLayout() free\n");
	}

	// Destroy command buffer
	for(uint32_t i = 0; i< swapchainImageCount; i++){
		vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_array[i]);
		fprintf(gpFILE, "resize() -> vkFreeCommandBuffers() is succeeded %d\n", i);
	}

	if(vkImageView_depth){
		vkDestroyImageView(vkDevice, vkImageView_depth, NULL);
		vkImageView_depth = VK_NULL_HANDLE;
		//fprintf(gpFILE, "resize() -> vkDestroyImageView for depth\n");
	}

	if(vkDeviceMemory_depth){
		vkFreeMemory(vkDevice, vkDeviceMemory_depth, NULL);
		vkDeviceMemory_depth = VK_NULL_HANDLE;
		//fprintf(gpFILE, "resize() ->vkDeviceMemory_depth\n");
	}

	if(vkImage_depth){
		vkDestroyImage(vkDevice, vkImage_depth, NULL);
		vkImage_depth = VK_NULL_HANDLE;
		//fprintf(gpFILE, "resize() ->vkImage_depth\n");
	}

	if(vkCommandBuffer_array){
		free(vkCommandBuffer_array);
		vkCommandBuffer_array = NULL;
		fprintf(gpFILE, "resize() -> vkCommandBuffer_array free\n");
	}

	// Destroy
	for(uint32_t i = 0; i< swapchainImageCount; i++){
		vkDestroyImageView(vkDevice, swapchainImageView_array[i], NULL);
		fprintf(gpFILE, "resize() -> vkDestroyImageView() is succeeded %d\n", i);
	}

	if(swapchainImageView_array){
		free(swapchainImageView_array);
		swapchainImageView_array = NULL;
		fprintf(gpFILE, "resize() -> swapchainImageView_array free\n");
	}

	// Free swapchain images (validation error)
	// for(uint32_t i = 0; i< swapchainImageCount; i++){
	// 	vkDestroyImage(vkDevice, swapchainImage_array[i], NULL);
	// 	fprintf(gpFILE, "resize() -> vkDestroyImage() is succeeded %d\n", i);
	// }

	// step 8 -> destroy swapchain image array(8)
	if(swapchainImage_array){
		free(swapchainImage_array);
		swapchainImage_array = NULL;
		fprintf(gpFILE, "resize() -> swapchainImage_array free\n");
	}

	// Destroy swapchain
	if(vkSwapchainKHR){
		vkDestroySwapchainKHR(vkDevice, vkSwapchainKHR, NULL);
		vkSwapchainKHR = VK_NULL_HANDLE;
		fprintf(gpFILE, "resize() -> vkDestroySwapchainKHR is Done\n");
	}


	// Recreate for resize
	vkResult = createSwapchain(VK_FALSE);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "resize() -> createSwapchain() is failed %d\n", vkResult);
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}

	// create vulkan images and view
	vkResult = createImagesAndImageViews();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "resize() -> createImagesAndImageViews() is failed %d\n", vkResult);
		return vkResult;
	}

	vkResult = createCommandBuffers();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "resize() -> createCommandBuffers() is failed %d\n", vkResult);
		return vkResult;
	}

	vkResult = createPipelineLayout();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "resize() -> createPipelineLayout() is failed %d\n", vkResult);
		return vkResult;
	}

	vkResult = createRenderpass();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createRenderpass() is failed %d\n", vkResult);
		return vkResult;
	}

	vkResult = createPipeline();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createPipeline() is failed %d\n", vkResult);
		return vkResult;
	}

	

	vkResult = createFrameBuffers();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> createFrameBuffer() is failed %d\n", vkResult);
		return vkResult;
	}

	vkResult = buildCommandBuffers();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "initialize() -> buildCommandBuffers() is failed %d\n", vkResult);
		
	}

	bInitialized = TRUE;

	return vkResult;
}



VkResult display(void)
{
	// Function declarations
	VkResult resize(int, int);
	VkResult updateUniformBuffer(void);
	VkResult buildCommandBuffers(void);

	// Variable declaration
	VkResult vkResult = VK_SUCCESS;

	// Code
	// if control comes here before initialization is completed, return false
	if(bInitialized == FALSE){
		//fprintf(gpFILE, "display() -> initialization yet not completed\n");
		return (VkResult)VK_FALSE;
	}

	// acquired index of next swapchain image
	// if this function could not retrieve given image within given timeout nanoseconds amount, then it will return VK_NOT_READY
	vkResult = vkAcquireNextImageKHR
	(
		vkDevice,				// our vulkan logical device
		vkSwapchainKHR,			// from which swapchain to acquire next image?
		UINT64_MAX,				// maybe we cant acquire this image immediately from swapchain, in that case, how much time to wait for acquiring image from swapchain (in nanoseconds)
		vkSemaphore_backBuffer,	// back buffer semaphore -> we wait here for release of swapchain image from previous operation with previous queue
		VK_NULL_HANDLE,			// our fence, NULL FOR THIS CALL!!! -> if we want to hold our host while we wait for our swapchain image, then use fence here
		&currentImageIndex		// address of variable holding our current image index
	);

	if(vkResult != VK_SUCCESS){
		if(vkResult == VK_ERROR_OUT_OF_DATE_KHR || vkResult == VK_SUBOPTIMAL_KHR){
			resize(winWidth, winHeight);
		}
		else{
			fprintf(gpFILE, "display() -> vkAcquireNextImageKHR() failed\n");
			return vkResult;
		}
	}
	else{
		// no fprintf() here since we are in a loop and it will increase our log file size
	}

	// use fence to allow host to wait for completion of the excution previous command buffer
	vkResult = vkWaitForFences(vkDevice, 1, &vkFence_array[currentImageIndex], VK_TRUE, UINT64_MAX);
	if(vkResult != VK_SUCCESS){
		fprintf(gpFILE, "display() -> vkWaitForFences() failed\n");
		return vkResult;
	}
	else{
		// no fprintf() here since we are in a loop and it will increase our log file size
	}

	// now ready the fences for next command buffer
	vkResult = vkResetFences
	(
		vkDevice,								// our vulkan logical device
		1,										// how many fences to wait for, though we have array we are waiting for 1 array
		&vkFence_array[currentImageIndex]		// which fence to wait for
	);
	if(vkResult != VK_SUCCESS){
		fprintf(gpFILE, "display() -> vkResetFences failed\n");
		return vkResult;
	}
	else{
		// no fprintf() here since we are in a loop and it will increase our log file size
	}

	// >>> ADD THIS BLOCK HERE: re-record if descriptors were updated <<<
    if (gCmdBuffersDirty) {
        VkResult r = buildCommandBuffers();
        if (r != VK_SUCCESS) {
            fprintf(gpFILE, "display() -> buildCommandBuffers() after descriptor update failed %d\n", r);
            return r;
        }
        gCmdBuffersDirty = false;
    }
    // <<< END ADDITION >>>

	// one of the member of vkSubmit info structure requires array of pipeline stages we have only one of completion of color attachment output still we need one member array
	const VkPipelineStageFlags waitDSTStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;

	// declare memset and initialize VkSubmitInfo structure
	VkSubmitInfo vkSubmitInfo;

	memset((void*)&vkSubmitInfo, 0, sizeof(VkSubmitInfo));

	vkSubmitInfo.sType 					= VK_STRUCTURE_TYPE_SUBMIT_INFO;
	vkSubmitInfo.pNext 					= NULL;
	vkSubmitInfo.pWaitDstStageMask 		= &waitDSTStageMask;
	vkSubmitInfo.waitSemaphoreCount 	= 1;
	vkSubmitInfo.pWaitSemaphores 		= &vkSemaphore_backBuffer;
	vkSubmitInfo.commandBufferCount 	= 1;
	vkSubmitInfo.pCommandBuffers 		= &vkCommandBuffer_array[currentImageIndex];
	vkSubmitInfo.signalSemaphoreCount 	= 1;
	vkSubmitInfo.pSignalSemaphores 		= &vkSemaphore_renderComplete;

	// Now submit above work to the queue
	vkResult = vkQueueSubmit(vkQueue, 1, &vkSubmitInfo, vkFence_array[currentImageIndex]);
	if(vkResult != VK_SUCCESS){
		fprintf(gpFILE, "display() -> vkQueueSubmit() failed\n");
		return vkResult;
	}
	else{
		// no fprintf() here since we are in a loop and it will increase our log file size
	}

	// we are gong to present render image after declaring and initializing 
	VkPresentInfoKHR vkPresentInfoKHR;
	memset((void*)&vkPresentInfoKHR, 0, sizeof(VkPresentInfoKHR));

	vkPresentInfoKHR.sType 				= VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
	vkPresentInfoKHR.pNext 				= NULL;
	vkPresentInfoKHR.swapchainCount 	= 1;
	vkPresentInfoKHR.pSwapchains 		= &vkSwapchainKHR;
	vkPresentInfoKHR.pImageIndices 		= &currentImageIndex;
	vkPresentInfoKHR.waitSemaphoreCount = 1;
	vkPresentInfoKHR.pWaitSemaphores 	= &vkSemaphore_renderComplete;
	
	// present the queue
	vkResult = vkQueuePresentKHR(vkQueue, &vkPresentInfoKHR);
	if(vkResult != VK_SUCCESS){
		if(vkResult == VK_ERROR_OUT_OF_DATE_KHR || vkResult == VK_SUBOPTIMAL_KHR){
			resize(winWidth, winHeight);
		}
		else{
			fprintf(gpFILE, "display() -> vkQueuePresentKHR() failed\n");
			return vkResult;
		}
	}
	else{
		// no fprintf() here since we are in a loop and it will increase our log file size
	}

	vkResult = updateUniformBuffer();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "display() -> updateUniformBuffer() is failed %d\n", vkResult);
		return vkResult;
	}
	else{
		//fprintf(gpFILE, "display() -> updateUniformBuffer() Succeeded\n");
	}

	vkDeviceWaitIdle(vkDevice);

	return vkResult;

}

void update(void)
{
	// code
	UpdateCameraAnim();
}

void uninitialize()
{
	// function declarations
	void ToggleFullscreen(void);

	// code
	// NEW: restore timer resolution
	timeEndPeriod(1);

	
	// if application exiting full screen
	if (gbFullscreen == TRUE)
	{
		ToggleFullscreen();
		gbFullscreen = FALSE;
	}
	
	// get read of window handle
	if (ghwnd)
	{
		DestroyWindow(ghwnd);
		ghwnd = NULL;
	}

	
	// **********************************
	
	// Overlays
	for (int i = 0; i < kOverlayCount; ++i) {
		if (gOverlaySamplers[i]) { vkDestroySampler  (vkDevice, gOverlaySamplers[i],  nullptr); gOverlaySamplers[i] = VK_NULL_HANDLE; }
		if (gOverlayViews[i])    { vkDestroyImageView(vkDevice, gOverlayViews[i],     nullptr); gOverlayViews[i]    = VK_NULL_HANDLE; }
		if (gOverlayMem[i])      { vkFreeMemory      (vkDevice, gOverlayMem[i],       nullptr); gOverlayMem[i]      = VK_NULL_HANDLE; }
		if (gOverlayImages[i])   { vkDestroyImage    (vkDevice, gOverlayImages[i],    nullptr); gOverlayImages[i]   = VK_NULL_HANDLE; }
	}

	// Destroy fences
	for(uint32_t i=0; i<swapchainImageCount; i++){
		vkDestroyFence(vkDevice, vkFence_array[i], NULL);
	}

	if(vkFence_array){
		free(vkFence_array);
		vkFence_array = NULL;
		fprintf(gpFILE, "uninitialize() -> vkFence_array free\n");
	}

	if(vkSemaphore_renderComplete){
		vkDestroySemaphore(vkDevice, vkSemaphore_renderComplete, NULL);
		vkSemaphore_renderComplete = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkSemaphore_renderComplete free\n");
	}

	if(vkSemaphore_backBuffer){
		vkDestroySemaphore(vkDevice, vkSemaphore_backBuffer, NULL);
		vkSemaphore_backBuffer = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkSemaphore_backBuffer free\n");
	}

	for(uint32_t i=0; i<swapchainImageCount; i++){
		vkDestroyFramebuffer(vkDevice, vkFramebuffer_array[i], NULL);
	}

	if(vkFramebuffer_array){
		free(vkFramebuffer_array);
		vkFramebuffer_array = NULL;
		fprintf(gpFILE, "uninitialize() -> vkFramebuffer_array free\n");
	}

	if(vkDescriptorSetLayout){
		vkDestroyDescriptorSetLayout(vkDevice, vkDescriptorSetLayout, NULL);
		vkDescriptorSetLayout = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDescriptorSetLayout free\n");
	}
	
	if(vkPipelineLayout){
		vkDestroyPipelineLayout(vkDevice, vkPipelineLayout, NULL);
		vkPipelineLayout = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDestroyPipelineLayout() free\n");
	}

	if(vkPipeline){
		vkDestroyPipeline(vkDevice, vkPipeline, NULL);
		vkPipeline = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDestroyPipeline() free\n");
	}

	if(vkRenderPass){
		vkDestroyRenderPass(vkDevice, vkRenderPass, NULL);
		vkRenderPass = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDestroyRenderPass\n");
	}

	// Destroy descriptor pool
	// When descripor pool is destroed descripted sets created by that pool get destroyed implicitly
	if(vkDescriptorPool){
		vkDestroyDescriptorPool(vkDevice, vkDescriptorPool, NULL);
		vkDescriptorPool = VK_NULL_HANDLE;
		vkDescriptorSet = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDescriptorPool and vkDescriptorSet are destroyed\n");
	}


	if(vkShaderModule_fragment_shader){
		vkDestroyShaderModule(vkDevice, vkShaderModule_fragment_shader, NULL);
		vkShaderModule_fragment_shader = NULL;
		fprintf(gpFILE, "uninitialize() -> vkDestroyShaderModule() fragment shader\n");
	}

	if(vkShaderModule_vertex_shader){
		vkDestroyShaderModule(vkDevice, vkShaderModule_vertex_shader, NULL);
		vkShaderModule_vertex_shader = NULL;
		fprintf(gpFILE, "uninitialize() -> vkDestroyShaderModule() vertex shader\n");
	}

	if(uniformData.vkDeviceMemory){
		vkFreeMemory(vkDevice, uniformData.vkDeviceMemory, NULL);
		uniformData.vkDeviceMemory = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkFreeMemory(), uniformData.vkDeviceMemory\n");
	}
	

	// Destroy uniform buffer
	if(uniformData.vkBuffer){
		vkDestroyBuffer(vkDevice, uniformData.vkBuffer, NULL);
		uniformData.vkBuffer = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDestroyBuffer(), uniformData.vkBuffer\n");
	}

	// Destroy texture sampler
	if(vkSampler_texture)
	{
		vkDestroySampler(vkDevice, vkSampler_texture, NULL);
		vkSampler_texture = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDestroySampler()\n");
	}

	if(vkImageView_texture)
	{
		vkDestroyImageView(vkDevice, vkImageView_texture, NULL);
		vkImageView_texture = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDestroyImageView()\n");
	}

	if(vkDeviceMemory_texture)
	{
		vkFreeMemory(vkDevice, vkDeviceMemory_texture, NULL);
		vkDeviceMemory_texture = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDeviceMemory_texture()\n");
	}

	if(vkImage_texture)
	{
		vkDestroyImage(vkDevice, vkImage_texture, NULL);
		vkImage_texture = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkImage_texture\n");
	}

	// color buffer
	if(vertexData_texcoord.vkDeviceMemory){
		vkFreeMemory(vkDevice, vertexData_texcoord.vkDeviceMemory, NULL);
		vertexData_texcoord.vkDeviceMemory = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vertexData_texcoord.vkDeviceMemory\n");
	}

	if(vertexData_texcoord.vkBuffer){
		vkDestroyBuffer(vkDevice, vertexData_texcoord.vkBuffer, NULL);
		vertexData_texcoord.vkBuffer = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vertexData_texcoord.vkBuffer\n");
	}

	//positiom buffer
	if(vertexData_position.vkDeviceMemory){
		vkFreeMemory(vkDevice, vertexData_position.vkDeviceMemory, NULL);
		vertexData_position.vkDeviceMemory = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vertexData_position.vkDeviceMemory\n");
	}

	if(vertexData_position.vkBuffer){
		vkDestroyBuffer(vkDevice, vertexData_position.vkBuffer, NULL);
		vertexData_position.vkBuffer = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vertexData_position.vkBuffer\n");
	}

	for(uint32_t i = 0; i< swapchainImageCount; i++){
		vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_array[i]);
		fprintf(gpFILE, "uninitialize() -> vkFreeCommandBuffers() is succeeded %d\n", i);
	}

	if(vkImageView_depth){
		vkDestroyImageView(vkDevice, vkImageView_depth, NULL);
		vkImageView_depth = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDestroyImageView for depth\n");
	}

	if(vkDeviceMemory_depth){
		vkFreeMemory(vkDevice, vkDeviceMemory_depth, NULL);
		vkDeviceMemory_depth = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() ->vkDeviceMemory_depth\n");
	}

	if(vkImage_depth){
		vkDestroyImage(vkDevice, vkImage_depth, NULL);
		vkImage_depth = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() ->vkImage_depth\n");
	}

	if(vkCommandBuffer_array){
		free(vkCommandBuffer_array);
		vkCommandBuffer_array = NULL;
		fprintf(gpFILE, "uninitialize() -> vkCommandBuffer_array free\n");
	}

	if(vkCommandPool){
		vkDestroyCommandPool(vkDevice, vkCommandPool, NULL);
		vkCommandPool = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkCommandPool free\n");
	}


	// Destroy image views(9)
	for(uint32_t i = 0; i< swapchainImageCount; i++){
		vkDestroyImageView(vkDevice, swapchainImageView_array[i], NULL);
		fprintf(gpFILE, "uninitialize() -> vkDestroyImageView() is succeeded %d\n", i);
	}

	// free a(10)
	if(swapchainImageView_array){
		free(swapchainImageView_array);
		swapchainImageView_array = NULL;
		fprintf(gpFILE, "uninitialize() -> swapchainImageView_array free\n");
	}

	// Free swapchain images
	// for(uint32_t i = 0; i< swapchainImageCount; i++){
	// 	vkDestroyImage(vkDevice, swapchainImage_array[i], NULL);
	// 	fprintf(gpFILE, "uninitialize() -> vkDestroyImage() is succeeded %d\n", i);
	// }

	// step 8 -> destroy swapchain image array(8)
	if(swapchainImage_array){
		free(swapchainImage_array);
		swapchainImage_array = NULL;
		fprintf(gpFILE, "uninitialize() -> swapchainImage_array free\n");
	}

	
	// Destroy swapchain
	if(vkSwapchainKHR){
		vkDestroySwapchainKHR(vkDevice, vkSwapchainKHR, NULL);
		vkSwapchainKHR = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDestroySwapchainKHR is Done\n");
	}


	// Destroy vulkan device
	if(vkDevice){
		vkDeviceWaitIdle(vkDevice);
		fprintf(gpFILE, "uninitialize() -> vkDeviceWaitIdle is Done\n");
		vkDestroyDevice(vkDevice, NULL);
		vkDevice = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDestroyDevice is Done\n");
	}


	// No need to destrot selected physical device

	if(vkSurfaceKHR)
	{
		vkDestroySurfaceKHR(vkInstance, vkSurfaceKHR, NULL);
		fprintf(gpFILE, "uninitialize() -> vkDestroySurfaceKHR() succeeded\n");
	}

	if(vkDebugReportCallbackEXT && vkDestroyDebugReportCallbackEXT_fnptr){
		vkDestroyDebugReportCallbackEXT_fnptr(vkInstance, vkDebugReportCallbackEXT, NULL);
		vkDebugReportCallbackEXT = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize() -> vkDebugReportCallbackEXT() succeeded\n");
	}

	// Destroy vulkan instance
	if(vkInstance)
	{
		vkDestroyInstance(vkInstance, NULL);
		vkInstance = VK_NULL_HANDLE;
		fprintf(gpFILE, "uninitialize -> vkDestroyInstance() succeeded \n");
	}

	// close the log file
	if (gpFILE)
	{
		fprintf(gpFILE, "\n-----------------Program Ended Successfully---------------------\n\n");
		fclose(gpFILE);
		gpFILE = NULL;
	}


}

//////////////////////////////////////////////// Definition of vulkan related functions //////////////////////////////////////////////

VkResult createVulkanInstance(void)
{
	// function declaration
	VkResult fillInstanceExtensionNames(void);
	VkResult fillValidationLayerNames(void);
	VkResult createValidationCallbackFunction(void);

	// variable declaration
	VkResult vkResult = VK_SUCCESS;

	// Code
	vkResult = fillInstanceExtensionNames();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVulkanInstance() -> fillInstanceExtensionNames() is failed\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createVulkanInstance() -> fillInstanceExtensionNames() Succeeded\n");
	}

	if(bValidation == TRUE)
	{
		// fill the validatiotn
		vkResult = fillValidationLayerNames();
		if (vkResult != VK_SUCCESS)
		{
			fprintf(gpFILE, "createVulkanInstance() -> fillValidationLayerNames() is failed\n");
			return vkResult;
		}
		else{
			fprintf(gpFILE, "createVulkanInstance() -> fillValidationLayerNames() Succeeded\n");
		}
	}
	
	// step 2
	VkApplicationInfo vkApplicationInfo;
	memset((void*)&vkApplicationInfo, 0, sizeof(VkApplicationInfo));

	vkApplicationInfo.sType 				= VK_STRUCTURE_TYPE_APPLICATION_INFO;
	vkApplicationInfo.pNext 				= NULL;
	vkApplicationInfo.pApplicationName 		= gpszAppName;
	vkApplicationInfo.applicationVersion 	= 1;
	vkApplicationInfo.pEngineName 			= gpszAppName;
	vkApplicationInfo.engineVersion 		= 1;
	vkApplicationInfo.apiVersion 			= VK_API_VERSION_1_4; // 

	// Step 3
	VkInstanceCreateInfo vkInstanceCreateInfo;
	memset((void*)&vkInstanceCreateInfo, 0, sizeof(VkInstanceCreateInfo));

	vkInstanceCreateInfo.sType 						= VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
	vkInstanceCreateInfo.pNext 						= NULL;
	vkInstanceCreateInfo.pApplicationInfo 			= &vkApplicationInfo;
	vkInstanceCreateInfo.enabledExtensionCount 		= enableInstanceExtensionCount;
	vkInstanceCreateInfo.ppEnabledExtensionNames 	= enabledInstanceExtensionNames_array;
	
	if(bValidation == TRUE){
		vkInstanceCreateInfo.enabledLayerCount 		= enabledValidationLayerCount;
		vkInstanceCreateInfo.ppEnabledLayerNames 	= enabledValidationLayerNames_array;
	}
	else{
		vkInstanceCreateInfo.enabledLayerCount 		= 0;
		vkInstanceCreateInfo.ppEnabledLayerNames 	= NULL;
	}

	// step 4
	vkResult = vkCreateInstance(&vkInstanceCreateInfo, NULL, &vkInstance);
	if(vkResult == VK_ERROR_INCOMPATIBLE_DRIVER)
	{
		fprintf(gpFILE, "createVulkanInstance() -> vkCreateInstance() failed due to incompatible driver(%d)\n", vkResult);
		return vkResult;
	}
	else if(vkResult == VK_ERROR_EXTENSION_NOT_PRESENT)
	{
		fprintf(gpFILE, "createVulkanInstance() -> vkCreateInstance() failed due to required extension not present (%d)\n", vkResult);
		return vkResult;
	}
	else if(vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVulkanInstance() -> vkCreateInstance() failed due to unknown reason(%d)\n", vkResult);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createVulkanInstance() -> vkCreateInstance() succeeded\n");
	}

	// Do for validation callbacks
	if(bValidation == TRUE){
		vkResult = createValidationCallbackFunction();
		if (vkResult != VK_SUCCESS)
		{
			fprintf(gpFILE, "createVulkanInstance() -> createValidationCallbackFunction() function is failed\n");
			return vkResult;
		}
		else{
			fprintf(gpFILE, "createVulkanInstance() -> createValidationCallbackFunction() Succeeded\n");
		}
	}

	return vkResult;
}

VkResult fillInstanceExtensionNames(void)
{
	// variable declaration
	VkResult vkResult = VK_SUCCESS;

	// step 1
	uint32_t instanceExtensionCount = 0;

	vkResult = vkEnumerateInstanceExtensionProperties(NULL, &instanceExtensionCount, NULL);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "fillInstanceExtensionNames() -> Fisrt Call to vkEnumerateInstanceExtensionProperties function is failed\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "fillInstanceExtensionNames() -> Fisrt Call to vkEnumerateInstanceExtensionProperties Succeeded\n");
	}

	// step 2
	VkExtensionProperties* vkExtensionProperties_array = NULL;

	vkExtensionProperties_array = (VkExtensionProperties*)malloc(sizeof(VkExtensionProperties)*instanceExtensionCount); // Real production code required error checking for malloc
	
	vkResult = vkEnumerateInstanceExtensionProperties(NULL, &instanceExtensionCount, vkExtensionProperties_array);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "fillInstanceExtensionNames() -> Secound Call to vkEnumerateInstanceExtensionProperties function is failed\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "fillInstanceExtensionNames() -> Secound Call to vkEnumerateInstanceExtensionProperties Succeeded\n");
	}

	// step 3
	char** instanceExtensionNames_array = NULL;

	instanceExtensionNames_array = (char**)malloc(sizeof(char*)*instanceExtensionCount);

	for(uint32_t i = 0; i<instanceExtensionCount; i++)
	{
		instanceExtensionNames_array[i] = (char*)malloc(sizeof(char)*strlen(vkExtensionProperties_array[i].extensionName) + 1);
		memcpy(instanceExtensionNames_array[i], vkExtensionProperties_array[i].extensionName, strlen(vkExtensionProperties_array[i].extensionName) + 1);

		fprintf(gpFILE, "fillInstanceExtensionNames() -> vulkan extension name = %s\n", instanceExtensionNames_array[i]);
	}

	// Step 4
	free(vkExtensionProperties_array);
	vkExtensionProperties_array = NULL;

	// Step 5
	VkBool32 vulkanSurfaceExtensionFound = VK_FALSE;
	VkBool32 win32SurfaceExtensionFound = VK_FALSE;
	VkBool32 debugReportExtensionFound = VK_FALSE;

	for(uint32_t i = 0; i<instanceExtensionCount; i++)
	{
		if(strcmp(instanceExtensionNames_array[i], VK_KHR_SURFACE_EXTENSION_NAME) == 0)
		{
			vulkanSurfaceExtensionFound = VK_TRUE;

			enabledInstanceExtensionNames_array[enableInstanceExtensionCount++] = VK_KHR_SURFACE_EXTENSION_NAME;
		}

		if(strcmp(instanceExtensionNames_array[i], VK_KHR_WIN32_SURFACE_EXTENSION_NAME) == 0)
		{
			win32SurfaceExtensionFound = VK_TRUE;

			enabledInstanceExtensionNames_array[enableInstanceExtensionCount++] = VK_KHR_WIN32_SURFACE_EXTENSION_NAME;
		}

		if(strcmp(instanceExtensionNames_array[i], VK_EXT_DEBUG_REPORT_EXTENSION_NAME) == 0)
		{
			debugReportExtensionFound = VK_TRUE;
			if(bValidation == TRUE){
				enabledInstanceExtensionNames_array[enableInstanceExtensionCount++] = VK_EXT_DEBUG_REPORT_EXTENSION_NAME;
			}
			else{
				// array will not have entry VK_EXT_DEBUG_REPORT_EXTENSION_NAME
			}
		}
	}

	// step 6
	for(uint32_t i = 0; i<instanceExtensionCount; i++)
	{
		free(instanceExtensionNames_array[i]);
	}
	
	free(instanceExtensionNames_array);
	instanceExtensionNames_array = NULL;


	// step 7
	if(vulkanSurfaceExtensionFound == VK_FALSE)
	{
		vkResult = VK_ERROR_INITIALIZATION_FAILED; // resturn hardcoded failure
		fprintf(gpFILE, "fillInstanceExtensionNames() -> VK_KHR_SURFACE_EXTENSION_NAME not found\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "fillInstanceExtensionNames() -> VK_KHR_SURFACE_EXTENSION_NAME found\n");
	}

	if(win32SurfaceExtensionFound == VK_FALSE)
	{
		vkResult = VK_ERROR_INITIALIZATION_FAILED; // resturn hardcoded failure
		fprintf(gpFILE, "fillInstanceExtensionNames() -> VK_KHR_WIN32_SURFACE_EXTENSION_NAME not found\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "fillInstanceExtensionNames() -> VK_KHR_WIN32_SURFACE_EXTENSION_NAME found\n");
	}

	if(debugReportExtensionFound == VK_FALSE)
	{
		if(bValidation == TRUE){
			vkResult = VK_ERROR_INITIALIZATION_FAILED; // resturn hardcoded failure
			fprintf(gpFILE, "fillInstanceExtensionNames() -> Validation is on but required VK_EXT_DEBUG_REPORT_EXTENSION_NAME not supported\n");
			return vkResult;
		}
		else{
			fprintf(gpFILE, "fillInstanceExtensionNames() -> validation is off but required VK_EXT_DEBUG_REPORT_EXTENSION_NAME not supported\n");
		}
	}
	else{
		if(bValidation == TRUE){
	
			fprintf(gpFILE, "fillInstanceExtensionNames() -> Validation is on and VK_EXT_DEBUG_REPORT_EXTENSION_NAME supported\n");
			
		}
		else{
			fprintf(gpFILE, "fillInstanceExtensionNames() -> validation is off but required VK_EXT_DEBUG_REPORT_EXTENSION_NAME is supported\n");
		}
	}

	// step 8 print only supported extension
	for(uint32_t i = 0; i<enableInstanceExtensionCount; i++)
	{
		fprintf(gpFILE, "fillInstanceExtensionNames() -> enabled vulkan Instance Extension name = %s\n", enabledInstanceExtensionNames_array[i]);
	}

	return vkResult;

}

VkResult fillValidationLayerNames(void){
	// Code
	// Local variable declaration
	VkResult vkResult = VK_SUCCESS;
	uint32_t validationLayerCount = 0;

	vkResult = vkEnumerateInstanceLayerProperties
	(
		&validationLayerCount, 
		NULL
	);

	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "fillValidationLayerNames() -> Fisrt Call to vkEnumerateInstanceLayerProperties() is failed\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "fillValidationLayerNames() -> Fisrt Call to vkEnumerateInstanceLayerProperties() Succeeded\n");
	}

	VkLayerProperties* vkLayerProperties_array = NULL;
	vkLayerProperties_array = (VkLayerProperties*)malloc(sizeof(VkLayerProperties)*validationLayerCount); // Real production code required error checking for malloc
	
	vkResult = vkEnumerateInstanceLayerProperties
	(
		&validationLayerCount, 
		vkLayerProperties_array
	);

	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "fillValidationLayerNames() -> Secound Call to vkEnumerateInstanceLayerProperties() is failed\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "fillValidationLayerNames() -> Secound Call to vkEnumerateInstanceLayerProperties() Succeeded\n");
	}

	char** validationLayerNames_array = NULL;
	//validationLayerNames_array = (char**)malloc(sizeof(char*)*validationLayerCount);
	validationLayerNames_array = (char **)malloc(validationLayerCount * sizeof(char *));

	for(uint32_t i = 0; i<validationLayerCount; i++)
	{
		validationLayerNames_array[i] = (char*)malloc(sizeof(char)*(strlen(vkLayerProperties_array[i].layerName) + 1));
		memcpy(validationLayerNames_array[i], vkLayerProperties_array[i].layerName, strlen(vkLayerProperties_array[i].layerName) + 1);
		fprintf(gpFILE, "fillValidationLayerNames() -> vulkan layer name = %s\n", validationLayerNames_array[i]);
	}

	free(vkLayerProperties_array);
	vkLayerProperties_array = NULL;

	VkBool32 validationLayerFound = VK_FALSE;

	for(uint32_t i = 0; i<validationLayerCount; i++)
	{
		if(strcmp(validationLayerNames_array[i], "VK_LAYER_KHRONOS_validation") == 0){
			validationLayerFound = VK_TRUE;
			enabledValidationLayerNames_array[enabledValidationLayerCount++] = "VK_LAYER_KHRONOS_validation";
		}
	}

	for(uint32_t i = 0; i<validationLayerCount; i++)
	{
		free(validationLayerNames_array[i]);
		validationLayerNames_array[i] = NULL;
	}

	free(validationLayerNames_array);
	validationLayerNames_array = NULL;

	if(validationLayerFound == VK_FALSE){
		if(bValidation == TRUE){
			vkResult = VK_ERROR_INITIALIZATION_FAILED;
			fprintf(gpFILE, "[VALIDATION ON]fillValidationLayerNames()->VK_LAYER_KHRONOS_validation not found due to %d\n", vkResult);
			return vkResult;
		}
		else{
			fprintf(gpFILE, "[VALIDATION OFF]fillValidationLayerNames()->VK_LAYER_KHRONOS_validation not found due to %d\n", vkResult);
		}	
	}
	else{
		if(bValidation == TRUE){
			fprintf(gpFILE, "[VALIDATION ON]fillValidationLayerNames()->VK_LAYER_KHRONOS_validation found successfully\n");
			return vkResult;
		}
		else{
			fprintf(gpFILE, "[VALIDATION OFF]fillValidationLayerNames()->VK_LAYER_KHRONOS_validation found successfully\n");
		}
	}

	for(uint32_t i = 0; i<enabledValidationLayerCount; i++)
	{
		fprintf(gpFILE, "fillValidationLayerNames() -> enabled vulkan validation layer name = %s\n", enabledValidationLayerNames_array[i]);
	}

	return vkResult;
}

VkResult createValidationCallbackFunction(void){
	// function declarations
	VKAPI_ATTR VkBool32 VKAPI_CALL debugReportCallback(VkDebugReportFlagsEXT, VkDebugReportObjectTypeEXT, uint64_t, size_t, int32_t, const char*, const char*, void*);

	// Local variable declaration
	VkResult vkResult = VK_SUCCESS;
	PFN_vkCreateDebugReportCallbackEXT vkCreateDebugReportCallbackEXT_fnptr = NULL;

	// Code
	// Get the required function pointer
	vkCreateDebugReportCallbackEXT_fnptr = (PFN_vkCreateDebugReportCallbackEXT)vkGetInstanceProcAddr
	(
		vkInstance,
		"vkCreateDebugReportCallbackEXT"
	); //%%
	if(vkCreateDebugReportCallbackEXT_fnptr == NULL){
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		fprintf(gpFILE, "createValidationCallbackFunction -> vkGetInstanceProcAddr() failed to get function pointer for PFN_vkCreateDebugReportCallbackEXT\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createValidationCallbackFunction -> vkGetInstanceProcAddr() succeeded to get function pointer for PFN_vkCreateDebugReportCallbackEXT\n");
	}

	vkDestroyDebugReportCallbackEXT_fnptr = (PFN_vkDestroyDebugReportCallbackEXT)vkGetInstanceProcAddr
	(
		vkInstance, 
		"vkDestroyDebugReportCallbackEXT"
	); //%%
	if(vkDestroyDebugReportCallbackEXT_fnptr == NULL){
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		fprintf(gpFILE, "createValidationCallbackFunction -> vkGetInstanceProcAddr() failed to get function pointer for PFN_vkDestroyDebugReportCallbackEXT\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createValidationCallbackFunction -> vkGetInstanceProcAddr() succeeded to get function pointer for PFN_vkDestroyDebugReportCallbackEXT\n");
	}

	// Get the vulkan debug report callback object
	VkDebugReportCallbackCreateInfoEXT vkDebugReportCallbackCreateInfoEXT;
	memset((void*)&vkDebugReportCallbackCreateInfoEXT, 0, sizeof(VkDebugReportCallbackCreateInfoEXT));

	vkDebugReportCallbackCreateInfoEXT.sType 		= VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
	vkDebugReportCallbackCreateInfoEXT.pNext 		= NULL;
	vkDebugReportCallbackCreateInfoEXT.flags 		= VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT;
	vkDebugReportCallbackCreateInfoEXT.pfnCallback 	= debugReportCallback;
	vkDebugReportCallbackCreateInfoEXT.pUserData 	= NULL;

	vkResult = vkCreateDebugReportCallbackEXT_fnptr(vkInstance, &vkDebugReportCallbackCreateInfoEXT, NULL, &vkDebugReportCallbackEXT);
	if (vkResult != VK_SUCCESS) 
	{
		fprintf(gpFILE, "createValidationCallbackFunction -> vkCreateDebugReportCallbackEXT failed %d\n", vkResult);
		return vkResult;
	}
	fprintf(gpFILE, "createValidationCallbackFunction -> vkCreateDebugReportCallbackEXT succeeded\n");

	return vkResult;
}

VkResult getSupportedSurface(void)
{
	// Local variable declaration
	VkResult vkResult = VK_SUCCESS;

	VkWin32SurfaceCreateInfoKHR vkWin32SurfaceCreateInfoKHR;

	memset((void*)&vkWin32SurfaceCreateInfoKHR, 0, sizeof(VkWin32SurfaceCreateInfoKHR));

	vkWin32SurfaceCreateInfoKHR.sType 		= VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
	vkWin32SurfaceCreateInfoKHR.pNext 		= NULL;
	vkWin32SurfaceCreateInfoKHR.flags 		= 0;
	vkWin32SurfaceCreateInfoKHR.hinstance 	= (HINSTANCE)GetWindowLongPtr(ghwnd, GWLP_HINSTANCE); // we can also use getModuleHandle() ti get hinstance
	vkWin32SurfaceCreateInfoKHR.hwnd 		= ghwnd;

	vkResult = vkCreateWin32SurfaceKHR(vkInstance, &vkWin32SurfaceCreateInfoKHR, NULL, &vkSurfaceKHR);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "getSupportedSurface -> vkCreateWin32SurfaceKHR function is failed\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "getSupportedSurface -> vkCreateWin32SurfaceKHR Succeeded\n");
	}

	return vkResult;
}

VkResult getPhysicalDevice(void)
{
	// variable declaration
	VkResult vkResult = VK_SUCCESS;

	vkResult = vkEnumeratePhysicalDevices(vkInstance, &physicalDeviceCount, NULL);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "getPhysicalDevice() -> First call to vkEnumeratePhysicalDevices() is failed %d\n", vkResult);
		return vkResult;
	}
	else if(physicalDeviceCount == 0)
	{
		fprintf(gpFILE, "getPhysicalDevice() -> vkEnumeratePhysicalDevices() resulted 0\n");
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}
	else{
		fprintf(gpFILE, "getPhysicalDevice() -> First call to vkEnumeratePhysicalDevices() Succeeded\n");
	}
	
	vkPhysicalDevice_array = (VkPhysicalDevice*)malloc(sizeof(VkPhysicalDevice) * physicalDeviceCount);

	// step 4
	vkResult = vkEnumeratePhysicalDevices(vkInstance, &physicalDeviceCount, vkPhysicalDevice_array);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "getPhysicalDevice() -> Second call to vkEnumeratePhysicalDevices() is failed %d\n", vkResult);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "getPhysicalDevice() -> Second call to vkEnumeratePhysicalDevices() Succeeded\n");
	}

	// step 5
	VkBool32 bFound = VK_FALSE;

	for(uint32_t i=0; i<physicalDeviceCount; i++)
	{
		uint32_t queueCount = UINT32_MAX;

		// If physical device present then it must support at least one family

		vkGetPhysicalDeviceQueueFamilyProperties(vkPhysicalDevice_array[i], &queueCount, NULL);

		// c)
		VkQueueFamilyProperties* vkQueueFamilyProperties_array = NULL;
		vkQueueFamilyProperties_array = (VkQueueFamilyProperties*)malloc(sizeof(VkQueueFamilyProperties)*queueCount);

		// d
		vkGetPhysicalDeviceQueueFamilyProperties(vkPhysicalDevice_array[i], &queueCount, vkQueueFamilyProperties_array);

		VkBool32* isQueueSurfaceSupported_array = NULL;
		isQueueSurfaceSupported_array = (VkBool32*)malloc(sizeof(VkBool32)*queueCount);

		for(uint32_t j = 0; j<queueCount; j++)
		{
			vkGetPhysicalDeviceSurfaceSupportKHR(vkPhysicalDevice_array[i], j, vkSurfaceKHR, &isQueueSurfaceSupported_array[j]);
		}

		for(uint32_t j=0; j<queueCount; j++)
		{
			if(vkQueueFamilyProperties_array[j].queueFlags & VK_QUEUE_GRAPHICS_BIT)
			{
				if(isQueueSurfaceSupported_array[j] == VK_TRUE)
				{
					vkPhysicalDevice_selected = vkPhysicalDevice_array[i];
					graphicsQueueFamilyIndex_selected = j;

					bFound = VK_TRUE;
					break;
				}
			}
		}

		if(isQueueSurfaceSupported_array)
		{
			free(isQueueSurfaceSupported_array);
			isQueueSurfaceSupported_array = NULL;
			fprintf(gpFILE, "getPhysicalDevice() -> isQueueSurfaceSupported_array is free\n");
		}

		if(vkQueueFamilyProperties_array)
		{
			free(vkQueueFamilyProperties_array);
			vkQueueFamilyProperties_array = NULL;
			fprintf(gpFILE, "getPhysicalDevice() -> vkQueueFamilyProperties_array is free\n");
		}

		if(bFound == VK_TRUE)
			break;
	}

	if(bFound == VK_TRUE)
	{
		fprintf(gpFILE, "getPhysicalDevice() is succeeded to select required physical device with graphics enabled\n");

		
	}
	else{
		fprintf(gpFILE, "getPhysicalDevice() Failed to obtained graphic supported device\n");

		if(vkPhysicalDevice_array)
		{
			free(vkPhysicalDevice_array);
			vkPhysicalDevice_array = NULL;
			fprintf(gpFILE, "getPhysicalDevice() -> vkPhysicalDevice_array is free successfully\n");
		}

		vkResult = VK_ERROR_INITIALIZATION_FAILED;

		return vkResult;
	}

	// step 7
	memset((void*)&vkPhysicalDeviceMemoryProperties, 0, sizeof(VkPhysicalDeviceMemoryProperties));

	// step 8
	vkGetPhysicalDeviceMemoryProperties(vkPhysicalDevice_selected, &vkPhysicalDeviceMemoryProperties);

	// step 9
	VkPhysicalDeviceFeatures vkPhysicalDeviceFeatures;
	memset((void*)&vkPhysicalDeviceFeatures, 0, sizeof(VkPhysicalDeviceFeatures));

	// step 10
	vkGetPhysicalDeviceFeatures(vkPhysicalDevice_selected, &vkPhysicalDeviceFeatures);

	if(vkPhysicalDeviceFeatures.tessellationShader)
	{
		fprintf(gpFILE, "getPhysicalDevice() -> selected physical device support tessellation Shader\n");
	}
	else{
		fprintf(gpFILE, "getPhysicalDevice() -> selected physical device not support tessellation Shader\n");
	}

	if(vkPhysicalDeviceFeatures.geometryShader)
	{
		fprintf(gpFILE, "getPhysicalDevice() -> selected physical device support geometry Shader\n");
	}
	else{
		fprintf(gpFILE, "getPhysicalDevice() -> selected physical device not support geometry Shader\n");
	}
										

	return vkResult;
}

VkResult printVKInfo(void)
{
	// variable declaration
	VkResult vkResult = VK_SUCCESS;

	// Code
	fprintf(gpFILE, "\n******************************** PRINT VULKAN INFORMATION *****************************************\n");

	for(uint32_t i=0; i<physicalDeviceCount; i++)
	{
		VkPhysicalDeviceProperties vkPhysicalDeviceProperties;
		memset((void*)&vkPhysicalDeviceProperties, 0, sizeof(VkPhysicalDeviceProperties));

		vkGetPhysicalDeviceProperties(vkPhysicalDevice_array[i], &vkPhysicalDeviceProperties);

		uint32_t majorVersion = VK_API_VERSION_MAJOR(vkPhysicalDeviceProperties.apiVersion);
		uint32_t minorVersion = VK_API_VERSION_MINOR(vkPhysicalDeviceProperties.apiVersion);
		uint32_t patchVersion = VK_API_VERSION_PATCH(vkPhysicalDeviceProperties.apiVersion);

		// API Version
		fprintf(gpFILE, "API Version 		-> %d.%d.%d\n", majorVersion, minorVersion, patchVersion);

		// Device Name
		fprintf(gpFILE, "Device Name 		-> %s\n", vkPhysicalDeviceProperties.deviceName);

		// Device Type
		switch(vkPhysicalDeviceProperties.deviceType)
		{
			case VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU:
				fprintf(gpFILE,	"Device Type		-> integrated GPU(iGPU)\n");
				break;
			case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:
				fprintf(gpFILE,	"Device Type		-> Discrete GPU(dGPU)\n");
				break;
			case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:
				fprintf(gpFILE,	"Device Type		-> Virtual GPU(vGPU)\n");
				break;
			case VK_PHYSICAL_DEVICE_TYPE_CPU:
				fprintf(gpFILE,	"Device Type		-> CPU\n");
				break;
			case VK_PHYSICAL_DEVICE_TYPE_OTHER:
				fprintf(gpFILE,	"Device Type		-> OTHER\n");
				break;
			default:
				fprintf(gpFILE,	"Device Type		-> UNKNOWN\n");
				break;
		}

		// Vendor ID
		fprintf(gpFILE, "Vendor ID		-> 0x%04x\n", vkPhysicalDeviceProperties.vendorID);

		// Device ID
		fprintf(gpFILE, "Device ID		-> 0x%04x\n", vkPhysicalDeviceProperties.deviceID);
		
	}

	// Free global physical device selected array
	if(vkPhysicalDevice_array)
	{
		free(vkPhysicalDevice_array);
		vkPhysicalDevice_array = NULL;
		fprintf(gpFILE, "printVKInfo() -> vkPhysicalDevice_array is free successfully\n");
	}

	fprintf(gpFILE, "\n******************************** END VULKAN INFORMATION *****************************************\n");

	return vkResult;
}

VkResult fillDeviceExtensionNames(void)
{
	// variable declaration
	VkResult vkResult = VK_SUCCESS;

	// step 1
	uint32_t deviceExtensionCount = 0;

	vkResult = vkEnumerateDeviceExtensionProperties(vkPhysicalDevice_selected, NULL, &deviceExtensionCount, NULL);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "fillDeviceExtensionNames() -> Fisrt Call to vkEnumerateDeviceExtensionProperties() is failed\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "fillDeviceExtensionNames() -> Fisrt Call to vkEnumerateDeviceExtensionProperties() Succeeded\n");
	}

	// step 2
	VkExtensionProperties* vkDeviceExtensionProperties_array = NULL;

	vkDeviceExtensionProperties_array = (VkExtensionProperties*)malloc(sizeof(VkExtensionProperties)*deviceExtensionCount); // Real production code required error checking for malloc
	
	vkResult = vkEnumerateDeviceExtensionProperties(vkPhysicalDevice_selected, NULL, &deviceExtensionCount, vkDeviceExtensionProperties_array);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "fillDeviceExtensionNames() -> Secound Call to vkEnumerateDeviceExtensionProperties() is failed\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "fillDeviceExtensionNames() -> Secound Call to vkEnumerateDeviceExtensionProperties() Succeeded\n");
	}

	// step 3
	char** deviceExtensionNames_array = NULL;

	deviceExtensionNames_array = (char**)malloc(sizeof(char*)*deviceExtensionCount);

	for(uint32_t i = 0; i<deviceExtensionCount; i++)
	{
		deviceExtensionNames_array[i] = (char*)malloc(sizeof(char)*strlen(vkDeviceExtensionProperties_array[i].extensionName) + 1);
		memcpy(deviceExtensionNames_array[i], vkDeviceExtensionProperties_array[i].extensionName, strlen(vkDeviceExtensionProperties_array[i].extensionName) + 1);

		fprintf(gpFILE, "fillDeviceExtensionNames() -> vulkan extension name = %s\n", deviceExtensionNames_array[i]);
	}

	// Step 4
	free(vkDeviceExtensionProperties_array);
	vkDeviceExtensionProperties_array = NULL;

	// Step 5
	VkBool32 vulkanSwapchainExtensionFound = FALSE;

	for(uint32_t i = 0; i<deviceExtensionCount; i++)
	{
		if(strcmp(deviceExtensionNames_array[i], VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0)
		{
			vulkanSwapchainExtensionFound = VK_TRUE;

			enabledDeviceExtensionNames_array[enabledDeviceExtensionCount++] = VK_KHR_SWAPCHAIN_EXTENSION_NAME;
		}

		
	}

	// step 6
	for(uint32_t i = 0; i<deviceExtensionCount; i++)
	{
		free(deviceExtensionNames_array[i]);
	}
	
	free(deviceExtensionNames_array);
	deviceExtensionNames_array = NULL;


	// step 7
	if(vulkanSwapchainExtensionFound == VK_FALSE)
	{
		vkResult = VK_ERROR_INITIALIZATION_FAILED; // resturn hardcoded failure
		fprintf(gpFILE, "fillDeviceExtensionNames() -> VK_KHR_SWAPCHAIN_EXTENSION_NAME not found\n");
		return vkResult;
	}
	else{
		fprintf(gpFILE, "fillDeviceExtensionNames() -> VK_KHR_SWAPCHAIN_EXTENSION_NAME found\n");
	}


	// step 8
	for(uint32_t i = 0; i<enabledDeviceExtensionCount; i++)
	{
		fprintf(gpFILE, "fillDeviceExtensionNames() -> enabled vulkan Device Extension name = %s\n", enabledDeviceExtensionNames_array[i]);
	}

	return vkResult;

}

VkResult createVulkanDevice(void){
	// Function declaration
	VkResult fillDeviceExtensionNames(void);

	// Variable declaration
	VkResult vkResult = VK_SUCCESS;

	// Code !!
	// Fill device extensions
	vkResult = fillDeviceExtensionNames();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVulkanDevice() -> fillDeviceExtensionNames() is failed %d\n", vkResult);
	}
	else{
		fprintf(gpFILE, "createVulkanDevice() -> fillDeviceExtensionNames() Succeeded\n");
	}

	float queueProirities[] = {1.0};

	// Newly added code
	VkDeviceQueueCreateInfo vkDeviceQueueCreateInfo;
	memset((void*)&vkDeviceQueueCreateInfo, 0, sizeof(VkDeviceQueueCreateInfo));

	vkDeviceQueueCreateInfo.sType 				= VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
	vkDeviceQueueCreateInfo.pNext 				= NULL;
	vkDeviceQueueCreateInfo.flags 				= 0;
	vkDeviceQueueCreateInfo.queueFamilyIndex 	= graphicsQueueFamilyIndex_selected;
	vkDeviceQueueCreateInfo.queueCount 			= 1;
	vkDeviceQueueCreateInfo.pQueuePriorities 	= queueProirities;
	


	// Initialize VkDeviceCreateInfo structure
	VkDeviceCreateInfo vkDeviceCreateInfo;
	memset((void*)&vkDeviceCreateInfo, 0, sizeof(VkDeviceCreateInfo));

	// Vulkan cha object asla ki VK_HANDLE_NULL;
	// Pointer or array asla ki NULL
	vkDeviceCreateInfo.sType 					= VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
	vkDeviceCreateInfo.pNext 					= NULL;
	vkDeviceCreateInfo.flags 					= 0;
	vkDeviceCreateInfo.enabledExtensionCount 	= enabledDeviceExtensionCount;
	vkDeviceCreateInfo.ppEnabledExtensionNames 	= enabledDeviceExtensionNames_array;
	vkDeviceCreateInfo.enabledLayerCount 		= 0; // D
	vkDeviceCreateInfo.ppEnabledLayerNames 		= NULL; // D
	vkDeviceCreateInfo.pEnabledFeatures 		= NULL; 

	vkDeviceCreateInfo.queueCreateInfoCount 	= 1;
	vkDeviceCreateInfo.pQueueCreateInfos 		= &vkDeviceQueueCreateInfo;
	

	vkResult = vkCreateDevice(vkPhysicalDevice_selected, &vkDeviceCreateInfo, NULL, &vkDevice);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVulkanDevice() -> vkCreateDevice() is failed %d\n", vkResult);
	}
	else{
		fprintf(gpFILE, "createVulkanDevice() -> vkCreateDevice() Succeeded\n");
	}
	return vkResult;
}

void getDeviceQueue(void){
	// Code
	vkGetDeviceQueue(vkDevice, graphicsQueueFamilyIndex_selected, 0, &vkQueue);
	if(vkQueue == VK_NULL_HANDLE){
		fprintf(gpFILE, "getDeviceQueue() -> vkGetDeviceQueue return NULL for vkQueue\n");
		return;
	}
	else{
		fprintf(gpFILE, "getDeviceQueue() -> vkGetDeviceQueue succeeded\n");
	}

	
}

VkResult getPhysicalDeviceSurfaceFormatAndColorSpace(void){
	// Variable declaration
	VkResult vkResult = VK_SUCCESS;

	// Get the count of supported surface color formats
	uint32_t formatCount = 0;

	vkResult = vkGetPhysicalDeviceSurfaceFormatsKHR(vkPhysicalDevice_selected, vkSurfaceKHR, &formatCount, NULL);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "getPhysicalDeviceSurfaceFormatAndColorSpace() -> first call to vkGetPhysicalDeviceSurfaceFormatsKHR() is failed %d\n", vkResult);
	}
	else if(formatCount == 0)
	{
		fprintf(gpFILE, "getPhysicalDeviceSurfaceFormatAndColorSpace -> first call to formatCount resulted 0\n");
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}
	else{
		fprintf(gpFILE, "getPhysicalDeviceSurfaceFormatAndColorSpace() -> first call to vkGetPhysicalDeviceSurfaceFormatsKHR() Succeeded\n");
	}

	// Declare and allocate VkSurfaceFormatKHR array 
	VkSurfaceFormatKHR* vkSurfaceFormatKHR_array = (VkSurfaceFormatKHR*)malloc(formatCount * sizeof(VkSurfaceFormatKHR));

	// Filling the array
	vkResult = vkGetPhysicalDeviceSurfaceFormatsKHR(vkPhysicalDevice_selected, vkSurfaceKHR, &formatCount, vkSurfaceFormatKHR_array);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "getPhysicalDeviceSurfaceFormatAndColorSpace() -> second call to vkGetPhysicalDeviceSurfaceFormatsKHR() is failed %d\n", vkResult);
	}
	else{
		fprintf(gpFILE, "getPhysicalDeviceSurfaceFormatAndColorSpace() -> second call to vkGetPhysicalDeviceSurfaceFormatsKHR() Succeeded\n");
	}

	// deside the surface color format first
	if(formatCount == 1 && vkSurfaceFormatKHR_array[0].format == VK_FORMAT_UNDEFINED){
		vkFormat_color = VK_FORMAT_B8G8R8A8_UNORM;
	}else{
		vkFormat_color = vkSurfaceFormatKHR_array[0].format;
	}

	// Deside the color space
	vkColorSpaceKHR =  vkSurfaceFormatKHR_array[0].colorSpace;

	if( vkSurfaceFormatKHR_array){
		free( vkSurfaceFormatKHR_array);
		vkSurfaceFormatKHR_array = NULL;
		fprintf(gpFILE, "getPhysicalDeviceSurfaceFormatAndColorSpace() -> vkSurfaceFormatKHR_array is free\n");
	}

	return vkResult;
}

VkResult getPhysicalDevicePresentMode(void){
	// Variable declaration
	VkResult vkResult = VK_SUCCESS;

	// Code
	uint32_t presentModeCount = 0;

	vkResult = vkGetPhysicalDeviceSurfacePresentModesKHR(vkPhysicalDevice_selected, vkSurfaceKHR, &presentModeCount, NULL);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "getPhysicalDevicePresentMode() -> first call to vkGetPhysicalDeviceSurfacePresentModesKHR() is failed %d\n", vkResult);
	}
	else if(presentModeCount == 0)
	{
		fprintf(gpFILE, "getPhysicalDevicePresentMode() -> first call to presentModeCount resulted 0\n");
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}
	else{
		fprintf(gpFILE, "getPhysicalDevicePresentMode() -> first call to vkGetPhysicalDeviceSurfacePresentModesKHR() Succeeded\n");
	}

	VkPresentModeKHR* vkPresentModeKHR_array = (VkPresentModeKHR*)malloc(presentModeCount * sizeof(VkPresentModeKHR));

	vkResult = vkGetPhysicalDeviceSurfacePresentModesKHR(vkPhysicalDevice_selected, vkSurfaceKHR, &presentModeCount, vkPresentModeKHR_array);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "getPhysicalDevicePresentMode() -> second call to vkGetPhysicalDeviceSurfacePresentModesKHR() is failed %d\n", vkResult);
	}
	else{
		fprintf(gpFILE, "getPhysicalDevicePresentMode() -> second call to vkGetPhysicalDeviceSurfacePresentModesKHR() Succeeded\n");
	}

	// Deside presentation mode
	for(uint32_t i = 0; i < presentModeCount; i++){
		if(vkPresentModeKHR_array[i] == VK_PRESENT_MODE_MAILBOX_KHR){
			vkPresentModeKHR = VK_PRESENT_MODE_MAILBOX_KHR;
			fprintf(gpFILE, "*****mailBox********\n");
			break;
		}
	}

	if(vkPresentModeKHR != VK_PRESENT_MODE_MAILBOX_KHR){
		vkPresentModeKHR = VK_PRESENT_MODE_FIFO_KHR;
		fprintf(gpFILE, "*****FIFO********\n");
	}

	if(vkPresentModeKHR_array){
		free(vkPresentModeKHR_array);
		vkPresentModeKHR_array = NULL;
		fprintf(gpFILE, "getPhysicalDevicePresentMode() -> vkPresentModeKHR_array is free\n");
	}

	return vkResult;
}

//
VkResult createSwapchain(VkBool32 vsync){
	// function declarations
	VkResult getPhysicalDeviceSurfaceFormatAndColorSpace(void);
	VkResult getPhysicalDevicePresentMode(void);

	// Variable declaration
	VkResult vkResult = VK_SUCCESS;

	// Code
	// Color format and color space
	vkResult = getPhysicalDeviceSurfaceFormatAndColorSpace();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createSwapchain() -> getPhysicalDeviceSurfaceFormatAndColorSpace() is failed %d\n", vkResult);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createSwapchain() -> getPhysicalDeviceSurfaceFormatAndColorSpace() Succeeded\n");
	}

	// Get physical device surface capabilities
	VkSurfaceCapabilitiesKHR vkSurfaceCapabilitiesKHR;
	memset((void*)&vkSurfaceCapabilitiesKHR, 0, sizeof(VkSurfaceCapabilitiesKHR));

	vkResult = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(vkPhysicalDevice_selected, vkSurfaceKHR, &vkSurfaceCapabilitiesKHR);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createSwapchain() -> vkGetPhysicalDeviceSurfaceCapabilitiesKHR() is failed %d\n", vkResult);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createSwapchain() -> vkGetPhysicalDeviceSurfaceCapabilitiesKHR() Succeeded\n");
	}

	// step 3 -> find out desired swapchain images count
	uint32_t testingNumberOfSwapchainImages = vkSurfaceCapabilitiesKHR.minImageCount + 1;
	uint32_t desiredNumberOfSwapchainImages = 0;

	if(vkSurfaceCapabilitiesKHR.maxImageCount > 0 && vkSurfaceCapabilitiesKHR.maxImageCount < testingNumberOfSwapchainImages){
		desiredNumberOfSwapchainImages = vkSurfaceCapabilitiesKHR.maxImageCount;
	}
	else{
		desiredNumberOfSwapchainImages = vkSurfaceCapabilitiesKHR.minImageCount;
	}

	// step 4 -> choose size of swapchain image
	memset((void*)&vkExtent2D_swapchain, 0, sizeof(VkExtent2D));

	if(vkSurfaceCapabilitiesKHR.currentExtent.width != UINT32_MAX){
		vkExtent2D_swapchain.width = vkSurfaceCapabilitiesKHR.currentExtent.width;
		vkExtent2D_swapchain.height = vkSurfaceCapabilitiesKHR.currentExtent.height;
		fprintf(gpFILE, "createSwapchain() -> Inside if SwapchainImage width X height = %d x %d\n", vkExtent2D_swapchain.width, vkExtent2D_swapchain.height);
	}
	else{
		// If surface size already defined then swapchain image size must match with it.
		VkExtent2D vkExtent2D;
		memset((void*)&vkExtent2D, 0, sizeof(VkExtent2D));

		vkExtent2D.width = (uint32_t)winWidth;
		vkExtent2D.height = (uint32_t)winHeight;

		vkExtent2D_swapchain.width = glm::max(vkSurfaceCapabilitiesKHR.minImageExtent.width, glm::min(vkSurfaceCapabilitiesKHR.maxImageExtent.width, vkExtent2D.width));
		vkExtent2D_swapchain.height = glm::max(vkSurfaceCapabilitiesKHR.minImageExtent.height, glm::min(vkSurfaceCapabilitiesKHR.maxImageExtent.height, vkExtent2D.height));

		fprintf(gpFILE, "createSwapchain() -> Inside else SwapchainImage width X height = %d x %d\n", vkExtent2D_swapchain.width, vkExtent2D_swapchain.height);
	}

	// step 5-> Set swapchain image usage flag
	VkImageUsageFlags vkImageUsageFlags = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;

	// step 6-> whether to consider pre-transform or not.
	VkSurfaceTransformFlagBitsKHR vkSurfaceTransformFlagBitsKHR; // enum

	if(vkSurfaceCapabilitiesKHR.supportedTransforms & VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR){
		vkSurfaceTransformFlagBitsKHR = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
	}
	else{
		vkSurfaceTransformFlagBitsKHR = vkSurfaceCapabilitiesKHR.currentTransform;
	}

	// step 7 ->
	// Present mode
	vkResult = getPhysicalDevicePresentMode();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createSwapchain() -> getPhysicalDevicePresentMode() is failed %d\n", vkResult);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createSwapchain() -> getPhysicalDevicePresentMode() Succeeded\n");
	}

	// step 8 -> initialize VkSwapchainCreateInfoKHR structure
	VkSwapchainCreateInfoKHR vkSwapchainCreateInfoKHR;
	memset((void*)&vkSwapchainCreateInfoKHR, 0, sizeof(VkSwapchainCreateInfoKHR));

	vkSwapchainCreateInfoKHR.sType 					= VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
	vkSwapchainCreateInfoKHR.pNext 					= NULL;
	vkSwapchainCreateInfoKHR.flags 					= 0;
	vkSwapchainCreateInfoKHR.surface 				= vkSurfaceKHR;
	vkSwapchainCreateInfoKHR.minImageCount 			= desiredNumberOfSwapchainImages;
	vkSwapchainCreateInfoKHR.imageFormat 			= vkFormat_color;
	vkSwapchainCreateInfoKHR.imageColorSpace 		= vkColorSpaceKHR;
	vkSwapchainCreateInfoKHR.imageExtent.width 		= vkExtent2D_swapchain.width;
	vkSwapchainCreateInfoKHR.imageExtent.height 	= vkExtent2D_swapchain.height;
	vkSwapchainCreateInfoKHR.imageUsage				= vkImageUsageFlags;
	vkSwapchainCreateInfoKHR.preTransform 			= vkSurfaceTransformFlagBitsKHR;
	vkSwapchainCreateInfoKHR.imageArrayLayers 		= 1;
	vkSwapchainCreateInfoKHR.imageSharingMode 		= VK_SHARING_MODE_EXCLUSIVE;
	vkSwapchainCreateInfoKHR.compositeAlpha 		= VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
	vkSwapchainCreateInfoKHR.presentMode 			= vkPresentModeKHR;
	vkSwapchainCreateInfoKHR.clipped 				= VK_TRUE;

	vkResult = vkCreateSwapchainKHR(vkDevice, &vkSwapchainCreateInfoKHR, NULL, &vkSwapchainKHR);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createSwapchain() -> vkCreateSwapchainKHR() is failed %d\n", vkResult);
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createSwapchain() -> vkCreateSwapchainKHR() Succeeded\n");
	}

	return vkResult;

}

VkResult createImagesAndImageViews(void){

	// Function declaration
	VkResult getSupportedDepthFormat(void);
	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	// Get swapchain image count
	vkResult = vkGetSwapchainImagesKHR(vkDevice, vkSwapchainKHR, &swapchainImageCount, NULL);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createImagesAndImageViews() -> first call to vkGetSwapchainImagesKHR() is failed %d\n", vkResult);
		return vkResult;
	}
	else if(swapchainImageCount == 0)
	{
		fprintf(gpFILE, "createImagesAndImageViews -> first call to swapchainImageCount resulted 0\n");
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createImagesAndImageViews() -> first call to vkGetSwapchainImagesKHR() Succeeded\n");
	}

	// Allocate the swapchain image array
	swapchainImage_array = (VkImage*)malloc(sizeof(VkImage) * swapchainImageCount);

	// step 3 -> fill this array by swapchain images
	vkResult = vkGetSwapchainImagesKHR(vkDevice, vkSwapchainKHR, &swapchainImageCount, swapchainImage_array);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createImagesAndImageViews() -> Second call to vkGetSwapchainImagesKHR() is failed %d\n", vkResult);
	}
	else{
		fprintf(gpFILE, "createImagesAndImageViews() -> Second call to vkGetSwapchainImagesKHR() Succeeded\n");
	}
	
	// allocate array of swapchain image view
	swapchainImageView_array = (VkImageView*)malloc(sizeof(VkImageView) * swapchainImageCount);

	// step 5 ->  initialize VkImageViewCreateInfo structure
	VkImageViewCreateInfo vkImageViewCreateInfo;
	memset((void*)&vkImageViewCreateInfo, 0, sizeof(VkImageViewCreateInfo));

	vkImageViewCreateInfo.sType 							= VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
	vkImageViewCreateInfo.pNext 							= NULL;
	vkImageViewCreateInfo.flags 							= 0;
	vkImageViewCreateInfo.format 							= vkFormat_color;
	vkImageViewCreateInfo.components.r 						= VK_COMPONENT_SWIZZLE_R;
	vkImageViewCreateInfo.components.g 						= VK_COMPONENT_SWIZZLE_G;
	vkImageViewCreateInfo.components.b 						= VK_COMPONENT_SWIZZLE_B;
	vkImageViewCreateInfo.components.a 						= VK_COMPONENT_SWIZZLE_A;
	vkImageViewCreateInfo.subresourceRange.aspectMask 		= VK_IMAGE_ASPECT_COLOR_BIT;
	vkImageViewCreateInfo.subresourceRange.baseMipLevel 	= 0;
	vkImageViewCreateInfo.subresourceRange.levelCount 		= 1;
	vkImageViewCreateInfo.subresourceRange.baseArrayLayer 	= 0;
	vkImageViewCreateInfo.subresourceRange.layerCount 		= 1;
	vkImageViewCreateInfo.viewType 							= VK_IMAGE_VIEW_TYPE_2D;

	// step 6-> now fill image view array by using above struct
	for(uint32_t i = 0; i<swapchainImageCount; i++){
		vkImageViewCreateInfo.image = swapchainImage_array[i];
		vkResult = vkCreateImageView(vkDevice, &vkImageViewCreateInfo, NULL, &swapchainImageView_array[i]);
		if (vkResult != VK_SUCCESS)
		{
			fprintf(gpFILE, "createImagesAndImageViews() failed for iteration %d -> vkCreateImageViews() is failed %d\n", i, vkResult);
			
		}
		else{
			fprintf(gpFILE, "createImagesAndImageViews() Succeeded for iteration %d -> vkCreateImageViews() Succeeded\n", i);
		}
	}

	// For Depth Image
	vkResult = getSupportedDepthFormat();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createImagesAndImageViews() failed for -> getSupportedDepthFormat() is failed %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createImagesAndImageViews() Succeeded for  getSupportedDepthFormat() Succeeded\n");
	}

	// For depth imagte initialize VkImageCreateInfo
	VkImageCreateInfo vkImageCreateInfo;
	memset((void*)&vkImageCreateInfo, 0, sizeof(VkImageCreateInfo));

	vkImageCreateInfo.sType 		= VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
	vkImageCreateInfo.pNext 		= NULL;
	vkImageCreateInfo.flags 		= 0;
	vkImageCreateInfo.imageType 	= VK_IMAGE_TYPE_2D;
	vkImageCreateInfo.format 		= vkFormat_depth;
	vkImageCreateInfo.extent.width 	= winWidth;
	vkImageCreateInfo.extent.height = winHeight;
	vkImageCreateInfo.extent.depth 	= 1;
	vkImageCreateInfo.mipLevels 	= 1;
	vkImageCreateInfo.arrayLayers 	= 1;
	vkImageCreateInfo.samples 		= VK_SAMPLE_COUNT_1_BIT;
	vkImageCreateInfo.tiling 		= VK_IMAGE_TILING_OPTIMAL;
	vkImageCreateInfo.usage 		= VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;

	vkResult = vkCreateImage(vkDevice, &vkImageCreateInfo, NULL, &vkImage_depth);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createImagesAndImageViews() -> vkCreateImage() is failed %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createImagesAndImageViews() ->  vkCreateImage() Succeeded\n");
	}


	// Memory requirements for depth image
	VkMemoryRequirements vkMemoryRequirements;
	memset((void*) &vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));

	vkGetImageMemoryRequirements(vkDevice, vkImage_depth, &vkMemoryRequirements);

	//
	VkMemoryAllocateInfo vkMemoryAllocateInfo;
	memset((void*)&vkMemoryAllocateInfo, 0, sizeof(VkMemoryAllocateInfo));

	vkMemoryAllocateInfo.sType 				= VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	vkMemoryAllocateInfo.pNext 				= NULL;
	vkMemoryAllocateInfo.allocationSize 	= vkMemoryRequirements.size;
	vkMemoryAllocateInfo.memoryTypeIndex 	= 0; // initialize value before entering into loop

	for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++){
		if((vkMemoryRequirements.memoryTypeBits & 1) == 1){
			if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT){
				vkMemoryAllocateInfo.memoryTypeIndex = i;
				break;
			}
		}
		vkMemoryRequirements.memoryTypeBits >>= 1;
	}

	vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vkDeviceMemory_depth);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createImagesAndImageViews() -> vkAllocateMemory() is failed %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createImagesAndImageViews() -> vkAllocateMemory() Succeeded\n");
	}

	vkResult = vkBindImageMemory(vkDevice, 
								vkImage_depth, 		// konala bind karaych
								vkDeviceMemory_depth, // kon bind karaych
								0
							);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createImagesAndImageViews() -> vkBindBufferMemory() is failed %d\n", vkResult);									
	}
	else{
		fprintf(gpFILE, "createImagesAndImageViews() -> vkBindBufferMemory() Succeeded\n");
	}

	// Create image for above depth images
	memset((void*)&vkImageViewCreateInfo, 0, sizeof(VkImageViewCreateInfo));

	vkImageViewCreateInfo.sType 							= VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
	vkImageViewCreateInfo.pNext 							= NULL;
	vkImageViewCreateInfo.flags 							= 0;
	vkImageViewCreateInfo.format 							= vkFormat_depth;
	// Pick stencil bit only if the chosen depth format actually has stencil
	VkImageAspectFlags aspect = VK_IMAGE_ASPECT_DEPTH_BIT;
	if (vkFormat_depth == VK_FORMAT_D32_SFLOAT_S8_UINT || vkFormat_depth == VK_FORMAT_D24_UNORM_S8_UINT || vkFormat_depth == VK_FORMAT_D16_UNORM_S8_UINT) 
	{
		aspect |= VK_IMAGE_ASPECT_STENCIL_BIT;
	}
	vkImageViewCreateInfo.subresourceRange.aspectMask = aspect;
	vkImageViewCreateInfo.subresourceRange.baseMipLevel 	= 0;
	vkImageViewCreateInfo.subresourceRange.levelCount 		= 1;
	vkImageViewCreateInfo.subresourceRange.baseArrayLayer 	= 0;
	vkImageViewCreateInfo.subresourceRange.layerCount 		= 1;
	vkImageViewCreateInfo.viewType 							= VK_IMAGE_VIEW_TYPE_2D;
	vkImageViewCreateInfo.image 							= vkImage_depth; // IMP

	vkResult = vkCreateImageView(vkDevice, &vkImageViewCreateInfo, NULL, &vkImageView_depth);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createImagesAndImageViews() -> vkCreateImageView() is failed %d\n", vkResult);									
	}
	else{
		fprintf(gpFILE, "createImagesAndImageViews() -> vkCreateImageView() Succeeded\n");
	}

	return vkResult;
}

VkResult createCommandPool(void){
	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	// Code
	// 
	VkCommandPoolCreateInfo vkCommandPoolCreateInfo;
	memset((void*)&vkCommandPoolCreateInfo, 0, sizeof(VkCommandPoolCreateInfo));

	vkCommandPoolCreateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
	vkCommandPoolCreateInfo.pNext = NULL;
	vkCommandPoolCreateInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
	vkCommandPoolCreateInfo.queueFamilyIndex = graphicsQueueFamilyIndex_selected;

	vkResult = vkCreateCommandPool(vkDevice, &vkCommandPoolCreateInfo, NULL, &vkCommandPool);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createCommandPool() -> vkCreateCommandPool is failed %d\n", vkResult);
		fflush(gpFILE);

		return vkResult;
			
	}
	else{
		fprintf(gpFILE, "createCommandPool() -> vkCreateCommandPool Succeeded\n");
		fflush(gpFILE);
	}

	return vkResult;
}

VkResult getSupportedDepthFormat(void){
	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	// Code
	VkFormat vkFormatDepth_array[] ={
		VK_FORMAT_D32_SFLOAT_S8_UINT,
		VK_FORMAT_D32_SFLOAT,
		VK_FORMAT_D24_UNORM_S8_UINT,
		VK_FORMAT_D16_UNORM_S8_UINT,
		VK_FORMAT_D16_UNORM
	};

	for(uint32_t i = 0; i<sizeof(vkFormatDepth_array)/sizeof(vkFormatDepth_array[0]); i++ ){
		VkFormatProperties vkFormatProperties;
		memset((void*)&vkFormatProperties, 0, sizeof(VkFormatProperties));

		vkGetPhysicalDeviceFormatProperties(vkPhysicalDevice_selected, vkFormatDepth_array[i], &vkFormatProperties);

		if(vkFormatProperties.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT)
		{
			vkFormat_depth = vkFormatDepth_array[i];
			vkResult = VK_SUCCESS;
			break;
		}
	}

	return vkResult;
}

VkResult createCommandBuffers(void){
	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	// Code
	// initialize structure
	VkCommandBufferAllocateInfo vkCommandBufferAllocateInfo;
	memset((void*)&vkCommandBufferAllocateInfo, 0, sizeof(VkCommandBufferAllocateInfo));

	vkCommandBufferAllocateInfo.sType 				= VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
	vkCommandBufferAllocateInfo.pNext 				= NULL;
	vkCommandBufferAllocateInfo.commandPool 		= vkCommandPool;
	vkCommandBufferAllocateInfo.level 				= VK_COMMAND_BUFFER_LEVEL_PRIMARY;
	vkCommandBufferAllocateInfo.commandBufferCount 	= 1;

	vkCommandBuffer_array = (VkCommandBuffer*)malloc(sizeof(VkCommandBuffer) * swapchainImageCount);

	// allocate command buffers
	for(uint32_t i = 0; i<swapchainImageCount; i++){
		vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo, &vkCommandBuffer_array[i]);
		if (vkResult != VK_SUCCESS)
		{
			fprintf(gpFILE, "createCommandBuffers() failed for iteration %d -> vkAllocateCommandBuffers() is failed %d\n", i, vkResult);
			fflush(gpFILE);
			
		}
		else{
			fprintf(gpFILE, "createCommandBuffers() Succeeded for iteration %d -> vkAllocateCommandBuffers() Succeeded\n", i);
			fflush(gpFILE);
		}
	}

	return vkResult;
}

VkResult createVertexBuffer(void)
{
	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	// Code

	// PYRAMID
	// position
	float cube_position[] =
	{
		// front
		// triangle one
	 	1.0f,  1.0f,  1.0f, // top-right of front
		-1.0f,  1.0f,  1.0f, // top-left of front
  	 	1.0f, -1.0f,  1.0f, // bottom-right of front
	
		// triangle two
	 	1.0f, -1.0f,  1.0f, // bottom-right of front
		-1.0f,  1.0f,  1.0f, // top-left of front
		-1.0f, -1.0f,  1.0f, // bottom-left of front

		// right
		// triangle one
	 	1.0f,  1.0f, -1.0f, // top-right of right
	 	1.0f,  1.0f,  1.0f, // top-left of right
	 	1.0f, -1.0f, -1.0f, // bottom-right of right
	 
		// triangle two
	 	1.0f, -1.0f, -1.0f, // bottom-right of right
	 	1.0f,  1.0f,  1.0f, // top-left of right
	 	1.0f, -1.0f,  1.0f, // bottom-left of right

		// back
		// triangle one
	 	1.0f,  1.0f, -1.0f, // top-right of back
		-1.0f,  1.0f, -1.0f, // top-left of back
	 	1.0f, -1.0f, -1.0f, // bottom-right of back
	
		// triangle two
	 	1.0f, -1.0f, -1.0f, // bottom-right of back
		-1.0f,  1.0f, -1.0f, // top-left of back
		-1.0f, -1.0f, -1.0f, // bottom-left of back

		// left
		// triangle one
		-1.0f,  1.0f,  1.0f, // top-right of left
		-1.0f,  1.0f, -1.0f, // top-left of left
		-1.0f, -1.0f,  1.0f, // bottom-right of left
	
		// triangle two
		-1.0f, -1.0f,  1.0f, // bottom-right of left
		-1.0f,  1.0f, -1.0f, // top-left of left
		-1.0f, -1.0f, -1.0f, // bottom-left of left

		// top
		// triangle one
	 	1.0f,  1.0f, -1.0f, // top-right of top
		-1.0f,  1.0f, -1.0f, // top-left of top
	 	1.0f,  1.0f,  1.0f, // bottom-right of top

		// triangle two
	 	1.0f,  1.0f,  1.0f, // bottom-right of top
		-1.0f,  1.0f, -1.0f, // top-left of top
		-1.0f,  1.0f,  1.0f, // bottom-left of top

		// bottom
		// triangle one
	 	1.0f, -1.0f,  1.0f, // top-right of bottom
		-1.0f, -1.0f,  1.0f, // top-left of bottom
	 	1.0f, -1.0f, -1.0f, // bottom-right of bottom
	
		// triangle two
	 	1.0f, -1.0f, -1.0f, // bottom-right of bottom
		-1.0f, -1.0f,  1.0f, // top-left of bottom
		-1.0f, -1.0f, -1.0f, // bottom-left of bottom
	};

	// Texcoord
	float cube_texcoord[] =
	{
		// front
		// triangle one
		1.0f, 1.0f, // top-right of front
		0.0f, 1.0f, // top-left of front
		1.0f, 0.0f, // bottom-right of front

		// triangle two
		1.0f, 0.0f, // bottom-right of front
		0.0f, 1.0f, // top-left of front
		0.0f, 0.0f, // bottom-left of front

		// right
		// triangle one
		1.0f, 1.0f, // top-right of right
		0.0f, 1.0f, // top-left of right
		1.0f, 0.0f, // bottom-right of right
	
		// triangle two
		1.0f, 0.0f, // bottom-right of right
		0.0f, 1.0f, // top-left of right
		0.0f, 0.0f, // bottom-left of right

		// back
		// triangle one
		1.0f, 1.0f, // top-right of back
		0.0f, 1.0f, // top-left of back
		1.0f, 0.0f, // bottom-right of back

		// triangle two
		1.0f, 0.0f, // bottom-right of back
		0.0f, 1.0f, // top-left of back
		0.0f, 0.0f, // bottom-left of back

		// left
		// triangle one
		1.0f, 1.0f, // top-right of left
		0.0f, 1.0f, // top-left of left
		1.0f, 0.0f, // bottom-right of left
	
		// triangle two
		1.0f, 0.0f, // bottom-right of left
		0.0f, 1.0f, // top-left of left
		0.0f, 0.0f, // bottom-left of left

		// top
		// triangle one
		1.0f, 1.0f, // top-right of top
		0.0f, 1.0f, // top-left of top
		1.0f, 0.0f, // bottom-right of top

		// triangle two
		1.0f, 0.0f, // bottom-right of top
		0.0f, 1.0f, // top-left of top
		0.0f, 0.0f, // bottom-left of top

		// bottom
		// triangle one
		1.0f, 1.0f, // top-right of bottom
		0.0f, 1.0f, // top-left of bottom
		1.0f, 0.0f, // bottom-right of bottom

		// triangle two
		1.0f, 0.0f, // bottom-right of bottom
		0.0f, 1.0f, // top-left of bottom
		0.0f, 0.0f, // bottom-left of bottom
	};
	
	// Vertex Position Buffer
	memset((void*)&vertexData_position, 0, sizeof(VertexData));

	VkBufferCreateInfo vkBufferCreateInfo;
	memset((void*)&vkBufferCreateInfo, 0, sizeof(VkBufferCreateInfo));

	vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
	vkBufferCreateInfo.pNext = NULL;
	vkBufferCreateInfo.flags = 0; // valid flags are used in scattered buffers
	vkBufferCreateInfo.size  = sizeof(cube_position);
	vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;

	vkResult = vkCreateBuffer(vkDevice, &vkBufferCreateInfo, NULL, &vertexData_position.vkBuffer);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVertexBuffer() -> vkCreateBuffer() is failed %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createVertexBuffer() -> vkCreateBuffer() Succeeded\n");
	}

	//
	VkMemoryRequirements vkMemoryRequirements;
	memset((void*) &vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));

	vkGetBufferMemoryRequirements(vkDevice, vertexData_position.vkBuffer, &vkMemoryRequirements);

	//
	VkMemoryAllocateInfo vkMemoryAllocateInfo;
	memset((void*)&vkMemoryAllocateInfo, 0, sizeof(VkMemoryAllocateInfo));

	vkMemoryAllocateInfo.sType 				= VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	vkMemoryAllocateInfo.pNext 				= NULL;
	vkMemoryAllocateInfo.allocationSize 	= vkMemoryRequirements.size;
	vkMemoryAllocateInfo.memoryTypeIndex 	= 0; // initiali value before entering into loop

	for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++){
		if((vkMemoryRequirements.memoryTypeBits & 1) == 1){
			if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT){
				vkMemoryAllocateInfo.memoryTypeIndex = i;
				break;
			}
		}
		vkMemoryRequirements.memoryTypeBits >>= 1;
	}

	vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_position.vkDeviceMemory);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVertexBuffer() -> vkAllocateMemory() is failed %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createVertexBuffer() -> vkAllocateMemory() Succeeded\n");
	}

	vkResult = vkBindBufferMemory(vkDevice, 
								vertexData_position.vkBuffer, 		// konala bind karaych
								vertexData_position.vkDeviceMemory, // kon bind karaych
								0
							);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVertexBuffer() -> vkBindBufferMemory() is failed %d\n", vkResult);									
	}
	else{
		fprintf(gpFILE, "createVertexBuffer() -> vkBindBufferMemory() Succeeded\n");
	}//02:34:00

	void* data = NULL;
	vkResult = vkMapMemory(vkDevice,
		vertexData_position.vkDeviceMemory, 
		0, 
		vkMemoryAllocateInfo.allocationSize, 
		0, // reserved must be zero as specification say
		&data
	);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVertexBuffer() -> vkMapMemory() is failed %d\n", vkResult);									
	}
	else{
		fprintf(gpFILE, "createVertexBuffer() -> vkMapMemory() Succeeded\n");
	}

	// Actual MEMCPY
	memcpy(data,cube_position, sizeof(cube_position));

	//
	vkUnmapMemory(vkDevice, vertexData_position.vkDeviceMemory);

	// Vertex Color Buffer
	memset((void*)&vertexData_texcoord, 0, sizeof(VertexData));

	memset((void*)&vkBufferCreateInfo, 0, sizeof(VkBufferCreateInfo));

	vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
	vkBufferCreateInfo.pNext = NULL;
	vkBufferCreateInfo.flags = 0; // valid flags are used in scattered buffers
	vkBufferCreateInfo.size  = sizeof(cube_texcoord);
	vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;

	vkResult = vkCreateBuffer(vkDevice, &vkBufferCreateInfo, NULL, &vertexData_texcoord.vkBuffer);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVertexBuffer() -> vkCreateBuffer() is failed for vertex texcoord %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createVertexBuffer() -> vkCreateBuffer() Succeeded vertex texcoord\n");
	}

	//
	memset((void*) &vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));

	vkGetBufferMemoryRequirements(vkDevice, vertexData_texcoord.vkBuffer, &vkMemoryRequirements);

	
	memset((void*)&vkMemoryAllocateInfo, 0, sizeof(VkMemoryAllocateInfo));

	vkMemoryAllocateInfo.sType 				= VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	vkMemoryAllocateInfo.pNext 				= NULL;
	vkMemoryAllocateInfo.allocationSize 	= vkMemoryRequirements.size;
	vkMemoryAllocateInfo.memoryTypeIndex 	= 0; // initiali value before entering into loop

	for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++){
		if((vkMemoryRequirements.memoryTypeBits & 1) == 1){
			if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT){
				vkMemoryAllocateInfo.memoryTypeIndex = i;
				break;
			}
		}
		vkMemoryRequirements.memoryTypeBits >>= 1;
	}

	vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_texcoord.vkDeviceMemory);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVertexBuffer() -> vkAllocateMemory() is failed for vertex texcoord buffer %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createVertexBuffer() -> vkAllocateMemory() Succeeded for vertex texcoord buffer\n");
	}

	vkResult = vkBindBufferMemory(vkDevice, 
								vertexData_texcoord.vkBuffer, 		// konala bind karaych
								vertexData_texcoord.vkDeviceMemory, // kon bind karaych
								0
							);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVertexBuffer() -> vkBindBufferMemory() is failed for vertex color buffer %d\n", vkResult);									
	}
	else{
		fprintf(gpFILE, "createVertexBuffer() -> vkBindBufferMemory() Succeeded for vertex color buffer\n");
	}//02:34:00

	data = NULL;
	vkResult = vkMapMemory(vkDevice,
		vertexData_texcoord.vkDeviceMemory, 
		0, 
		vkMemoryAllocateInfo.allocationSize, 
		0, // reserved must be zero as specification say
		&data
	);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createVertexBuffer() -> vkMapMemory() is failed for vertex color buffer %d\n", vkResult);									
	}
	else{
		fprintf(gpFILE, "createVertexBuffer() -> vkMapMemory() Succeeded for vertex color buffer\n");
	}

	// Actual MEMCPY
	memcpy(data, cube_texcoord, sizeof(cube_texcoord));

	//
	vkUnmapMemory(vkDevice, vertexData_texcoord.vkDeviceMemory);

	return vkResult;
}

// VkResult createTexture(const char* textureFileName[])
// {
// 	// Variable declarations
// 	VkResult vkResult = VK_SUCCESS;

// 	// Code
// 	// step 1 -> Get image data
// 	// FILE* fp = NULL;
// 	// fp = fopen(*textureFileName, "rb");
// 	// if (fp == NULL)
// 	// {
// 	// 	fprintf(gpFILE, "createTexture() -> fopen() is failed to %d\n", vkResult);	
// 	// 	fflush(gpFILE);						
// 	// }
// 	// else{
// 	// 	fprintf(gpFILE, "createTexture() -> fopen() Succeeded \n");
// 	// 	fflush(gpFILE);	
// 	// }

// 	// uint8_t* image_data = NULL;
// 	// int texture_width, texture_height, texture_channels;
// 	// image_data = stbi_load_from_file(fp, &texture_width, &texture_height, &texture_channels, STBI_rgb_alpha);
// 	// if (image_data == NULL || texture_width <= 0 || texture_height <= 0 || texture_channels <= 0)
// 	// {
// 	// 	fprintf(gpFILE, "createTexture() -> stbi_load_from_file() -> fopen() is failed to GET IMAGE INFO %d\n", vkResult);
// 	// 	fflush(gpFILE);	
// 	// 	vkResult = VK_ERROR_INITIALIZATION_FAILED;
// 	// 	return vkResult;								
// 	// }
// 	// else
// 	// {
// 	// 	fprintf(gpFILE, "createTexture() -> stbi_load_from_file() -> fopen() Succeeded \n");
// 	// 	fflush(gpFILE);	
// 	// }

// 	// VkDeviceSize image_size = texture_width * texture_height * 4; // 4 for rgba

// 	// Expect textureFileName to be const char* textureFileName[6]
// 	int faceWidth = 0, faceHeight = 0, faceChannels = 0;
// 	uint8_t* facePixels[6] = {0};
// 	VkDeviceSize faceSize = 0;

// 	// load all 6 faces
// 	for (int f = 0; f < 6; ++f) 
// 	{
//     	FILE* fp = fopen(textureFileName[f], "rb");
//     	if (!fp) 
// 		{
//         	fprintf(gpFILE, "createTexture() -> fopen() failed for %s\n", textureFileName[f]);
//         	return VK_ERROR_INITIALIZATION_FAILED;
//     	}
//     	facePixels[f] = stbi_load_from_file(fp, &faceWidth, &faceHeight, &faceChannels, STBI_rgb_alpha);
//     	fclose(fp);
//     	if (!facePixels[f]) 
// 		{
//         	fprintf(gpFILE, "createTexture() -> stbi_load_from_file() failed for %s\n", textureFileName[f]);
//         	// free previously loaded faces
//         	for (int i=0;i<f;i++) stbi_image_free(facePixels[i]);
//         		return VK_ERROR_INITIALIZATION_FAILED;
//     	}
// 	}
// 	// assume all faces have same dimensions — validate in real code
// 	faceSize = (VkDeviceSize)faceWidth * faceHeight * 4; // 4 bytes per texel (RGBA8)
// 	VkDeviceSize totalSize = faceSize * 6;


// 	// Step 2 -> Put above image data into staging buffer
// 	VkBuffer vkBuffer_stagingBuffer = VK_NULL_HANDLE;
// 	VkDeviceMemory VkDeviceMemory_stagingBuffer = VK_NULL_HANDLE;
// 	VkBufferCreateInfo vkBufferCreateInfo_stagingBuffer;

// 	memset((void*)&vkBufferCreateInfo_stagingBuffer, 0, sizeof(VkBufferCreateInfo));

// 	vkBufferCreateInfo_stagingBuffer.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
// 	vkBufferCreateInfo_stagingBuffer.pNext = NULL;
// 	vkBufferCreateInfo_stagingBuffer.size = totalSize;
// 	vkBufferCreateInfo_stagingBuffer.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT; //Because this data is our source to copy empty VkImage
// 	vkBufferCreateInfo_stagingBuffer.flags = 0;
// 	vkBufferCreateInfo_stagingBuffer.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

// 	vkResult = vkCreateBuffer(vkDevice, &vkBufferCreateInfo_stagingBuffer, NULL, &vkBuffer_stagingBuffer);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkCreateBuffer() is failed for vertex color buffer %d\n", vkResult);
// 		fflush(gpFILE);										
// 	}
// 	else{
// 		fprintf(gpFILE, "createTexture() -> vkCreateBuffer() Succeeded for vertex color buffer\n");
// 		fflush(gpFILE);	
// 	}

// 	VkMemoryRequirements vkMemoryRequirements_stagingBuffer;
// 	memset((void*)&vkMemoryRequirements_stagingBuffer, 0, sizeof(VkMemoryRequirements));

// 	vkGetBufferMemoryRequirements(vkDevice, vkBuffer_stagingBuffer, &vkMemoryRequirements_stagingBuffer);

// 	VkMemoryAllocateInfo vkMemoryAllocateInfo_stagingBuffer;
// 	memset((void*)&vkMemoryAllocateInfo_stagingBuffer, 0, sizeof(VkMemoryAllocateInfo));

// 	vkMemoryAllocateInfo_stagingBuffer.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
// 	vkMemoryAllocateInfo_stagingBuffer.pNext = NULL;
// 	vkMemoryAllocateInfo_stagingBuffer.allocationSize = vkMemoryRequirements_stagingBuffer.size;
// 	vkMemoryAllocateInfo_stagingBuffer.memoryTypeIndex = 0;

// 	for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
// 	{
// 		if((vkMemoryRequirements_stagingBuffer.memoryTypeBits & 1) == 1)
// 		{
// 			if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT))
// 			{
// 				vkMemoryAllocateInfo_stagingBuffer.memoryTypeIndex = i;
// 				break;
// 			}
// 		}
// 		vkMemoryRequirements_stagingBuffer.memoryTypeBits >>= 1;
// 	}

// 	vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo_stagingBuffer, NULL, &VkDeviceMemory_stagingBuffer);
// 	if (vkResult != VK_SUCCESS){
// 		fprintf(gpFILE, "createTexture() -> vkAllocateMemory() is failed for staging buffer device memory %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else{
// 		fprintf(gpFILE, "createTexture() -> vkAllocateMemory() Succeeded for staging buffer device memory\n");
// 		fflush(gpFILE);	
// 	}

// 	// bind.
// 	vkResult = vkBindBufferMemory(vkDevice, vkBuffer_stagingBuffer, VkDeviceMemory_stagingBuffer, 0);
// 	if (vkResult != VK_SUCCESS){
// 		fprintf(gpFILE, "createTexture() -> vkBindBufferMemory() is failed for staging buffer device memory %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else{
// 		fprintf(gpFILE, "createTexture() -> vkBindBufferMemory() Succeeded for staging buffer device memory\n");
// 		fflush(gpFILE);	
// 	}

// 	void* data = NULL;
// 	vkResult = vkMapMemory(vkDevice, VkDeviceMemory_stagingBuffer, 0, totalSize, 0, &data);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkMapMemory() is failed for staging buffer device memory %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else{
// 		fprintf(gpFILE, "createTexture() -> vkMapMemory() Succeeded for staging buffer device memory\n");
// 		fflush(gpFILE);	
// 	}

// 	 for (uint32_t f = 0; f < 6; ++f)
//     {
//         uint8_t* src = facePixels[f];
//         if (src)
//         {
//             VkDeviceSize dstOffset = (VkDeviceSize)f * faceSize;
//             memcpy((uint8_t*)data + dstOffset, src, (size_t)faceSize);
//         }
//     }
	
// 	vkUnmapMemory(vkDevice, VkDeviceMemory_stagingBuffer);

// 	// As copying of image data is already done into the staging buffer, we can free the actual image data give by stb
// 	for (int f = 0; f < 6; ++f)
//     {
//         stbi_image_free(facePixels[f]);
//         facePixels[f] = NULL;
//     }

// 	fprintf(gpFILE, "Image data done\n");

// 	// Step 3 -> 
// 	VkImageCreateInfo vkImageCreateInfo;
// 	memset((void*)&vkImageCreateInfo, 0, sizeof(VkImageCreateInfo));

// 	vkImageCreateInfo.sType 			= VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
// 	vkImageCreateInfo.pNext 			= NULL;
// 	vkImageCreateInfo.flags 			= VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT;
// 	vkImageCreateInfo.imageType 		= VK_IMAGE_TYPE_2D;
// 	vkImageCreateInfo.format 			= VK_FORMAT_R8G8B8A8_UNORM; // VK_FORMAT_R8G8B8A8_SRGB
// 	vkImageCreateInfo.extent.width 		= faceWidth;
// 	vkImageCreateInfo.extent.height 	= faceHeight;
// 	vkImageCreateInfo.extent.depth 		= 1;
// 	vkImageCreateInfo.mipLevels 		= 1;
// 	vkImageCreateInfo.arrayLayers 		= 6;
// 	vkImageCreateInfo.samples 			= VK_SAMPLE_COUNT_1_BIT;
// 	vkImageCreateInfo.tiling 			= VK_IMAGE_TILING_OPTIMAL;
// 	vkImageCreateInfo.usage 			= VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT; // imp
// 	vkImageCreateInfo.sharingMode 		= VK_SHARING_MODE_EXCLUSIVE;
// 	vkImageCreateInfo.initialLayout 	= VK_IMAGE_LAYOUT_UNDEFINED;

// 	// 01:54:00
// 	vkResult = vkCreateImage(vkDevice, &vkImageCreateInfo, NULL, &vkImage_texture);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkCreateImage() is failed for  %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else{
// 		fprintf(gpFILE, "createTexture() -> vkCreateImage() Succeeded \n");
// 		fflush(gpFILE);	
// 	}

// 	VkMemoryRequirements vkMemoryRequirements_image;
// 	memset((void*)&vkMemoryRequirements_image, 0, sizeof(VkMemoryRequirements));
	
// 	vkGetImageMemoryRequirements(vkDevice, vkImage_texture, &vkMemoryRequirements_image);

// 	VkMemoryAllocateInfo vkMemoryAllocateInfo_image;
// 	memset((void*)&vkMemoryAllocateInfo_image, 0, sizeof(VkMemoryAllocateInfo));

// 	vkMemoryAllocateInfo_image.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
// 	vkMemoryAllocateInfo_image.pNext = NULL;
// 	vkMemoryAllocateInfo_image.allocationSize = vkMemoryRequirements_image.size;
// 	vkMemoryAllocateInfo_image.memoryTypeIndex = 0;

// 	for(uint32_t i = 0; i<vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
// 	{
// 		if((vkMemoryRequirements_image.memoryTypeBits & 1)==1)
// 		{
// 			if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
// 			{
// 				vkMemoryAllocateInfo_image.memoryTypeIndex = i;
// 				break;
// 			}
// 		}
// 		vkMemoryRequirements_image.memoryTypeBits >>=1;
// 	}

// 	vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo_image, NULL, &vkDeviceMemory_texture);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkAllocateMemory() is failed %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else{
// 		fprintf(gpFILE, "createTexture() -> vkAllocateMemory() Succeeded\n");
// 		fflush(gpFILE);	
// 	}

// 	vkBindImageMemory(vkDevice, vkImage_texture, vkDeviceMemory_texture, 0);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkBindImageMemory() is failed %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkBindImageMemory() Succeeded\n");
// 		fflush(gpFILE);	
// 	}

// 	// Layout transition
// 	VkCommandBufferAllocateInfo vkCommandBufferAllocateInfo_transition_image_layout;
// 	memset((void*)&vkCommandBufferAllocateInfo_transition_image_layout, 0, sizeof(VkCommandBufferAllocateInfo));

// 	vkCommandBufferAllocateInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
// 	vkCommandBufferAllocateInfo_transition_image_layout.pNext = NULL;
// 	vkCommandBufferAllocateInfo_transition_image_layout.commandPool = vkCommandPool;
// 	vkCommandBufferAllocateInfo_transition_image_layout.commandBufferCount = 1;
// 	vkCommandBufferAllocateInfo_transition_image_layout.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
	
// 	VkCommandBuffer vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;

// 	vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo_transition_image_layout, &vkCommandBuffer_transition_image_layout);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> failed for vkAllocateCommandBuffers() is failed for command buffers buffer copy %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> Succeeded for vkAllocateCommandBuffers() Succeeded for command buffers buffer copy\n");
// 		fflush(gpFILE);	
// 	}

// 	VkCommandBufferBeginInfo vkCommandBufferBeginInfo_transition_image_layout;
// 	memset((void*)&vkCommandBufferBeginInfo_transition_image_layout, 0, sizeof(VkCommandBufferBeginInfo));

// 	vkCommandBufferBeginInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
// 	vkCommandBufferBeginInfo_transition_image_layout.pNext = NULL;
// 	vkCommandBufferBeginInfo_transition_image_layout.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;// IMPORTANT

// 	vkResult = vkBeginCommandBuffer(vkCommandBuffer_transition_image_layout, &vkCommandBufferBeginInfo_transition_image_layout);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkBeginCommandBuffer for RenderComplete is failed %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkBeginCommandBuffer for RenderComplete is Succeeded\n");
// 		fflush(gpFILE);	
// 	}

// 	VkPipelineStageFlags vkPipelineStageFlags_source = 0;
// 	VkPipelineStageFlags vkPipelineStageFlags_destination = 0;
// 	VkImageMemoryBarrier vkImageMemoryBarrier;

// 	memset((void*)&vkImageMemoryBarrier, 0, sizeof(VkImageMemoryBarrier));

// 	vkImageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
// 	vkImageMemoryBarrier.pNext = NULL;
// 	vkImageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
// 	vkImageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
// 	vkImageMemoryBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
// 	vkImageMemoryBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
// 	vkImageMemoryBarrier.image = vkImage_texture;
// 	vkImageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; // error HERE
// 	vkImageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
// 	vkImageMemoryBarrier.subresourceRange.baseMipLevel = 0;
// 	vkImageMemoryBarrier.subresourceRange.layerCount = 6;
// 	vkImageMemoryBarrier.subresourceRange.levelCount = 1;

// 	if(vkImageMemoryBarrier.oldLayout == VK_IMAGE_LAYOUT_UNDEFINED && vkImageMemoryBarrier.newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)
// 	{
// 		vkImageMemoryBarrier.srcAccessMask = 0;
// 		vkImageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
// 		vkPipelineStageFlags_source = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
// 		vkPipelineStageFlags_destination = VK_PIPELINE_STAGE_TRANSFER_BIT;
// 	}
// 	else if(vkImageMemoryBarrier.oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && vkImageMemoryBarrier.newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
// 	{
// 		vkImageMemoryBarrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
// 		vkImageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
// 		vkPipelineStageFlags_source = VK_PIPELINE_STAGE_TRANSFER_BIT;
// 		vkPipelineStageFlags_destination = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> Unsupported texture transition");
// 		vkResult = VK_ERROR_INITIALIZATION_FAILED;
// 		return vkResult;
// 	}

// 	vkCmdPipelineBarrier(vkCommandBuffer_transition_image_layout, vkPipelineStageFlags_source, vkPipelineStageFlags_destination, 0, 0, NULL, 0, NULL, 1, &vkImageMemoryBarrier);

// 	vkResult = vkEndCommandBuffer(vkCommandBuffer_transition_image_layout);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkEndCommandBuffer() for RenderComplete is failed %d\n",vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkEndCommandBuffer() for RenderComplete is Succeeded\n");
// 		fflush(gpFILE);	
// 	}

// 	VkSubmitInfo vkSubmitInf_transition_image_layout;
// 	memset((void*)&vkSubmitInf_transition_image_layout, 0, sizeof(VkSubmitInfo));

// 	vkSubmitInf_transition_image_layout.sType 				= VK_STRUCTURE_TYPE_SUBMIT_INFO;
// 	vkSubmitInf_transition_image_layout.pNext 				= NULL;
// 	vkSubmitInf_transition_image_layout.commandBufferCount 	= 1;
// 	vkSubmitInf_transition_image_layout.pCommandBuffers 	= &vkCommandBuffer_transition_image_layout;

// 	vkResult = vkQueueSubmit(vkQueue, 1, &vkSubmitInf_transition_image_layout, VK_NULL_HANDLE);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkQueueSubmit() failed ! \n");
// 		fflush(gpFILE);	
// 		return vkResult;
// 	}
// 	// else
// 	// {
// 	// 	fprintf(gpFILE, "createTexture() -> vkQueueSubmit() f Succeeded\n");
// 	// }

// 	vkResult = vkQueueWaitIdle(vkQueue);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkQueueWaitIdle() failed ! \n");
// 		fflush(gpFILE);	
// 		return vkResult;
// 	}

// 	if (vkCommandBuffer_transition_image_layout)
// 	{
// 		vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_transition_image_layout);
// 		vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;
// 		fprintf(gpFILE, "createTexture() -> vkCommandBuffer_transition_image_layout freed ! \n");
// 		fflush(gpFILE);	
// 	}

// 	// step 5
// 	VkCommandBufferAllocateInfo vkCommandBufferAllocateInfo_buffer_to_image_copy;
// 	memset((void*)&vkCommandBufferAllocateInfo_buffer_to_image_copy, 0, sizeof(VkCommandBufferAllocateInfo));

// 	vkCommandBufferAllocateInfo_buffer_to_image_copy.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
// 	vkCommandBufferAllocateInfo_buffer_to_image_copy.pNext = NULL;
// 	vkCommandBufferAllocateInfo_buffer_to_image_copy.commandPool = vkCommandPool;
// 	vkCommandBufferAllocateInfo_buffer_to_image_copy.commandBufferCount = 1;
// 	vkCommandBufferAllocateInfo_buffer_to_image_copy.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
	
// 	VkCommandBuffer vkCommandBuffer_buffer_to_image_copy = VK_NULL_HANDLE;

// 	vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo_buffer_to_image_copy, &vkCommandBuffer_buffer_to_image_copy);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> failed for vkAllocateCommandBuffers() is failed for command buffers buffer copy %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> Succeeded for vkAllocateCommandBuffers() Succeeded for command buffers buffer copy\n");
// 		fflush(gpFILE);	
// 	}

// 	VkCommandBufferBeginInfo vkCommandBufferBeginInfo_buffer_to_image_copy;
// 	memset((void*)&vkCommandBufferBeginInfo_buffer_to_image_copy, 0, sizeof(VkCommandBufferBeginInfo));

// 	vkCommandBufferBeginInfo_buffer_to_image_copy.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
// 	vkCommandBufferBeginInfo_buffer_to_image_copy.pNext = NULL;
// 	vkCommandBufferBeginInfo_buffer_to_image_copy.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;// IMPORTANT

// 	vkResult = vkBeginCommandBuffer(vkCommandBuffer_buffer_to_image_copy, &vkCommandBufferBeginInfo_buffer_to_image_copy);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkBeginCommandBuffer for RenderComplete is failed %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkBeginCommandBuffer for RenderComplete is Succeeded\n");
// 		fflush(gpFILE);	
// 	}

// 	VkBufferImageCopy vkBufferImageCopy[6];
// 	for (uint32_t face = 0; face < 6; ++face) 
// 	{
// 		memset((void*)vkBufferImageCopy, 0, sizeof(VkBufferImageCopy));

// 		vkBufferImageCopy[face].bufferOffset = 0;
// 		vkBufferImageCopy[face].bufferRowLength = 0;
// 		vkBufferImageCopy[face].bufferImageHeight = 0;
// 		vkBufferImageCopy[face].imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
// 		vkBufferImageCopy[face].imageSubresource.mipLevel = 0;
// 		vkBufferImageCopy[face].imageSubresource.baseArrayLayer = 0;
// 		vkBufferImageCopy[face].imageSubresource.layerCount = 1;
// 		vkBufferImageCopy[face].imageOffset.x = 0;
// 		vkBufferImageCopy[face].imageOffset.y = 0;
// 		vkBufferImageCopy[face].imageOffset.z = 0;
// 		vkBufferImageCopy[face].imageExtent.width = faceWidth;
// 		vkBufferImageCopy[face].imageExtent.height = faceHeight;
// 		vkBufferImageCopy[face].imageExtent.depth = 1;
// 	}
	

// 	vkCmdCopyBufferToImage(vkCommandBuffer_buffer_to_image_copy, vkBuffer_stagingBuffer, vkImage_texture, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, vkBufferImageCopy);

// 	vkResult = vkEndCommandBuffer(vkCommandBuffer_buffer_to_image_copy);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkEndCommandBuffer() for vkCommandBuffer_buffer_to_image_copy is failed %d\n",vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkEndCommandBuffer() for vkCommandBuffer_buffer_to_image_copy is Succeeded\n");
// 		fflush(gpFILE);	
// 	}

// 	VkSubmitInfo vkSubmitInfo_buffer_to_image_copy;
// 	memset((void*)&vkSubmitInfo_buffer_to_image_copy, 0, sizeof(VkSubmitInfo));

// 	vkSubmitInfo_buffer_to_image_copy.sType 				= VK_STRUCTURE_TYPE_SUBMIT_INFO;
// 	vkSubmitInfo_buffer_to_image_copy.pNext 				= NULL;
// 	vkSubmitInfo_buffer_to_image_copy.commandBufferCount 	= 1;
// 	vkSubmitInfo_buffer_to_image_copy.pCommandBuffers 	= &vkCommandBuffer_buffer_to_image_copy;

// 	vkResult = vkQueueSubmit(vkQueue, 1, &vkSubmitInfo_buffer_to_image_copy, VK_NULL_HANDLE);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkQueueSubmit() failed for vkSubmitInfo_buffer_to_image_copy ! \n");
// 		fflush(gpFILE);	
// 		return vkResult;
// 	}
// 	// else
// 	// {
// 	// 	fprintf(gpFILE, "createTexture() -> vkQueueSubmit() f Succeeded\n");
// 	// }

// 	vkResult = vkQueueWaitIdle(vkQueue);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkQueueWaitIdle() failed ! \n");
// 		fflush(gpFILE);	
// 		return vkResult;
// 	}

// 	if (vkCommandBuffer_buffer_to_image_copy)
// 	{
// 		vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_buffer_to_image_copy);
// 		vkCommandBuffer_buffer_to_image_copy = VK_NULL_HANDLE;
// 		fprintf(gpFILE, "createTexture() -> vkCommandBuffer_buffer_to_image_copy freed ! \n");
// 		fflush(gpFILE);	
// 	}

// 	// step 6
// 	// Layout transition
// 	memset((void*)&vkCommandBufferAllocateInfo_transition_image_layout, 0, sizeof(VkCommandBufferAllocateInfo));

// 	vkCommandBufferAllocateInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
// 	vkCommandBufferAllocateInfo_transition_image_layout.pNext = NULL;
// 	vkCommandBufferAllocateInfo_transition_image_layout.commandPool = vkCommandPool;
// 	vkCommandBufferAllocateInfo_transition_image_layout.commandBufferCount = 1;
// 	vkCommandBufferAllocateInfo_transition_image_layout.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
	
// 	vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;

// 	vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo_transition_image_layout, &vkCommandBuffer_transition_image_layout);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> failed for vkAllocateCommandBuffers() is failed for command buffers buffer copy %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> Succeeded for vkAllocateCommandBuffers() Succeeded for command buffers buffer copy\n");
// 		fflush(gpFILE);	
// 	}

// 	memset((void*)&vkCommandBufferBeginInfo_transition_image_layout, 0, sizeof(VkCommandBufferBeginInfo));

// 	vkCommandBufferBeginInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
// 	vkCommandBufferBeginInfo_transition_image_layout.pNext = NULL;
// 	vkCommandBufferBeginInfo_transition_image_layout.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;// IMPORTANT

// 	vkResult = vkBeginCommandBuffer(vkCommandBuffer_transition_image_layout, &vkCommandBufferBeginInfo_transition_image_layout);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkBeginCommandBuffer for RenderComplete is failed %d\n", vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkBeginCommandBuffer for RenderComplete is Succeeded\n");
// 		fflush(gpFILE);	
// 	}

// 	vkPipelineStageFlags_source = 0;
// 	vkPipelineStageFlags_destination = 0;
	

// 	memset((void*)&vkImageMemoryBarrier, 0, sizeof(VkImageMemoryBarrier));

// 	vkImageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
// 	vkImageMemoryBarrier.pNext = NULL;
// 	vkImageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
// 	vkImageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
// 	vkImageMemoryBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
// 	vkImageMemoryBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
// 	vkImageMemoryBarrier.image = vkImage_texture;
// 	vkImageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; // error HERE
// 	vkImageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
// 	vkImageMemoryBarrier.subresourceRange.baseMipLevel = 0;
// 	vkImageMemoryBarrier.subresourceRange.layerCount = 1;
// 	vkImageMemoryBarrier.subresourceRange.levelCount = 1;

// 	if(vkImageMemoryBarrier.oldLayout == VK_IMAGE_LAYOUT_UNDEFINED && vkImageMemoryBarrier.newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)
// 	{
// 		vkImageMemoryBarrier.srcAccessMask = 0;
// 		vkImageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
// 		vkPipelineStageFlags_source = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
// 		vkPipelineStageFlags_destination = VK_PIPELINE_STAGE_TRANSFER_BIT;
// 	}
// 	else if(vkImageMemoryBarrier.oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && vkImageMemoryBarrier.newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
// 	{
// 		vkImageMemoryBarrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
// 		vkImageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
// 		vkPipelineStageFlags_source = VK_PIPELINE_STAGE_TRANSFER_BIT;
// 		vkPipelineStageFlags_destination = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> Unsupported texture transition FOR SECOND CALL");
// 		fflush(gpFILE);	
// 		vkResult = VK_ERROR_INITIALIZATION_FAILED;
// 		return vkResult;
// 	}

// 	vkCmdPipelineBarrier(vkCommandBuffer_transition_image_layout, vkPipelineStageFlags_source, vkPipelineStageFlags_destination, 0, 0, NULL, 0, NULL, 1, &vkImageMemoryBarrier);

// 	vkResult = vkEndCommandBuffer(vkCommandBuffer_transition_image_layout);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkEndCommandBuffer() for RenderComplete is failed %d\n",vkResult);
// 		fflush(gpFILE);	
// 	}
// 	else
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkEndCommandBuffer() for RenderComplete is Succeeded\n");
// 		fflush(gpFILE);	
// 	}

// 	memset((void*)&vkSubmitInf_transition_image_layout, 0, sizeof(VkSubmitInfo));

// 	vkSubmitInf_transition_image_layout.sType 				= VK_STRUCTURE_TYPE_SUBMIT_INFO;
// 	vkSubmitInf_transition_image_layout.pNext 				= NULL;
// 	vkSubmitInf_transition_image_layout.commandBufferCount 	= 1;
// 	vkSubmitInf_transition_image_layout.pCommandBuffers 	= &vkCommandBuffer_transition_image_layout;

// 	vkResult = vkQueueSubmit(vkQueue, 1, &vkSubmitInf_transition_image_layout, VK_NULL_HANDLE);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkQueueSubmit() failed ! \n");
// 		fflush(gpFILE);	
// 		return vkResult;
// 	}
// 	// else
// 	// {
// 	// 	fprintf(gpFILE, "createTexture() -> vkQueueSubmit() f Succeeded\n");
// 	// }

// 	vkResult = vkQueueWaitIdle(vkQueue);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkQueueWaitIdle() failed ! \n");
// 		fflush(gpFILE);	
// 		return vkResult;
// 	}

// 	if (vkCommandBuffer_transition_image_layout)
// 	{
// 		vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_transition_image_layout);
// 		vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;
// 		fprintf(gpFILE, "createTexture() -> vkCommandBuffer_transition_image_layout freed ! \n");
// 		fflush(gpFILE);	
// 	}

// 	// STEP 7
// 	if (VkDeviceMemory_stagingBuffer){
// 		vkFreeMemory(vkDevice, VkDeviceMemory_stagingBuffer, NULL);
// 		VkDeviceMemory_stagingBuffer = VK_NULL_HANDLE;
// 		fprintf(gpFILE, "createTexture() -> VkDeviceMemory_stagingBuffer freed ! \n");
// 		fflush(gpFILE);	
// 	}

// 	if (vkBuffer_stagingBuffer){
// 		vkDestroyBuffer(vkDevice, vkBuffer_stagingBuffer, NULL);
// 		vkBuffer_stagingBuffer = VK_NULL_HANDLE;
// 		fprintf(gpFILE, "createTexture() -> vkBuffer_stagingBuffer freed ! \n");
// 		fflush(gpFILE);	
// 	}

// 	// step 8
// 	VkImageViewCreateInfo vkImageViewCreateInfo;
// 	memset((void*)&vkImageViewCreateInfo, 0, sizeof(VkImageViewCreateInfo));

// 	vkImageViewCreateInfo.sType 							= VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
// 	vkImageViewCreateInfo.pNext 							= NULL;
// 	vkImageViewCreateInfo.flags 							= 0;
// 	vkImageViewCreateInfo.format 							= VK_FORMAT_R8G8B8A8_UNORM;
// 	vkImageViewCreateInfo.subresourceRange.aspectMask 		= VK_IMAGE_ASPECT_COLOR_BIT; // IMP
// 	vkImageViewCreateInfo.subresourceRange.baseMipLevel 	= 0;
// 	vkImageViewCreateInfo.subresourceRange.levelCount 		= 1;
// 	vkImageViewCreateInfo.subresourceRange.baseArrayLayer 	= 0;
// 	vkImageViewCreateInfo.subresourceRange.layerCount 		= 6;
// 	vkImageViewCreateInfo.viewType 							= VK_IMAGE_VIEW_TYPE_CUBE;
// 	vkImageViewCreateInfo.image 							= vkImage_texture; // IMP

// 	vkResult = vkCreateImageView(vkDevice, &vkImageViewCreateInfo, NULL, &vkImageView_texture);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkCreateImageView() is failed %d\n", vkResult);	
// 		fflush(gpFILE);									
// 	}
// 	else{
// 		fprintf(gpFILE, "createTexture() -> vkCreateImageView() Succeeded\n");
// 		fflush(gpFILE);	
// 	}

// 	// step 9
// 	VkSamplerCreateInfo vkSamplerCreateInfo;
// 	memset((void*)&vkSamplerCreateInfo, 0, sizeof(VkSamplerCreateInfo));

// 	vkSamplerCreateInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
// 	vkSamplerCreateInfo.pNext = NULL;
// 	vkSamplerCreateInfo.magFilter = VK_FILTER_LINEAR;
// 	vkSamplerCreateInfo.minFilter = VK_FILTER_LINEAR;
// 	vkSamplerCreateInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
// 	vkSamplerCreateInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
// 	vkSamplerCreateInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
// 	vkSamplerCreateInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
// 	vkSamplerCreateInfo.anisotropyEnable = VK_TRUE;
// 	vkSamplerCreateInfo.maxAnisotropy = 16;
// 	vkSamplerCreateInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
// 	vkSamplerCreateInfo.unnormalizedCoordinates = VK_FALSE;
// 	vkSamplerCreateInfo.compareEnable = VK_FALSE;
// 	vkSamplerCreateInfo.compareOp = VK_COMPARE_OP_ALWAYS;
	
	
// 	vkResult = vkCreateSampler(vkDevice, &vkSamplerCreateInfo, NULL, &vkSampler_texture);
// 	if (vkResult != VK_SUCCESS)
// 	{
// 		fprintf(gpFILE, "createTexture() -> vkCreateSampler() is failed %d\n", vkResult);	
// 		fflush(gpFILE);									
// 	}
// 	else{
// 		fprintf(gpFILE, "createTexture() -> vkCreateSampler() Succeeded\n");
// 		fflush(gpFILE);	
// 	}

// 	return vkResult;	
// }

VkResult createTexture(const char* textureFileName[])
{
    VkResult vkResult = VK_SUCCESS;

    int faceWidth = 0, faceHeight = 0, faceChannels = 0;
    uint8_t* facePixels[6] = { 0 };
    VkDeviceSize faceSize = 0;
    VkDeviceSize totalSize = 0;

    // Load all 6 faces using stb_image
    for (int f = 0; f < 6; ++f)
    {
        facePixels[f] = stbi_load(textureFileName[f], &faceWidth, &faceHeight, &faceChannels, STBI_rgb_alpha);
        if (!facePixels[f])
        {
            fprintf(gpFILE, "createTexture() -> stbi_load() failed for %s\n", textureFileName[f]);
            fflush(gpFILE);
            // free any previously loaded faces
            for (int i = 0; i < f; ++i)
                stbi_image_free(facePixels[i]);
            return VK_ERROR_INITIALIZATION_FAILED;
        }
    }

    // assume all faces same dims; compute sizes
    faceSize = (VkDeviceSize)faceWidth * (VkDeviceSize)faceHeight * 4; // RGBA8
    totalSize = faceSize * 6;

    // --- Step 2: create staging buffer ---
    VkBuffer vkBuffer_stagingBuffer = VK_NULL_HANDLE;
    VkDeviceMemory VkDeviceMemory_stagingBuffer = VK_NULL_HANDLE;

    VkBufferCreateInfo vkBufferCreateInfo_stagingBuffer; 
	memset((void*)&vkBufferCreateInfo_stagingBuffer, 0, sizeof(VkBufferCreateInfo));

    vkBufferCreateInfo_stagingBuffer.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo_stagingBuffer.size = totalSize;
    vkBufferCreateInfo_stagingBuffer.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
    vkBufferCreateInfo_stagingBuffer.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    vkResult = vkCreateBuffer(vkDevice, &vkBufferCreateInfo_stagingBuffer, NULL, &vkBuffer_stagingBuffer);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkCreateBuffer() failed: %d\n", vkResult);
        fflush(gpFILE);
        
    }

    VkMemoryRequirements vkMemoryRequirements_stagingBuffer;
    vkGetBufferMemoryRequirements(vkDevice, vkBuffer_stagingBuffer, &vkMemoryRequirements_stagingBuffer);

    VkMemoryAllocateInfo vkMemoryAllocateInfo_stagingBuffer;
	memset((void*)&vkMemoryAllocateInfo_stagingBuffer, 0, sizeof(VkMemoryAllocateInfo));

    vkMemoryAllocateInfo_stagingBuffer.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo_stagingBuffer.allocationSize = vkMemoryRequirements_stagingBuffer.size;

    // find memory type index with HOST_VISIBLE | HOST_COHERENT
    uint32_t memTypeBits = vkMemoryRequirements_stagingBuffer.memoryTypeBits;
    vkMemoryAllocateInfo_stagingBuffer.memoryTypeIndex = UINT32_MAX;
    for (uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; ++i)
    {
        if (memTypeBits & (1u << i))
        {
            VkMemoryPropertyFlags flags = vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags;
            if ((flags & (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) ==
                 (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT))
            {
                vkMemoryAllocateInfo_stagingBuffer.memoryTypeIndex = i;
                break;
            }
        }
    }

    if (vkMemoryAllocateInfo_stagingBuffer.memoryTypeIndex == UINT32_MAX)
    {
        fprintf(gpFILE, "createTexture() -> no suitable memory type found for staging buffer\n");
        fflush(gpFILE);
        vkResult = VK_ERROR_MEMORY_MAP_FAILED;
        
    }

    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo_stagingBuffer, NULL, &VkDeviceMemory_stagingBuffer);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkAllocateMemory() failed for staging buffer: %d\n", vkResult);
        fflush(gpFILE);
    }

    vkResult = vkBindBufferMemory(vkDevice, vkBuffer_stagingBuffer, VkDeviceMemory_stagingBuffer, 0);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkBindBufferMemory() failed for staging buffer: %d\n", vkResult);
        fflush(gpFILE);
    }

    // Map and copy each face into staging buffer at offset
    void* data = NULL;
    vkResult = vkMapMemory(vkDevice, VkDeviceMemory_stagingBuffer, 0, totalSize, 0, &data);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkMapMemory() failed: %d\n", vkResult);
        fflush(gpFILE);
    }

    for (uint32_t f = 0; f < 6; ++f)
    {
        uint8_t* src = facePixels[f];
        if (src)
        {
            VkDeviceSize dstOffset = (VkDeviceSize)f * faceSize;
            memcpy((uint8_t*)data + dstOffset, src, (size_t)faceSize);
        }
    }

    vkUnmapMemory(vkDevice, VkDeviceMemory_stagingBuffer);

    // free loaded images (we already copied to staging)
    for (int f = 0; f < 6; ++f)
    {
        stbi_image_free(facePixels[f]);
        facePixels[f] = NULL;
    }

    fprintf(gpFILE, "Image data copied into staging buffer\n");
    fflush(gpFILE);

    // --- Step 3: create cubemap image ---
    VkImageCreateInfo vkImageCreateInfo;
	memset((void*)&vkImageCreateInfo, 0, sizeof(VkImageCreateInfo));


    vkImageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    vkImageCreateInfo.flags = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT;
    vkImageCreateInfo.imageType = VK_IMAGE_TYPE_2D;
    vkImageCreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
    vkImageCreateInfo.extent.width = (uint32_t)faceWidth;
    vkImageCreateInfo.extent.height = (uint32_t)faceHeight;
    vkImageCreateInfo.extent.depth = 1;
    vkImageCreateInfo.mipLevels = 1;
    vkImageCreateInfo.arrayLayers = 6;
    vkImageCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    vkImageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
    vkImageCreateInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
    vkImageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    vkImageCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

    vkResult = vkCreateImage(vkDevice, &vkImageCreateInfo, NULL, &vkImage_texture);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkCreateImage() failed: %d\n", vkResult);
        fflush(gpFILE);
    }

    VkMemoryRequirements vkMemoryRequirements_image;
    vkGetImageMemoryRequirements(vkDevice, vkImage_texture, &vkMemoryRequirements_image);

    VkMemoryAllocateInfo vkMemoryAllocateInfo_image;
	memset((void*)&vkMemoryAllocateInfo_image, 0, sizeof(VkMemoryAllocateInfo));

    vkMemoryAllocateInfo_image.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo_image.allocationSize = vkMemoryRequirements_image.size;
    vkMemoryAllocateInfo_image.memoryTypeIndex = UINT32_MAX;

    uint32_t memBitsImage = vkMemoryRequirements_image.memoryTypeBits;
    for (uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; ++i)
    {
        if (memBitsImage & (1u << i))
        {
            if (vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
            {
                vkMemoryAllocateInfo_image.memoryTypeIndex = i;
                break;
            }
        }
    }

    if (vkMemoryAllocateInfo_image.memoryTypeIndex == UINT32_MAX)
    {
        fprintf(gpFILE, "createTexture() -> no suitable memory type found for image\n");
        fflush(gpFILE);
        vkResult = VK_ERROR_MEMORY_MAP_FAILED;
    }

    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo_image, NULL, &vkDeviceMemory_texture);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkAllocateMemory() failed for image: %d\n", vkResult);
        fflush(gpFILE);
    }

    vkResult = vkBindImageMemory(vkDevice, vkImage_texture, vkDeviceMemory_texture, 0);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkBindImageMemory() failed: %d\n", vkResult);
        fflush(gpFILE);
    }

    // --- Transition image layout: UNDEFINED -> TRANSFER_DST_OPTIMAL ---
    VkCommandBufferAllocateInfo vkCommandBufferAllocateInfo_transition_image_layout;
	memset((void*)&vkCommandBufferAllocateInfo_transition_image_layout, 0, sizeof(VkCommandBufferAllocateInfo));

    vkCommandBufferAllocateInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    vkCommandBufferAllocateInfo_transition_image_layout.commandPool = vkCommandPool;
    vkCommandBufferAllocateInfo_transition_image_layout.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    vkCommandBufferAllocateInfo_transition_image_layout.commandBufferCount = 1;

    VkCommandBuffer vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;
    vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo_transition_image_layout, &vkCommandBuffer_transition_image_layout);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkAllocateCommandBuffers() failed: %d\n", vkResult);
        fflush(gpFILE);
    }

    VkCommandBufferBeginInfo vkCommandBufferBeginInfo_transition_image_layout;
	memset((void*)&vkCommandBufferBeginInfo_transition_image_layout, 0, sizeof(VkCommandBufferBeginInfo));

    vkCommandBufferBeginInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkCommandBufferBeginInfo_transition_image_layout.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

    vkResult = vkBeginCommandBuffer(vkCommandBuffer_transition_image_layout, &vkCommandBufferBeginInfo_transition_image_layout);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkBeginCommandBuffer() failed: %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_transition;
    }

    VkImageMemoryBarrier vkImageMemoryBarrier;
	memset((void*)&vkImageMemoryBarrier, 0, sizeof(VkImageMemoryBarrier));

    vkImageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    vkImageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    vkImageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    vkImageMemoryBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    vkImageMemoryBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    vkImageMemoryBarrier.image = vkImage_texture;
    vkImageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    vkImageMemoryBarrier.subresourceRange.baseMipLevel = 0;
    vkImageMemoryBarrier.subresourceRange.levelCount = 1;
    vkImageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
    vkImageMemoryBarrier.subresourceRange.layerCount = 6;

    vkImageMemoryBarrier.srcAccessMask = 0;
    vkImageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

    VkPipelineStageFlags srcStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    VkPipelineStageFlags dstStage = VK_PIPELINE_STAGE_TRANSFER_BIT;

    vkCmdPipelineBarrier(
        vkCommandBuffer_transition_image_layout,
        srcStage, dstStage,
        0,
        0, NULL,
        0, NULL,
        1, &vkImageMemoryBarrier);

    vkResult = vkEndCommandBuffer(vkCommandBuffer_transition_image_layout);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkEndCommandBuffer() failed: %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_transition;
    }

    VkSubmitInfo submitInfo_transition;
	memset((void*)&submitInfo_transition, 0, sizeof(VkSubmitInfo));

    submitInfo_transition.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo_transition.commandBufferCount = 1;
    submitInfo_transition.pCommandBuffers = &vkCommandBuffer_transition_image_layout;

    vkResult = vkQueueSubmit(vkQueue, 1, &submitInfo_transition, VK_NULL_HANDLE);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkQueueSubmit() failed: %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_transition;
    }

    vkResult = vkQueueWaitIdle(vkQueue);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkQueueWaitIdle() failed: %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_transition;
    }

free_cmdbuf_transition:
    if (vkCommandBuffer_transition_image_layout && vkDevice)
    {
        vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_transition_image_layout);
        vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;
    }



    // --- Step 5: copy buffer -> image using 6 bufferImageCopy entries ---
    VkCommandBufferAllocateInfo vkCommandBufferAllocateInfo_buffer_to_image_copy;
	memset((void*)&vkCommandBufferAllocateInfo_buffer_to_image_copy, 0, sizeof(VkCommandBufferAllocateInfo));

    vkCommandBufferAllocateInfo_buffer_to_image_copy.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    vkCommandBufferAllocateInfo_buffer_to_image_copy.commandPool = vkCommandPool;
    vkCommandBufferAllocateInfo_buffer_to_image_copy.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    vkCommandBufferAllocateInfo_buffer_to_image_copy.commandBufferCount = 1;

    VkCommandBuffer vkCommandBuffer_buffer_to_image_copy = VK_NULL_HANDLE;
    vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo_buffer_to_image_copy, &vkCommandBuffer_buffer_to_image_copy);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkAllocateCommandBuffers() failed (copy): %d\n", vkResult);
        fflush(gpFILE);
        
    }

    VkCommandBufferBeginInfo vkCommandBufferBeginInfo_buffer_to_image_copy;
	memset((void*)&vkCommandBufferBeginInfo_buffer_to_image_copy, 0, sizeof(VkCommandBufferBeginInfo));

    vkCommandBufferBeginInfo_buffer_to_image_copy.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkCommandBufferBeginInfo_buffer_to_image_copy.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

    vkResult = vkBeginCommandBuffer(vkCommandBuffer_buffer_to_image_copy, &vkCommandBufferBeginInfo_buffer_to_image_copy);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkBeginCommandBuffer() failed (copy): %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_copy;
    }

    VkBufferImageCopy vkBufferImageCopy[6];
    for (uint32_t face = 0; face < 6; ++face)
    {
        memset(&vkBufferImageCopy[face], 0, sizeof(VkBufferImageCopy));
        vkBufferImageCopy[face].bufferOffset = (VkDeviceSize)face * faceSize;
        vkBufferImageCopy[face].bufferRowLength = 0;
        vkBufferImageCopy[face].bufferImageHeight = 0;
        vkBufferImageCopy[face].imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        vkBufferImageCopy[face].imageSubresource.mipLevel = 0;
        vkBufferImageCopy[face].imageSubresource.baseArrayLayer = face;
        vkBufferImageCopy[face].imageSubresource.layerCount = 1;
		vkBufferImageCopy[face].imageOffset.x = 0;
		vkBufferImageCopy[face].imageOffset.y = 0;
		vkBufferImageCopy[face].imageOffset.z = 0;
		vkBufferImageCopy[face].imageExtent.width = faceWidth;
		vkBufferImageCopy[face].imageExtent.height = faceHeight;
		vkBufferImageCopy[face].imageExtent.depth = 1;
    }

    vkCmdCopyBufferToImage(
        vkCommandBuffer_buffer_to_image_copy,
        vkBuffer_stagingBuffer,
        vkImage_texture,
        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        6,
        vkBufferImageCopy);

    vkResult = vkEndCommandBuffer(vkCommandBuffer_buffer_to_image_copy);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkEndCommandBuffer() failed (copy): %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_copy;
    }

    VkSubmitInfo submitInfo_copy;
	memset((void*)&submitInfo_copy, 0, sizeof(VkSubmitInfo));

    submitInfo_copy.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo_copy.commandBufferCount = 1;
    submitInfo_copy.pCommandBuffers = &vkCommandBuffer_buffer_to_image_copy;

    vkResult = vkQueueSubmit(vkQueue, 1, &submitInfo_copy, VK_NULL_HANDLE);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkQueueSubmit() failed (copy): %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_copy;
    }

    vkResult = vkQueueWaitIdle(vkQueue);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkQueueWaitIdle() failed (copy): %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_copy;
    }

free_cmdbuf_copy:
    if (vkCommandBuffer_buffer_to_image_copy && vkDevice)
    {
        vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_buffer_to_image_copy);
        vkCommandBuffer_buffer_to_image_copy = VK_NULL_HANDLE;
    }

   

    // --- Step 6: transition image to SHADER_READ_ONLY_OPTIMAL (layerCount = 6) ---
    // re-allocate and begin command buffer for transition
    vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;
    vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo_transition_image_layout, &vkCommandBuffer_transition_image_layout);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkAllocateCommandBuffers() failed (second transition): %d\n", vkResult);
        fflush(gpFILE);
       
    }

    memset(&vkCommandBufferBeginInfo_transition_image_layout, 0, sizeof(VkCommandBufferBeginInfo));
    vkCommandBufferBeginInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkCommandBufferBeginInfo_transition_image_layout.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

    vkResult = vkBeginCommandBuffer(vkCommandBuffer_transition_image_layout, &vkCommandBufferBeginInfo_transition_image_layout);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkBeginCommandBuffer() failed (second transition): %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_final_transition;
    }

    memset(&vkImageMemoryBarrier, 0, sizeof(VkImageMemoryBarrier));
    vkImageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    vkImageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    vkImageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkImageMemoryBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    vkImageMemoryBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    vkImageMemoryBarrier.image = vkImage_texture;
    vkImageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    vkImageMemoryBarrier.subresourceRange.baseMipLevel = 0;
    vkImageMemoryBarrier.subresourceRange.levelCount = 1;
    vkImageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
    vkImageMemoryBarrier.subresourceRange.layerCount = 6;

    vkImageMemoryBarrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    vkImageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

    srcStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    dstStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;

    vkCmdPipelineBarrier(
        vkCommandBuffer_transition_image_layout,
        srcStage, dstStage,
        0,
        0, NULL,
        0, NULL,
        1, &vkImageMemoryBarrier);

    vkResult = vkEndCommandBuffer(vkCommandBuffer_transition_image_layout);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkEndCommandBuffer() failed (second transition): %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_final_transition;
    }

    VkSubmitInfo submitInfo_final_transition;
	memset((void*)&submitInfo_final_transition, 0, sizeof(VkSubmitInfo));
	
    submitInfo_final_transition.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo_final_transition.commandBufferCount = 1;
    submitInfo_final_transition.pCommandBuffers = &vkCommandBuffer_transition_image_layout;

    vkResult = vkQueueSubmit(vkQueue, 1, &submitInfo_final_transition, VK_NULL_HANDLE);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkQueueSubmit() failed (second transition): %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_final_transition;
    }

    vkResult = vkQueueWaitIdle(vkQueue);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkQueueWaitIdle() failed (second transition): %d\n", vkResult);
        fflush(gpFILE);
        goto free_cmdbuf_final_transition;
    }

free_cmdbuf_final_transition:
    if (vkCommandBuffer_transition_image_layout && vkDevice)
    {
        vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_transition_image_layout);
        vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;
    }

   

    // --- Step 7: clean up staging buffer ---
    if (VkDeviceMemory_stagingBuffer)
    {
        vkFreeMemory(vkDevice, VkDeviceMemory_stagingBuffer, NULL);
        VkDeviceMemory_stagingBuffer = VK_NULL_HANDLE;
    }
    if (vkBuffer_stagingBuffer)
    {
        vkDestroyBuffer(vkDevice, vkBuffer_stagingBuffer, NULL);
        vkBuffer_stagingBuffer = VK_NULL_HANDLE;
    }

    // --- Step 8: create image view ---
    VkImageViewCreateInfo vkImageViewCreateInfo;
	memset((void*)&vkImageViewCreateInfo, 0, sizeof(VkImageViewCreateInfo));

    vkImageViewCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    vkImageViewCreateInfo.image = vkImage_texture;
    vkImageViewCreateInfo.viewType = VK_IMAGE_VIEW_TYPE_CUBE;
    vkImageViewCreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
    vkImageViewCreateInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    vkImageViewCreateInfo.subresourceRange.baseMipLevel = 0;
    vkImageViewCreateInfo.subresourceRange.levelCount = 1;
    vkImageViewCreateInfo.subresourceRange.baseArrayLayer = 0;
    vkImageViewCreateInfo.subresourceRange.layerCount = 6;

    vkResult = vkCreateImageView(vkDevice, &vkImageViewCreateInfo, NULL, &vkImageView_texture);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkCreateImageView() failed: %d\n", vkResult);
        fflush(gpFILE);
        
    }

    // --- Step 9: create sampler ---
    VkSamplerCreateInfo vkSamplerCreateInfo;
	memset((void*)&vkSamplerCreateInfo, 0, sizeof(VkSamplerCreateInfo));

    vkSamplerCreateInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    vkSamplerCreateInfo.magFilter = VK_FILTER_LINEAR;
    vkSamplerCreateInfo.minFilter = VK_FILTER_LINEAR;
    vkSamplerCreateInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
    vkSamplerCreateInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    vkSamplerCreateInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    vkSamplerCreateInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    vkSamplerCreateInfo.anisotropyEnable = VK_FALSE;
    vkSamplerCreateInfo.maxAnisotropy = 16.0f;
    vkSamplerCreateInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
    vkSamplerCreateInfo.unnormalizedCoordinates = VK_FALSE;
    vkSamplerCreateInfo.compareEnable = VK_FALSE;
    vkSamplerCreateInfo.compareOp = VK_COMPARE_OP_ALWAYS;
    vkSamplerCreateInfo.minLod = 0.0f;
    vkSamplerCreateInfo.maxLod = 0.0f;
    vkSamplerCreateInfo.mipLodBias = 0.0f;

    vkResult = vkCreateSampler(vkDevice, &vkSamplerCreateInfo, NULL, &vkSampler_texture);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createTexture() -> vkCreateSampler() failed: %d\n", vkResult);
        fflush(gpFILE);
    }

    // Success
    return vkResult;
}


VkResult createUniformBuffer(void){
	// Function Declaration;
	VkResult updateUniformBuffer(void);

	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	// Code
	VkBufferCreateInfo vkBufferCreateInfo;
	memset((void*)&vkBufferCreateInfo, 0, sizeof(VkBufferCreateInfo));

	vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
	vkBufferCreateInfo.pNext = NULL;
	vkBufferCreateInfo.flags = 0; // valid flags are used in scattered buffers
	vkBufferCreateInfo.size  = sizeof(struct MyUniformData);
	vkBufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;

	memset((void*)&uniformData, 0, sizeof(UniformData));

	vkResult = vkCreateBuffer(vkDevice, &vkBufferCreateInfo, NULL, &uniformData.vkBuffer);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createUniformBuffer() -> vkCreateBuffer() is failed %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createUniformBuffer() -> vkCreateBuffer() Succeeded\n");
	}

	//
	VkMemoryRequirements vkMemoryRequirements;
	memset((void*) &vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));

	vkGetBufferMemoryRequirements(vkDevice, uniformData.vkBuffer, &vkMemoryRequirements);

	//
	VkMemoryAllocateInfo vkMemoryAllocateInfo;
	memset((void*)&vkMemoryAllocateInfo, 0, sizeof(VkMemoryAllocateInfo));

	vkMemoryAllocateInfo.sType 				= VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	vkMemoryAllocateInfo.pNext 				= NULL;
	vkMemoryAllocateInfo.allocationSize 	= vkMemoryRequirements.size;
	vkMemoryAllocateInfo.memoryTypeIndex 	= 0; // initialize value before entering into loop

	for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++){
		if((vkMemoryRequirements.memoryTypeBits & 1) == 1){
			if ((vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) == (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) 
			{
				vkMemoryAllocateInfo.memoryTypeIndex = i;
				break;
			}
		}
		vkMemoryRequirements.memoryTypeBits >>= 1;
	}

	vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &uniformData.vkDeviceMemory);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createUniformBuffer() -> vkAllocateMemory() is failed %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createUniformBuffer() -> vkAllocateMemory() Succeeded\n");
	}

	vkResult = vkBindBufferMemory(vkDevice, 
								uniformData.vkBuffer, 		// konala bind karaych
								uniformData.vkDeviceMemory, // kon bind karaych
								0
							);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createUniformBuffer() -> vkBindBufferMemory() is failed %d\n", vkResult);									
	}
	else{
		fprintf(gpFILE, "createUniformBuffer() -> vkBindBufferMemory() Succeeded\n");
	}

	// call updateUniformBuffer
	vkResult = updateUniformBuffer();
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createUniformBuffer() -> updateUniformBuffer() is failed %d\n", vkResult);									
	}
	else{
		fprintf(gpFILE, "createUniformBuffer() -> updateUniformBuffer() Succeeded\n");
	}

	return vkResult;
}

VkResult updateUniformBuffer(void)
{
    VkResult vkResult = VK_SUCCESS;

    MyUniformData myUniformData{};
    myUniformData.modelMatrix = glm::mat4(1.0f);

    // View from camera orientation (skybox stays centered)
    glm::mat4 view = glm::mat4_cast(glm::conjugate(gCamQ));
    view[3] = glm::vec4(0, 0, 0, 1);
    myUniformData.viewMatrix = view;

    // Projection (flip Y for Vulkan)
    glm::mat4 P = glm::perspective(glm::radians(45.0f),
                                   (float)winWidth / (float)winHeight,
                                   0.1f, 100.0f);
    P[1][1] *= -1.0f;
    myUniformData.projectionMatrix = P;

	// --- Overlay fade for the current pan (works for all 12) ---
	float fade = ComputeOverlayFadeForPan((int)gPansDone);

	// Negative => circular mask in the shader.
	// Size = |w| * min(screenW, screenH). Keep your fraction constant.
	float sizeSigned = gOverlaySizeFrac;   // NEW: runtime‑adjustable

	myUniformData.overlayParams = glm::vec4(
		fade,                 // x: fade (0..1)
		float(winWidth),      // y: screen width  (pixels)
		float(winHeight),     // z: screen height (pixels)
		sizeSigned            // w: signed size fraction (negative -> circular mask)
	);

    void* data = nullptr;
    vkResult = vkMapMemory(vkDevice, uniformData.vkDeviceMemory, 0, sizeof(MyUniformData), 0, &data);
    if (vkResult == VK_SUCCESS)
    {
        memcpy(data, &myUniformData, sizeof(MyUniformData));
        vkUnmapMemory(vkDevice, uniformData.vkDeviceMemory);
    }
    else
    {
        fprintf(gpFILE, "updateUniformBuffer() -> vkMapMemory() failed %d\n", vkResult);
    }
    return vkResult;
}

VkResult createShaders(void){
	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	// Code
	// For vertex shader
	const char* szFileName = "shader.vert.spv";
	FILE* fp = NULL;
	size_t size;

	fp = fopen(szFileName, "rb"); // rb -> 
	if(fp == NULL){
		fprintf(gpFILE, "createShaders() -> shader.vert.spv is failed %d\n", vkResult);
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;								
	}
	else{
		fprintf(gpFILE, "createShaders() -> shader.vert.spv Succeeded\n");
	}

	fseek(fp, 0L, SEEK_END);
	size = ftell(fp);
	if(size == 1){
		fprintf(gpFILE, "createShaders() -> size failed %d\n", vkResult);
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}
	
	fseek(fp, 0L, SEEK_SET);

	char* shaderData = (char*)malloc(sizeof(char)*size);
	size_t retVal = fread(shaderData, size, 1, fp);
	if(retVal != 1){
		fprintf(gpFILE, "createShaders() -> to read shader.vert.spv is failed %d\n", vkResult);
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createShaders() -> read shader.vert.spv Succeeded\n");
	}

	fclose(fp);

	VkShaderModuleCreateInfo vkShaderModuleCreateInfo;
	memset((void*)&vkShaderModuleCreateInfo, 0, sizeof(VkShaderModuleCreateInfo));

	vkShaderModuleCreateInfo.sType 		= VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
	vkShaderModuleCreateInfo.pNext 		= NULL;
	vkShaderModuleCreateInfo.flags 		= 0; // must be zero
	vkShaderModuleCreateInfo.codeSize 	= size;
	vkShaderModuleCreateInfo.pCode 		= (uint32_t*)shaderData;

	vkResult = vkCreateShaderModule(vkDevice, &vkShaderModuleCreateInfo, NULL, &vkShaderModule_vertex_shader);
	if (vkResult != VK_SUCCESS) 
	{
		fprintf(gpFILE, "createShaders() -> vkCreateShaderModule(vertex) failed %d\n", vkResult);
		return vkResult;
	}

	if(shaderData){
		free(shaderData);
		shaderData = NULL;
	}

	fprintf(gpFILE, "createShaders() -> vertex shader module created\n");

	// For Fragment shader
	szFileName = "shader.frag.spv";
	fp = NULL;
	size = 0;

	fp = fopen(szFileName, "rb"); // rb -> 
	if(fp == NULL){
		fprintf(gpFILE, "createShaders() -> shader.frag.spv is failed %d\n", vkResult);
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;								
	}
	else{
		fprintf(gpFILE, "createShaders() -> shader.frag.spv Succeeded\n");
	}

	fseek(fp, 0L, SEEK_END);
	size = ftell(fp);
	if(size == 1){
		fprintf(gpFILE, "createShaders() -> size(frag shader) failed %d\n", vkResult);
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}
	
	fseek(fp, 0L, SEEK_SET);

	shaderData = (char*)malloc(sizeof(char)*size);
	retVal = fread(shaderData, size, 1, fp);
	if(retVal != 1){
		fprintf(gpFILE, "createShaders() -> to read shader.frag.spv is failed %d\n", vkResult);
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;
	}
	else{
		fprintf(gpFILE, "createShaders() -> read shader.frag.spv Succeeded\n");
	}

	fclose(fp);

	memset((void*)&vkShaderModuleCreateInfo, 0, sizeof(VkShaderModuleCreateInfo));

	vkShaderModuleCreateInfo.sType 		= VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
	vkShaderModuleCreateInfo.pNext 		= NULL;
	vkShaderModuleCreateInfo.flags 		= 0; // must be zero
	vkShaderModuleCreateInfo.codeSize 	= size;
	vkShaderModuleCreateInfo.pCode 		= (uint32_t*)shaderData;

	vkResult = vkCreateShaderModule(vkDevice, &vkShaderModuleCreateInfo, NULL, &vkShaderModule_fragment_shader);
	if(fp == NULL){
		fprintf(gpFILE, "createShaders() -> vkCreateShaderModule() is failed for vkShaderModule_fragment_shader %d\n", vkResult);
		vkResult = VK_ERROR_INITIALIZATION_FAILED;
		return vkResult;								
	}
	else{
		fprintf(gpFILE, "createShaders() -> vkCreateShaderModule() for vkShaderModule_fragment_shader Succeeded\n");
	}

	if(shaderData){
		free(shaderData);
		shaderData = NULL;
	}

	fprintf(gpFILE, "createShaders() -> fragment shader module created\n");

	return vkResult;
}

VkResult createDescriptorSetLayout(){
    VkResult vkResult = VK_SUCCESS;

    VkDescriptorSetLayoutBinding b[3] = {};
    // UBO (binding 0) – VS + FS (FS needs overlay parameters)
    b[0].descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    b[0].binding         = 0;
    b[0].descriptorCount = 1;
    b[0].stageFlags      = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;

    // Cubemap (binding 1)
    b[1].descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    b[1].binding         = 1;
    b[1].descriptorCount = 1;
    b[1].stageFlags      = VK_SHADER_STAGE_FRAGMENT_BIT;

    // Overlay 2D (binding 2)
    b[2].descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    b[2].binding         = 2;
    b[2].descriptorCount = 1;
    b[2].stageFlags      = VK_SHADER_STAGE_FRAGMENT_BIT;

    VkDescriptorSetLayoutCreateInfo ci{ VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO };
    ci.bindingCount = (uint32_t)_ARRAYSIZE(b);
    ci.pBindings    = b;

    vkResult = vkCreateDescriptorSetLayout(vkDevice, &ci, nullptr, &vkDescriptorSetLayout);
    if (vkResult != VK_SUCCESS)
        fprintf(gpFILE, "createDescriptorSetLayout() -> vkCreateDescriptorSetLayout() failed %d\n", vkResult);
    else
        fprintf(gpFILE, "createDescriptorSetLayout() -> vkCreateDescriptorSetLayout() Succeeded\n");

    return vkResult;
}

VkResult createPipelineLayout(void){
    VkResult vkResult = VK_SUCCESS;

    VkPipelineLayoutCreateInfo vkPipelineLayoutCreateInfo;
    memset((void*)&vkPipelineLayoutCreateInfo, 0, sizeof(VkPipelineLayoutCreateInfo));

    vkPipelineLayoutCreateInfo.sType                   = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    vkPipelineLayoutCreateInfo.pNext                   = NULL;
    vkPipelineLayoutCreateInfo.flags                   = 0; // reserved, hence must be 0
    vkPipelineLayoutCreateInfo.setLayoutCount          = 1; //
    vkPipelineLayoutCreateInfo.pSetLayouts             = &vkDescriptorSetLayout;
    vkPipelineLayoutCreateInfo.pushConstantRangeCount  = 0;
    vkPipelineLayoutCreateInfo.pPushConstantRanges     = NULL;

    vkResult = vkCreatePipelineLayout(vkDevice, &vkPipelineLayoutCreateInfo, NULL, &vkPipelineLayout);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createPipelineLayout() -> vkCreatePipelineLayout() is failed %d\n", vkResult);
    }
    else{
        fprintf(gpFILE, "createPipelineLayout() -> vkCreatePipelineLayout() Succeeded\n");
    }

    return vkResult;
}

VkResult createDescriptorPool(void) {
    VkResult vkResult = VK_SUCCESS;

    // One UBO + two sampled images (cubemap + overlay)
    VkDescriptorPoolSize poolSizes[2];
    memset(poolSizes, 0, sizeof(poolSizes));

    poolSizes[0].type            = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    poolSizes[0].descriptorCount = 1;

    poolSizes[1].type            = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    poolSizes[1].descriptorCount = 2; // <-- was 1, must be 2

    VkDescriptorPoolCreateInfo ci{};
    ci.sType         = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    ci.poolSizeCount = (uint32_t)(sizeof(poolSizes) / sizeof(poolSizes[0]));
    ci.pPoolSizes    = poolSizes;
    ci.maxSets       = 2;

    vkResult = vkCreateDescriptorPool(vkDevice, &ci, nullptr, &vkDescriptorPool);
    if (vkResult != VK_SUCCESS) {
        fprintf(gpFILE, "createDescriptorPool() -> vkCreateDescriptorPool() failed %d\n", vkResult);
    } else {
        fprintf(gpFILE, "createDescriptorPool() -> vkCreateDescriptorPool() Succeeded\n");
    }
    return vkResult;
}

VkResult createDescriptorSet(void){
    VkResult vkResult = VK_SUCCESS;

    VkDescriptorSetAllocateInfo ai{ VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO };
    ai.descriptorPool     = vkDescriptorPool;
    ai.descriptorSetCount = 1;
    ai.pSetLayouts        = &vkDescriptorSetLayout;
    vkResult = vkAllocateDescriptorSets(vkDevice, &ai, &vkDescriptorSet);
    if (vkResult != VK_SUCCESS) {
        fprintf(gpFILE, "createDescriptorSet() -> vkAllocateDescriptorSets() failed %d\n", vkResult);
        return vkResult;
    }

    // UBO
    VkDescriptorBufferInfo ubo{};
    ubo.buffer = uniformData.vkBuffer;
    ubo.offset = 0;
    ubo.range  = sizeof(MyUniformData);

    // Cubemap
    VkDescriptorImageInfo sky{};
    sky.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    sky.imageView   = vkImageView_texture;   // your cubemap view
    sky.sampler     = vkSampler_texture;

    // Overlay 2D (slot 0 of the 12-image gallery)
    VkDescriptorImageInfo overlay{};
    overlay.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    overlay.imageView   = gOverlayViews[0];     // CHANGED: first overlay in gallery
    overlay.sampler     = gOverlaySamplers[0];  // CHANGED: first overlay in gallery

    VkWriteDescriptorSet writes[3]{};

    // binding 0 : UBO
    writes[0].sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    writes[0].dstSet          = vkDescriptorSet;
    writes[0].dstBinding      = 0;
    writes[0].descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    writes[0].descriptorCount = 1;
    writes[0].pBufferInfo     = &ubo;

    // binding 1 : cubemap
    writes[1].sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    writes[1].dstSet          = vkDescriptorSet;
    writes[1].dstBinding      = 1;
    writes[1].descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    writes[1].descriptorCount = 1;
    writes[1].pImageInfo      = &sky;

    // binding 2 : overlay 2D
    writes[2].sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    writes[2].dstSet          = vkDescriptorSet;
    writes[2].dstBinding      = 2;
    writes[2].descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    writes[2].descriptorCount = 1;
    writes[2].pImageInfo      = &overlay;

    vkUpdateDescriptorSets(vkDevice, (uint32_t)_ARRAYSIZE(writes), writes, 0, nullptr);
    fprintf(gpFILE, "vkUpdateDescriptorSets completed successfully\n");

    // Seed the 'currently bound' overlay index
    gOverlayBound = 0;

    return vkResult;
}

VkResult createRenderpass(void){
	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	// Code 
	// step 1-> declare and initialize VkAttachmentDescription structure
	VkAttachmentDescription vkAttachmentDescription_array[2];
	memset((void*)vkAttachmentDescription_array, 0, sizeof(VkAttachmentDescription) * _ARRAYSIZE(vkAttachmentDescription_array));

	vkAttachmentDescription_array[0].flags 			= 0;
	vkAttachmentDescription_array[0].format 		= vkFormat_color;
	vkAttachmentDescription_array[0].samples 		= VK_SAMPLE_COUNT_1_BIT;
	vkAttachmentDescription_array[0].loadOp 		= VK_ATTACHMENT_LOAD_OP_CLEAR;
	vkAttachmentDescription_array[0].storeOp 		= VK_ATTACHMENT_STORE_OP_STORE;
	vkAttachmentDescription_array[0].stencilLoadOp 	= VK_ATTACHMENT_LOAD_OP_DONT_CARE;
	vkAttachmentDescription_array[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
	vkAttachmentDescription_array[0].initialLayout 	= VK_IMAGE_LAYOUT_UNDEFINED;
	vkAttachmentDescription_array[0].finalLayout 	= VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

	// For depth
	vkAttachmentDescription_array[1].flags 			= 0;
	vkAttachmentDescription_array[1].format 		= vkFormat_depth;
	vkAttachmentDescription_array[1].samples 		= VK_SAMPLE_COUNT_1_BIT;
	vkAttachmentDescription_array[1].loadOp 		= VK_ATTACHMENT_LOAD_OP_CLEAR;
	vkAttachmentDescription_array[1].storeOp 		= VK_ATTACHMENT_STORE_OP_STORE;
	vkAttachmentDescription_array[1].stencilLoadOp 	= VK_ATTACHMENT_LOAD_OP_DONT_CARE;
	vkAttachmentDescription_array[1].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
	vkAttachmentDescription_array[1].initialLayout 	= VK_IMAGE_LAYOUT_UNDEFINED;
	vkAttachmentDescription_array[1].finalLayout 	= VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

	// STEP 2-> declare and initialize vkAttachmentReference structure
	VkAttachmentReference vkAttachmentReference_color;
	memset((void*)&vkAttachmentReference_color, 0, sizeof(VkAttachmentReference));

	vkAttachmentReference_color.attachment 	= 0; // this is index number of above structure array
	vkAttachmentReference_color.layout 		= VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

	// For depth
	// STEP 2-> declare and initialize vkAttachmentReference structure
	VkAttachmentReference vkAttachmentReference_depth;
	memset((void*)&vkAttachmentReference_depth, 0, sizeof(VkAttachmentReference));

	vkAttachmentReference_depth.attachment 	= 1; // this is index number of above structure array
	vkAttachmentReference_depth.layout 		= VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;


	// STEP 3 -> declare and initialize
	VkSubpassDescription vkSubpassDescription;
	memset((void*)&vkSubpassDescription, 0, sizeof(VkSubpassDescription));

	vkSubpassDescription.flags 						= 0;
	vkSubpassDescription.pipelineBindPoint 			= VK_PIPELINE_BIND_POINT_GRAPHICS;
	vkSubpassDescription.inputAttachmentCount 		= 0;
	vkSubpassDescription.pInputAttachments 			= NULL;
	vkSubpassDescription.colorAttachmentCount 		= 1;//_ARRAYSIZE(vkAttachmentDescription_array) this count should be count of vkAttachmentReference used for color
	vkSubpassDescription.pColorAttachments 			= &vkAttachmentReference_color;
	vkSubpassDescription.pResolveAttachments 		= NULL;
	vkSubpassDescription.pDepthStencilAttachment 	= &vkAttachmentReference_depth;
	vkSubpassDescription.preserveAttachmentCount 	= 0;
	vkSubpassDescription.pPreserveAttachments 		= NULL;

	// declare and initialize VkRenderPassCreateInfo structure
	VkRenderPassCreateInfo vkRenderPassCreateInfo;
	memset((void*)&vkRenderPassCreateInfo, 0, sizeof(VkRenderPassCreateInfo));

	vkRenderPassCreateInfo.sType 			= VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
	vkRenderPassCreateInfo.pNext 			= NULL;
	vkRenderPassCreateInfo.flags 			= 0;
	vkRenderPassCreateInfo.attachmentCount 	= _ARRAYSIZE(vkAttachmentDescription_array);
	vkRenderPassCreateInfo.pAttachments 	= vkAttachmentDescription_array;
	vkRenderPassCreateInfo.subpassCount 	= 1;
	vkRenderPassCreateInfo.pSubpasses 		= &vkSubpassDescription;
	vkRenderPassCreateInfo.dependencyCount 	= 0;
	vkRenderPassCreateInfo.pDependencies 	= NULL;

	// create render pass
	vkResult = vkCreateRenderPass(vkDevice, &vkRenderPassCreateInfo, NULL, &vkRenderPass);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createRenderpass() -> vkCreateRenderPass() is failed %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createRenderpass() -> vkCreateRenderPass() Succeeded\n");
	}

	return vkResult;

}

VkResult createPipeline(){
    // Variable declarations
    VkResult vkResult = VK_SUCCESS;

    // code
    // Vertex input state
    VkVertexInputBindingDescription  vkVertexInputBindingDescription_array[2]; // this array size increase in future when we create multi color triangle or for texture
    memset(vkVertexInputBindingDescription_array, 0, sizeof(VkVertexInputBindingDescription) * _ARRAYSIZE(vkVertexInputBindingDescription_array));

    // Position
    vkVertexInputBindingDescription_array[0].binding   = 0; // binding point location  // consider it as GL_ARRAY_BUFFER
    vkVertexInputBindingDescription_array[0].stride    = sizeof(float) * 3; // 3-3 ne dhanga tak
    vkVertexInputBindingDescription_array[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX; // is it index or indices

    // Texcoord
    vkVertexInputBindingDescription_array[1].binding   = 1; // binding point location  // consider it as GL_ARRAY_BUFFER
    vkVertexInputBindingDescription_array[1].stride    = sizeof(float) * 2; // 3-3 ne dhanga tak
    vkVertexInputBindingDescription_array[1].inputRate = VK_VERTEX_INPUT_RATE_VERTEX; // is it index or indices


    VkVertexInputAttributeDescription vkVertexInputAttributeDescription_array[2]; // this array size increase in future when we create multi color triangle or for texture
    memset((void*)vkVertexInputAttributeDescription_array, 0, sizeof(VkVertexInputAttributeDescription) * _ARRAYSIZE(vkVertexInputAttributeDescription_array));

    // Position
    vkVertexInputAttributeDescription_array[0].binding  = 0; // if separate structure created for every atrribute
    vkVertexInputAttributeDescription_array[0].location = 0; // layout(location = 0) in vec4 vPosition; 
    vkVertexInputAttributeDescription_array[0].format   = VK_FORMAT_R32G32B32_SFLOAT;
    vkVertexInputAttributeDescription_array[0].offset   = 0; // importent for interleaved

    // Texcoord
    vkVertexInputAttributeDescription_array[1].binding  = 1; // if separate structure created for every atrribute
    vkVertexInputAttributeDescription_array[1].location = 1; // layout(location = 0) in vec4 vPosition; 
    vkVertexInputAttributeDescription_array[1].format   = VK_FORMAT_R32G32_SFLOAT;
    vkVertexInputAttributeDescription_array[1].offset   = 0; // importent for interleaved

    VkPipelineVertexInputStateCreateInfo vkPipelineVertexInputStateCreateInfo; // its proper PSO
    memset((void*)&vkPipelineVertexInputStateCreateInfo, 0, sizeof(VkPipelineVertexInputStateCreateInfo));

    vkPipelineVertexInputStateCreateInfo.sType                               = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vkPipelineVertexInputStateCreateInfo.pNext                               = NULL;
    vkPipelineVertexInputStateCreateInfo.flags                               = 0;
    vkPipelineVertexInputStateCreateInfo.vertexBindingDescriptionCount       = _ARRAYSIZE(vkVertexInputBindingDescription_array); // never use hardcoded value
    vkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions          = vkVertexInputBindingDescription_array;
    vkPipelineVertexInputStateCreateInfo.vertexAttributeDescriptionCount     = _ARRAYSIZE(vkVertexInputAttributeDescription_array);
    vkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions        = vkVertexInputAttributeDescription_array;

    // Input assembly state
    VkPipelineInputAssemblyStateCreateInfo vkPipelineInputAssemblyStateCreateInfo;
    memset((void*)&vkPipelineInputAssemblyStateCreateInfo, 0, sizeof(VkPipelineInputAssemblyStateCreateInfo));

    vkPipelineInputAssemblyStateCreateInfo.sType   = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    vkPipelineInputAssemblyStateCreateInfo.pNext   = NULL;
    vkPipelineInputAssemblyStateCreateInfo.flags   = 0;
    vkPipelineInputAssemblyStateCreateInfo.topology= VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    // vkPipelineInputAssemblyStateCreateInfo.primitiveRestartEnable = 0; intentinally not initialized this member

    // Rasterizer state
    VkPipelineRasterizationStateCreateInfo vkPipelineRasterizationStateCreateInfo;
    memset((void*)&vkPipelineRasterizationStateCreateInfo, 0, sizeof(VkPipelineRasterizationStateCreateInfo));

    vkPipelineRasterizationStateCreateInfo.sType      = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    vkPipelineRasterizationStateCreateInfo.pNext      = NULL;
    vkPipelineRasterizationStateCreateInfo.flags      = 0;
    vkPipelineRasterizationStateCreateInfo.polygonMode= VK_POLYGON_MODE_FILL;
    vkPipelineRasterizationStateCreateInfo.cullMode   = VK_CULL_MODE_NONE;
    vkPipelineRasterizationStateCreateInfo.frontFace  = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    vkPipelineRasterizationStateCreateInfo.lineWidth  = 1.0f;
    

    // Color blend state
    VkPipelineColorBlendAttachmentState vkPipelineColorBlendAttachmentState_array[1]; // 
    memset((void*)vkPipelineColorBlendAttachmentState_array, 0, sizeof(VkPipelineColorBlendAttachmentState));

    vkPipelineColorBlendAttachmentState_array[0].colorWriteMask = 0xf;
    vkPipelineColorBlendAttachmentState_array[0].blendEnable    = VK_FALSE;
    
    VkPipelineColorBlendStateCreateInfo VkPipelineColorBlendStateCreateInfo;
    memset((void*)&VkPipelineColorBlendStateCreateInfo, 0, sizeof(VkPipelineColorBlendStateCreateInfo));

    VkPipelineColorBlendStateCreateInfo.sType           = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    VkPipelineColorBlendStateCreateInfo.pNext           = NULL;
    VkPipelineColorBlendStateCreateInfo.flags           = 0;
    VkPipelineColorBlendStateCreateInfo.attachmentCount = _ARRAYSIZE(vkPipelineColorBlendAttachmentState_array);
    VkPipelineColorBlendStateCreateInfo.pAttachments    = vkPipelineColorBlendAttachmentState_array;

    // Viewport state
    VkPipelineViewportStateCreateInfo vkPipelineViewportStateCreateInfo;
    memset((void*)&vkPipelineViewportStateCreateInfo, 0, sizeof(VkPipelineViewportStateCreateInfo));

    vkPipelineViewportStateCreateInfo.sType         = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    vkPipelineViewportStateCreateInfo.pNext         = NULL;
    vkPipelineViewportStateCreateInfo.flags         = 0;
    vkPipelineViewportStateCreateInfo.viewportCount = 1;

    memset((void*)&vkViewport, 0, sizeof(VkViewport));

    vkViewport.x       = 0;
    vkViewport.y       = 0;
    vkViewport.width   = (float)vkExtent2D_swapchain.width;
    vkViewport.height  = (float)vkExtent2D_swapchain.height;
    vkViewport.minDepth= 0.0f;
    vkViewport.maxDepth= 1.0f;

    vkPipelineViewportStateCreateInfo.pViewports    = &vkViewport;
    vkPipelineViewportStateCreateInfo.scissorCount  = 1;

    memset((void*)&vkRect2D_scissor, 0, sizeof(VkRect2D));

    vkRect2D_scissor.offset.x     = 0;
    vkRect2D_scissor.offset.y     = 0;
    vkRect2D_scissor.extent.width = vkExtent2D_swapchain.width;
    vkRect2D_scissor.extent.height= vkExtent2D_swapchain.height;

    vkPipelineViewportStateCreateInfo.pScissors = &vkRect2D_scissor;

    // Depth stencil step
    // as we dont have depth yet we can omit it
    VkPipelineDepthStencilStateCreateInfo vkPipelineDepthStencilStateCreateInfo;
    memset((void*)&vkPipelineDepthStencilStateCreateInfo, 0, sizeof(VkPipelineDepthStencilStateCreateInfo));

    vkPipelineDepthStencilStateCreateInfo.sType                 = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    vkPipelineDepthStencilStateCreateInfo.depthTestEnable       = VK_TRUE;
    vkPipelineDepthStencilStateCreateInfo.depthWriteEnable      = VK_TRUE;
    vkPipelineDepthStencilStateCreateInfo.depthCompareOp        = VK_COMPARE_OP_LESS_OR_EQUAL;
    vkPipelineDepthStencilStateCreateInfo.depthBoundsTestEnable = VK_FALSE;
    vkPipelineDepthStencilStateCreateInfo.back.failOp           = VK_STENCIL_OP_KEEP;
    vkPipelineDepthStencilStateCreateInfo.back.passOp           = VK_STENCIL_OP_KEEP;
    vkPipelineDepthStencilStateCreateInfo.back.compareOp        = VK_COMPARE_OP_ALWAYS;
    vkPipelineDepthStencilStateCreateInfo.front                 = vkPipelineDepthStencilStateCreateInfo.back;
    vkPipelineDepthStencilStateCreateInfo.stencilTestEnable     = VK_FALSE;
    

    // dynamic state -> dynamic state are those state of PSO(Pipeline state object) which you can change dynamically without statically specifying them 
                 // we dont have any dynamic state

    // Multi sample state
    VkPipelineMultisampleStateCreateInfo vkPipelineMultisampleStateCreateInfo;
    memset((void*)&vkPipelineMultisampleStateCreateInfo, 0, sizeof(VkPipelineMultisampleStateCreateInfo));

    vkPipelineMultisampleStateCreateInfo.sType                   = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    vkPipelineMultisampleStateCreateInfo.pNext                   = NULL;
    vkPipelineMultisampleStateCreateInfo.flags                   = 0;
    vkPipelineMultisampleStateCreateInfo.rasterizationSamples    = VK_SAMPLE_COUNT_1_BIT;

    // shader state
    VkPipelineShaderStageCreateInfo vkPipelineShaderStageCreateInfo_array[2];
    memset((void*)vkPipelineShaderStageCreateInfo_array, 0, sizeof(VkPipelineShaderStageCreateInfo) * _ARRAYSIZE(vkPipelineShaderStageCreateInfo_array));
    
    // Vertex shader
    vkPipelineShaderStageCreateInfo_array[0].sType                   = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vkPipelineShaderStageCreateInfo_array[0].pNext                   = NULL;
    vkPipelineShaderStageCreateInfo_array[0].flags                   = 0;
    vkPipelineShaderStageCreateInfo_array[0].stage                   = VK_SHADER_STAGE_VERTEX_BIT;
    vkPipelineShaderStageCreateInfo_array[0].module                  = vkShaderModule_vertex_shader;
    vkPipelineShaderStageCreateInfo_array[0].pName                   = "main";
    vkPipelineShaderStageCreateInfo_array[0].pSpecializationInfo     = NULL;

    // Fragment shader
    vkPipelineShaderStageCreateInfo_array[1].sType                   = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vkPipelineShaderStageCreateInfo_array[1].pNext                   = NULL;
    vkPipelineShaderStageCreateInfo_array[1].flags                   = 0;
    vkPipelineShaderStageCreateInfo_array[1].stage                   = VK_SHADER_STAGE_FRAGMENT_BIT;
    vkPipelineShaderStageCreateInfo_array[1].module                  = vkShaderModule_fragment_shader;
    vkPipelineShaderStageCreateInfo_array[1].pName                   = "main";
    vkPipelineShaderStageCreateInfo_array[1].pSpecializationInfo     = NULL;

    // Tessellation state
    // we dont have 

    //
    VkPipelineCacheCreateInfo vkPipelineCacheCreateInfo;
    memset((void*)&vkPipelineCacheCreateInfo, 0, sizeof(VkPipelineCacheCreateInfo));

    vkPipelineCacheCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
    vkPipelineCacheCreateInfo.pNext = NULL;
    vkPipelineCacheCreateInfo.flags = 0;
    
    VkPipelineCache vkPipelineCache = VK_NULL_HANDLE;

    vkResult = vkCreatePipelineCache(vkDevice, &vkPipelineCacheCreateInfo, NULL, &vkPipelineCache);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createPipeline() -> vkCreatePipelineCache() is failed %d\n", vkResult);
    }
    else{
        fprintf(gpFILE, "createPipeline() -> vkCreatePipelineCache() Succeeded\n");
    }

    // Create the actual graphic pipeline
    VkGraphicsPipelineCreateInfo vkGraphicsPipelineCreateInfo;
    memset((void*)&vkGraphicsPipelineCreateInfo, 0, sizeof(VkGraphicsPipelineCreateInfo));

    vkGraphicsPipelineCreateInfo.sType                  = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    vkGraphicsPipelineCreateInfo.pNext                  = NULL;
    vkGraphicsPipelineCreateInfo.flags                  = 0;
    vkGraphicsPipelineCreateInfo.pVertexInputState      = &vkPipelineVertexInputStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pInputAssemblyState    = &vkPipelineInputAssemblyStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pRasterizationState    = &vkPipelineRasterizationStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pColorBlendState       = &VkPipelineColorBlendStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pViewportState         = &vkPipelineViewportStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pDepthStencilState     = &vkPipelineDepthStencilStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pDynamicState          = NULL;
    vkGraphicsPipelineCreateInfo.pMultisampleState      = &vkPipelineMultisampleStateCreateInfo;
    vkGraphicsPipelineCreateInfo.stageCount             = _ARRAYSIZE(vkPipelineShaderStageCreateInfo_array);
    vkGraphicsPipelineCreateInfo.pStages                = vkPipelineShaderStageCreateInfo_array;
    vkGraphicsPipelineCreateInfo.pTessellationState     = NULL;
    vkGraphicsPipelineCreateInfo.layout                 = vkPipelineLayout;
    vkGraphicsPipelineCreateInfo.renderPass             = vkRenderPass;
    vkGraphicsPipelineCreateInfo.subpass                = 0;
    vkGraphicsPipelineCreateInfo.basePipelineHandle     = VK_NULL_HANDLE;
    vkGraphicsPipelineCreateInfo.basePipelineIndex      = 0;

    // now create the pipeline
    vkResult = vkCreateGraphicsPipelines(vkDevice, vkPipelineCache, 1, &vkGraphicsPipelineCreateInfo, NULL, &vkPipeline);
    if (vkResult != VK_SUCCESS)
    {
        fprintf(gpFILE, "createPipeline() -> vkCreateGraphicsPipelines() is failed %d\n", vkResult);
        vkDestroyPipelineCache(vkDevice, vkPipelineCache, NULL);
        vkPipelineCache = VK_NULL_HANDLE;
        
    }
    else{
        fprintf(gpFILE, "createPipeline() -> vkCreateGraphicsPipelines() Succeeded\n");
    }

    // we have done wth
    vkDestroyPipelineCache(vkDevice, vkPipelineCache, NULL);
    vkPipelineCache = VK_NULL_HANDLE;
    
    return vkResult;
}

VkResult createFrameBuffers(void){
	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	vkFramebuffer_array = (VkFramebuffer*)malloc(sizeof(VkFramebuffer)* swapchainImageCount);

	for(uint32_t i = 0; i<swapchainImageCount; i++){
		VkImageView vkImageView_attachment_array[2]; // color and Depth previously it only for color
		memset((void*)vkImageView_attachment_array, 0, sizeof(VkImageView) * _ARRAYSIZE(vkImageView_attachment_array));

		// step 2
		VkFramebufferCreateInfo vkFramebufferCreateInfo;
		memset((void*)&vkFramebufferCreateInfo, 0, sizeof(VkFramebufferCreateInfo));

		vkFramebufferCreateInfo.sType 			= VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
		vkFramebufferCreateInfo.pNext 			= NULL;
		vkFramebufferCreateInfo.flags 			= 0;
		vkFramebufferCreateInfo.renderPass 		= vkRenderPass;
		vkFramebufferCreateInfo.attachmentCount = _ARRAYSIZE(vkImageView_attachment_array);
		vkFramebufferCreateInfo.pAttachments 	= vkImageView_attachment_array;
		vkFramebufferCreateInfo.width 			= vkExtent2D_swapchain.width;
		vkFramebufferCreateInfo.height 			= vkExtent2D_swapchain.height;
		vkFramebufferCreateInfo.layers 			= 1;
		
		
		vkImageView_attachment_array[0] = swapchainImageView_array[i];
		vkImageView_attachment_array[1] = vkImageView_depth;
		vkResult = vkCreateFramebuffer(vkDevice, &vkFramebufferCreateInfo, NULL, &vkFramebuffer_array[i]);
		if (vkResult != VK_SUCCESS)
		{
			fprintf(gpFILE, "createFrameBuffers() -> vkCreateFramebuffer() is failed %d\n", vkResult);
			
		}
		else{
			fprintf(gpFILE, "createFrameBuffers() -> vkCreateFramebuffer() Succeeded\n");
		}
	}

	return vkResult;
}

VkResult createSemaphore(void){
	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	// Code
	VkSemaphoreCreateInfo vkSemaphoreCreateInfo;
	memset((void*)&vkSemaphoreCreateInfo, 0, sizeof(VkSemaphoreCreateInfo));

	vkSemaphoreCreateInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
	vkSemaphoreCreateInfo.pNext = NULL;
	vkSemaphoreCreateInfo.flags = 0; // Must be zero

	vkResult = vkCreateSemaphore(vkDevice, &vkSemaphoreCreateInfo, NULL, &vkSemaphore_backBuffer);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createSemaphore() -> First call tovkCreateSemaphore() is failed %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createSemaphore() -> First call to vkCreateSemaphore() Succeeded\n");
	}

	vkResult = vkCreateSemaphore(vkDevice, &vkSemaphoreCreateInfo, NULL, &vkSemaphore_renderComplete);
	if (vkResult != VK_SUCCESS)
	{
		fprintf(gpFILE, "createSemaphore() -> Second call to vkCreateSemaphore() is failed %d\n", vkResult);
			
	}
	else{
		fprintf(gpFILE, "createSemaphore() -> Second call to vkCreateSemaphore() Succeeded\n");
	}

	return vkResult;
}

VkResult createFences(void){
	// Variable declarations
	VkResult vkResult = VK_SUCCESS;

	// Code

	VkFenceCreateInfo vkFenceCreateInfo;
	memset((void*)&vkFenceCreateInfo, 0, sizeof(VkFenceCreateInfo));

	vkFenceCreateInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
	vkFenceCreateInfo.pNext = NULL;
	vkFenceCreateInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

	vkFence_array = (VkFence*)malloc(sizeof(VkFence)*swapchainImageCount);

	for(uint32_t i=0; i<swapchainImageCount; i++){
		vkResult = vkCreateFence(vkDevice, &vkFenceCreateInfo, NULL, &vkFence_array[i]);
		if (vkResult != VK_SUCCESS)
		{
			fprintf(gpFILE, "createFences() -> vkCreateFence() is failed %d\n", vkResult);
			
		}
		else{
			fprintf(gpFILE, "createFences() -> vkCreateFence() Succeeded\n");
		}

	}

	//

	return vkResult;
}

VkResult buildCommandBuffers(void)
{
    // Variable declarations
    VkResult vkResult = VK_SUCCESS;

    // Loop per swapchain image
    for(uint32_t i = 0; i < swapchainImageCount; i++){
        // reset command buffers
        vkResult = vkResetCommandBuffer(vkCommandBuffer_array[i], 0); // second parameter (Don't release the resource created by command pool by these command buffers)
        if (vkResult != VK_SUCCESS)
        {
            fprintf(gpFILE, "buildCommandBuffers() -> vkCommandBuffer_array(%d) is failed %d\n",i, vkResult);
            
        }
        else{
            fprintf(gpFILE, "buildCommandBuffers() -> vkCommandBuffer_array(%d) Succeeded\n", i);
        }

        VkCommandBufferBeginInfo vkCommandBufferBeginInfo;
        memset((void*)&vkCommandBufferBeginInfo, 0, sizeof(VkCommandBufferBeginInfo));

        vkCommandBufferBeginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        vkCommandBufferBeginInfo.pNext = NULL;
        vkCommandBufferBeginInfo.flags = 0;

        vkResult = vkBeginCommandBuffer(vkCommandBuffer_array[i], &vkCommandBufferBeginInfo);
        if (vkResult != VK_SUCCESS)
        {
            fprintf(gpFILE, "buildCommandBuffers() -> vkBeginCommandBuffer(%d) is failed %d\n",i, vkResult);
            
        }
        else{
            fprintf(gpFILE, "buildCommandBuffers() -> vkBeginCommandBuffer(%d) Succeeded\n", i);
        }

        // Set clear values
        VkClearValue vkClearValue_array[2];
        memset((void*)vkClearValue_array, 0, sizeof(VkClearValue)* _ARRAYSIZE(vkClearValue_array));

        vkClearValue_array[0].color        = vkClearColorValue;
        vkClearValue_array[1].depthStencil = vkClearDepthStencilValue;

        // Renderpass begin info
        VkRenderPassBeginInfo vkRenderPassBeginInfo;
        memset((void*)&vkRenderPassBeginInfo, 0, sizeof(VkRenderPassBeginInfo));

        vkRenderPassBeginInfo.sType                     = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        vkRenderPassBeginInfo.pNext                     = 0;
        vkRenderPassBeginInfo.renderPass                = vkRenderPass;
        vkRenderPassBeginInfo.renderArea.offset.x       = 0;
        vkRenderPassBeginInfo.renderArea.offset.y       = 0;
        vkRenderPassBeginInfo.renderArea.extent.width   = vkExtent2D_swapchain.width;
        vkRenderPassBeginInfo.renderArea.extent.height  = vkExtent2D_swapchain.height;
        vkRenderPassBeginInfo.clearValueCount           = _ARRAYSIZE(vkClearValue_array);
        vkRenderPassBeginInfo.pClearValues              = vkClearValue_array;
        vkRenderPassBeginInfo.framebuffer               = vkFramebuffer_array[i];

        // begin the render pass
        vkCmdBeginRenderPass(vkCommandBuffer_array[i], &vkRenderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

        // Bind with the pipeline
        vkCmdBindPipeline(vkCommandBuffer_array[i], VK_PIPELINE_BIND_POINT_GRAPHICS, vkPipeline);

        // bind our descriptor set to the pipeline
        vkCmdBindDescriptorSets(vkCommandBuffer_array[i], VK_PIPELINE_BIND_POINT_GRAPHICS, vkPipelineLayout, 0, 1, &vkDescriptorSet, 0, NULL);

        // Bind with the vertex buffer
        // bind vertex positoin buffer
        VkDeviceSize vkDeviceSize_offset_position[1];
        memset((void*)vkDeviceSize_offset_position, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_position));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 0, 1, &vertexData_position.vkBuffer, vkDeviceSize_offset_position);

        // bind vertex texcoord buffer (binding = 1)
        VkDeviceSize vkDeviceSize_offset_texcoord[1] = {0};
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 1, 1, &vertexData_texcoord.vkBuffer, vkDeviceSize_offset_texcoord);
        
        // Here we should call vulkan drawing functions
        vkCmdDraw(vkCommandBuffer_array[i], 36, 1, 0, 0);

        // End render pass
        vkCmdEndRenderPass(vkCommandBuffer_array[i]);

        // End command buffer recording
        vkResult = vkEndCommandBuffer(vkCommandBuffer_array[i]);

    }

    return vkResult;
}

VKAPI_ATTR VkBool32 VKAPI_CALL debugReportCallback
(
	VkDebugReportFlagsEXT vkDebugReportFlagsEXT, 
	VkDebugReportObjectTypeEXT vkDebugReportObjectTypeEXT, 
	uint64_t object, 
	size_t location, 
	int32_t messageCode,
	const char* pLayerPrefix,
	const char* pMessage,
	void* pUserDate
){
	// Code
	fprintf(gpFILE, "SHS_Validation-> debugReportCallback(): %s (%d) = %s\n", pLayerPrefix, messageCode, pMessage);

	return VK_FALSE;
}

