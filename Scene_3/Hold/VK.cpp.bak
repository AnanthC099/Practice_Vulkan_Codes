//Header file
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
//header file for texture
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

//This inclusion of <vulkan/vulkan.h> is needed in all platforms
//to distinguish the platfrom, below macro is needed
#define VK_USE_PLATFORM_WIN32_KHR
#include <vulkan/vulkan.h>

//glm related macros and header files
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE   //clipping values between 0 and 1 for depth
#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"

#include "VK.h"
#include "Sphere.h"

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "gdi32.lib")
// Vulkan related library
#pragma comment(lib, "vulkan-1.lib")
#pragma comment(lib, "Sphere.lib")

//Macros
/* History of Graphics adapter
Aspect ratio od 4:3 is supported by all monitors
Monochrome
CGA -> Color Graphics Adapter
EGA -> Extended Graphics Adapter
VGA -> Video Graphics Adapter
SVGA -> Super Video Graphics Adapter (4:3 Aspect ratio)
*/
#define WIN_WIDTH  800
#define WIN_HEIGHT 600

//Callback function declaration
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

void Update(void);

const char* gpszAppName = "ARTR";

//Global variables
HWND ghwnd = NULL;
HDC ghdc = NULL;
HGLRC ghrc = NULL;

DWORD dwStyle;
WINDOWPLACEMENT wpPrev;

int gbActiveWindow = 0;
int gbFullscreen = 0;
int gbWindowMinimized = FALSE;

int giHeight = 0;
int giWidth = 0;

FILE *gpFile = NULL;

//Vulkan related global variables
//Instance Extension releated variables
uint32_t enabledInstanceExtensionCount = 0;
//VK_KHR_SURFACE_EXTENSION_NAME
//VK_KHR_WIN32_SURFACE_EXTENSION_NAME
//VK_EXT_DEBUG_REPORT_EXTENSION_NAME
const char* enabledInstanceExtensionNames_array[3];

//Vulkan Instance
VkInstance vkInstance = VK_NULL_HANDLE;

//Vulkan Presentaiton Surface
VkSurfaceKHR vkSurfaceKHR = VK_NULL_HANDLE;

//vulkan Physical Device related
VkPhysicalDevice vkPhysicalDevice_selected = VK_NULL_HANDLE;
uint32_t graphicsQueueFamilyIndex_selected = UINT32_MAX;
VkPhysicalDeviceMemoryProperties vkPhysicalDeviceMemoryProperties;

//vulkan Printing VkInfo related 
VkPhysicalDevice *vkPhysicalDevice_array = NULL; 
uint32_t physicalDeviceCount = 0;

//Device Extension releated variables
uint32_t enabledDeviceExtensionCount = 0;
//VK_KHR_SWAPCHAIN_EXTENSION_NAME
const char* enabledDeviceExtensionNames_array[1];

//Vulkan Device
VkDevice vkDevice = VK_NULL_HANDLE;

//DeviceQueue
VkQueue vkQueue = VK_NULL_HANDLE;

//Color format and color Space
VkFormat vkFormat_color = VK_FORMAT_UNDEFINED;
VkColorSpaceKHR vkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;

//Presentation Mode
VkPresentModeKHR vkPresentModeKHR = VK_PRESENT_MODE_FIFO_KHR;

//Swapchain related
int winWidth = WIN_WIDTH;
int winHeight = WIN_HEIGHT;
VkSwapchainKHR vkSwapchainKHR = VK_NULL_HANDLE;
VkExtent2D vkExtent2D_swapchain;

//for color images
//SwapchainImage and swapchainImagesViews releated
uint32_t swapchainImageCount = UINT32_MAX;
VkImage* swapchainImage_array = NULL;
VkImageView* swapchainImageView_array = NULL;

//for depth image
VkFormat vkFormat_depth = VK_FORMAT_UNDEFINED;
VkImage vkImage_depth = VK_NULL_HANDLE;
VkDeviceMemory vkDeviceMemory_depth = VK_NULL_HANDLE;
VkImageView vkImageView_depth = VK_NULL_HANDLE;


//commandPool
VkCommandPool vkCommandPool = VK_NULL_HANDLE;

//Command Buffer
VkCommandBuffer* vkCommandBuffer_array = NULL;

//RenderPass
VkRenderPass vkRenderPass = VK_NULL_HANDLE;

//FrameBuffers
VkFramebuffer *vkFrameBuffer_array = NULL;

//semaphore
VkSemaphore vkSemaphore_backBuffer = VK_NULL_HANDLE;
VkSemaphore vkSemaphore_renderComplete = VK_NULL_HANDLE;

//Fence
VkFence *vkFence_array = NULL;

//BuildCommandBuffers
//clear color values
VkClearColorValue vkClearColorValue;  // 3 arrays
VkClearDepthStencilValue vkClearDepthStencilValue;  //for depth

//Render
VkBool32 bInitialized = FALSE;
uint32_t currentImageIndex = UINT32_MAX;

//Validation
BOOL bValidation = TRUE;
uint32_t enabledValidationLayerCount = 0;
const char* enabledValidationLayerNames_array[1]; //for VK_LAYER_KHRONOS_validation
VkDebugReportCallbackEXT vkDebugReportCallbackEXT = VK_NULL_HANDLE;
PFN_vkDestroyDebugReportCallbackEXT vkDestroyDebugReportCallbackEXT_fnptr = NULL;

//VertexBuffer related variables

unsigned int numVertices;
unsigned int numElements;

float sphere_vertices[1146];
float sphere_normals[1146];
float sphere_textures[764];
unsigned short sphere_elements[2280];

typedef struct 
{
    VkBuffer vkBuffer;
    VkDeviceMemory vkDeviceMemory;
}VertexData;

//position
// VertexData vertexData_position_pyramid;
// VertexData vertexData_texcoord_pyramid;
// VertexData vertexData_position_cube;
// VertexData vertexData_texcoord_cube;
VertexData vertexData_position_sun;
VertexData vertexData_texcoord_sun;
VertexData vertexData_normal_sun;
VertexData vertexData_index_sun;

VertexData vertexData_position_mercury;
VertexData vertexData_texcoord_mercury;
VertexData vertexData_normal_mercury;
VertexData vertexData_index_mercury;

VertexData vertexData_position_venus;
VertexData vertexData_texcoord_venus;
VertexData vertexData_normal_venus;
VertexData vertexData_index_venus;

VertexData vertexData_position_earth;
VertexData vertexData_texcoord_earth;
VertexData vertexData_index_earth;
VertexData vertexData_normal_earth;

VertexData vertexData_position_mars;
VertexData vertexData_texcoord_mars;
VertexData vertexData_index_mars;
VertexData vertexData_normal_mars;

VertexData vertexData_position_jupitor;
VertexData vertexData_texcoord_jupitor;
VertexData vertexData_index_jupitor;
VertexData vertexData_normal_jupitor;

VertexData vertexData_position_saturn;
VertexData vertexData_texcoord_saturn;
VertexData vertexData_index_saturn;
VertexData vertexData_normal_saturn;

VertexData vertexData_position_uranus;
VertexData vertexData_texcoord_uranus;
VertexData vertexData_index_uranus;
VertexData vertexData_normal_uranus;

VertexData vertexData_position_neptune;
VertexData vertexData_texcoord_neptune;
VertexData vertexData_index_neptune;
VertexData vertexData_normal_neptune;



//Uniform related declarations
struct MyUniformData
{
    glm::mat4 modelMatrix;
    glm::mat4 viewMatrix;
    glm::mat4 projectionMatrix;
};

struct UniformData
{
    VkBuffer vkBuffer;
    VkDeviceMemory vkDeviceMemory;
};

// UniformData uniformData_pyramid;
// UniformData uniformData_cube;
UniformData uniformData_sun;
UniformData uniformData_mercury;
UniformData uniformData_venus;
UniformData uniformData_earth;
UniformData uniformData_mars;
UniformData uniformData_jupitor;
UniformData uniformData_saturn;
UniformData uniformData_uranus;
UniformData uniformData_neptune;

//Shader related variables
VkShaderModule vkShaderModule_vertex_shader = VK_NULL_HANDLE;
VkShaderModule vkShaderModule_fragment_shader = VK_NULL_HANDLE;

//DescriptorSetLayout realted variables
VkDescriptorSetLayout vkDescriptorSetLayout = VK_NULL_HANDLE;

//PipelineLayout realted variables
VkPipelineLayout vkPipelineLayout = VK_NULL_HANDLE;

//Descriptor pool
VkDescriptorPool vkDescriptorPool = VK_NULL_HANDLE;

//Descriptor set
// VkDescriptorSet vkDescriptorSet_pyramid = VK_NULL_HANDLE;
// VkDescriptorSet vkDescriptorSet_cube = VK_NULL_HANDLE;
VkDescriptorSet vkDescriptorSet_sun = VK_NULL_HANDLE;
VkDescriptorSet vkDescriptorSet_mercury = VK_NULL_HANDLE;
VkDescriptorSet vkDescriptorSet_venus = VK_NULL_HANDLE;
VkDescriptorSet vkDescriptorSet_earth = VK_NULL_HANDLE;
VkDescriptorSet vkDescriptorSet_mars = VK_NULL_HANDLE;
VkDescriptorSet vkDescriptorSet_jupitor = VK_NULL_HANDLE;
VkDescriptorSet vkDescriptorSet_saturn = VK_NULL_HANDLE;
VkDescriptorSet vkDescriptorSet_uranus = VK_NULL_HANDLE;
VkDescriptorSet vkDescriptorSet_neptune = VK_NULL_HANDLE;

//Pipeline
VkViewport vkViewport;
VkRect2D vkRect2D_scissor; //mostly viewport and scissor dimensions are same
VkPipeline vkPipeline = VK_NULL_HANDLE;

float angle = 0.0f;
float angle_mercury = 0.0f;
float angle_venus = 0.0f;
float angle_earth = 0.0f;
float angle_mars = 0.0f;
float angle_jupitor = 0.0f;
float angle_saturn = -180.0f;
float angle_uranus = -270.0f;
float angle_neptune = -200.0f;

//Texture related global data
VkImage vkImage_texture = VK_NULL_HANDLE;
VkDeviceMemory vkDeviceMemory_texture = VK_NULL_HANDLE;

VkImageView vkImageView_texture = VK_NULL_HANDLE;
// VkImageView vkImageView_texture_stone = VK_NULL_HANDLE;
// VkImageView vkImageView_texture_kundali = VK_NULL_HANDLE;
VkImageView vkImageView_texture_sun = VK_NULL_HANDLE;
VkImageView vkImageView_texture_mercury = VK_NULL_HANDLE;
VkImageView vkImageView_texture_venus = VK_NULL_HANDLE;
VkImageView vkImageView_texture_earth = VK_NULL_HANDLE;
VkImageView vkImageView_texture_mars = VK_NULL_HANDLE;
VkImageView vkImageView_texture_jupitor = VK_NULL_HANDLE;
VkImageView vkImageView_texture_saturn = VK_NULL_HANDLE;
VkImageView vkImageView_texture_uranus = VK_NULL_HANDLE;
VkImageView vkImageView_texture_neptune = VK_NULL_HANDLE;

VkSampler vkSampler_texture = VK_NULL_HANDLE;
// VkSampler vkSampler_texture_stone = VK_NULL_HANDLE;
// VkSampler vkSampler_texture_kundali = VK_NULL_HANDLE;
VkSampler vkSampler_texture_sun = VK_NULL_HANDLE;
VkSampler vkSampler_texture_mercury = VK_NULL_HANDLE;
VkSampler vkSampler_texture_venus = VK_NULL_HANDLE;
VkSampler vkSampler_texture_earth = VK_NULL_HANDLE;
VkSampler vkSampler_texture_mars = VK_NULL_HANDLE;
VkSampler vkSampler_texture_jupitor = VK_NULL_HANDLE;
VkSampler vkSampler_texture_saturn = VK_NULL_HANDLE;
VkSampler vkSampler_texture_uranus = VK_NULL_HANDLE;
VkSampler vkSampler_texture_neptune = VK_NULL_HANDLE;

//WinMain
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int iCmdShow)
{
	//function declarations
	VkResult Initialize(void);
	void Uninitialize(void);
	VkResult Display(void);

	//local variable declarations
	WNDCLASSEX wndclass;
	HWND hwnd;
	MSG msg;
	TCHAR szAppName[255];
	int bDone = 0;
    VkResult vkResult = VK_SUCCESS;


	//code
    gpFile = fopen("SSA_Log.txt", "w+");
	if (gpFile == NULL)
	{
		MessageBox(NULL, TEXT("Cannot create/open SSA_Log.txt file"), TEXT("FILE IO ERROR"), MB_ICONERROR);
		exit(0);
	}
	else
	{
		fprintf(gpFile, "WinMain() --> Program started successfully\n");
        fflush(gpFile);
	}

    wsprintf(szAppName, TEXT("%s"), gpszAppName);

	wndclass.cbSize = sizeof(WNDCLASSEX);
	wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = 0;
	wndclass.lpfnWndProc = WndProc;
	wndclass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
	wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(MYICON));
	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndclass.hInstance = hInstance;
	wndclass.lpszMenuName = NULL;
	wndclass.lpszClassName = szAppName;
	wndclass.hIconSm = LoadIcon(hInstance, MAKEINTRESOURCE(MYICON));

	RegisterClassEx(&wndclass);

	hwnd = CreateWindowEx(WS_EX_APPWINDOW,
		szAppName,
		TEXT("SSA_VULKAN"),
		WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE,
		GetSystemMetrics(SM_CXSCREEN)/2 - WIN_WIDTH/2,
		GetSystemMetrics(SM_CYSCREEN)/2 - WIN_HEIGHT/2,
		WIN_WIDTH,
		WIN_HEIGHT,
		NULL, //Parent Window Handle
		NULL, //Menu Handle
		hInstance,
		NULL);

	ghwnd = hwnd;

	vkResult = Initialize();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "WinMain() --> Initialize() is failed\n");
        fflush(gpFile);
        DestroyWindow(hwnd);
        hwnd = NULL;
    }
    else
    {
        fprintf(gpFile, "WinMain() --> Initialize() is succedded\n");
        fflush(gpFile);
    }
    //Error checking of Initialize

	ShowWindow(hwnd, iCmdShow);
    Update();
	SetForegroundWindow(hwnd);
	SetFocus(hwnd);

	//Game loop
	while (bDone == 0)
	{
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			if (msg.message == WM_QUIT)
				bDone = 1;
			else
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		}
		else
		{
			if (gbActiveWindow == 1)
			{
				//Here you should call update() for OpenGL rendering
                Update();
				//Here you should call display() for OpenGL rendering
                if(gbWindowMinimized == FALSE)
                {
                    vkResult = Display();
                    if((vkResult != VK_FALSE) && (vkResult != VK_SUCCESS) && (vkResult != VK_ERROR_OUT_OF_DATE_KHR) && (vkResult != VK_SUBOPTIMAL_KHR))
                    {
                        fprintf(gpFile, "WinMain() --> call to Display() failed\n");
                        fflush(gpFile);
                        bDone = TRUE;
                    }
                }
			}
		}
	}

	Uninitialize();

	return((int)(msg.wParam));
}


LRESULT CALLBACK WndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	//Local function declaration
	void ToggleFullscreen(void);
	VkResult Resize(int, int);
	void Uninitialize(void);

	int height = 0;
    int width = 0;
    int length = sizeof(WINDOWPLACEMENT);
    
    switch (iMsg)
	{

    case WM_CREATE:
        memset(&wpPrev, 0, length);
        break;

	case WM_SETFOCUS:
		gbActiveWindow = 1;
		break;

	case WM_KILLFOCUS:
		gbActiveWindow = 0;
		break;

	case WM_ERASEBKGND:
		return(0);

	case WM_SIZE:
        if(wParam == SIZE_MINIMIZED)
        {
            gbWindowMinimized = TRUE;
        }
        else
        {
            gbWindowMinimized = FALSE;
            Resize(LOWORD(lParam), HIWORD(lParam));
        }
        
		break;

	case WM_KEYDOWN:
		switch (wParam)
		{
		case VK_ESCAPE:
			DestroyWindow(hwnd);
			break;

		case 0x46:
		case 0x66:
			ToggleFullscreen();
			break;

		default:
			break;
		}
		break;

	case WM_CLOSE:
		DestroyWindow(hwnd);
		break;

	case WM_DESTROY:
		Uninitialize();
		PostQuitMessage(0);
		break;

	default: break;
	}

	return(DefWindowProc(hwnd, iMsg, wParam, lParam));
}


void ToggleFullscreen(void)
{
	//Local variable declaration
	MONITORINFO mi = { sizeof(MONITORINFO) };

	//Code
	if (gbFullscreen == 0) //If current window is normal(Not Fullscreen)
	{
		dwStyle = GetWindowLong(ghwnd, GWL_STYLE); //dwStyle will get WS_OVERLAPPEDWINDOW information
		if (dwStyle & WS_OVERLAPPEDWINDOW)
		{
			if (GetWindowPlacement(ghwnd, &wpPrev) && GetMonitorInfo(MonitorFromWindow(ghwnd, MONITORINFOF_PRIMARY), &mi))
			{
				SetWindowLong(ghwnd, GWL_STYLE, (dwStyle & ~WS_OVERLAPPEDWINDOW)); //Removing flags of WS_OVERLAPPEDWINDOW
				SetWindowPos(ghwnd,
					HWND_TOP, //HWND_TOP -> for making it on top order
					mi.rcMonitor.left, // left coordinate of monitor
					mi.rcMonitor.top, // top coordinate of monitor
					mi.rcMonitor.right - mi.rcMonitor.left, // width coordinate of monitor
					mi.rcMonitor.bottom - mi.rcMonitor.top, // height coordinate of monitor
					SWP_NOZORDER | //Window flag --> don't change the Z order
					SWP_FRAMECHANGED); //Window flag --> WM_NCCALCSIZE (Window message calculate Non Client area)
			}
		}
		ShowCursor(FALSE);  //disappear the cursor in full screen or Game mode
		gbFullscreen = 1;
	}
	else
	{
		SetWindowLong(ghwnd, GWL_STYLE, (dwStyle | WS_OVERLAPPEDWINDOW));//Restoring flags of WS_OVERLAPPEDWINDOW
		SetWindowPlacement(ghwnd, &wpPrev); //setting placement of window
		SetWindowPos(ghwnd,
			HWND_TOP,
			0,  //already set in wpPrev
			0,  //already set in wpPrev
			0,  //already set in wpPrev
			0,  //already set in wpPrev
			SWP_NOMOVE | // do not change x, y cordinates for starting position
			SWP_NOSIZE | // do not change height and width cordinates
			SWP_NOOWNERZORDER | //do not change the position even if its parent window is changed
			SWP_NOZORDER | //Window flag --> don't change the Z order
			SWP_FRAMECHANGED); //Window flag --> WM_NCCALCSIZE (Window message calculate Non Client area)
		ShowCursor(TRUE); //Appear the cursor in full screen or Game mode
		gbFullscreen = 0;
	}
}


VkResult Initialize(void)
{
    //function declaration
    VkResult createVulkanInstance(void);
    VkResult getSupportedSurface(void);
    VkResult getPhysicalDevice(void);
    VkResult printVkInfo(void);
    VkResult createVulkanDevice(void);
    void getDeviceQueue(void);
    VkResult createSwapchain(VkBool32);
    VkResult createImagesAndImageViews(void);
    VkResult createCommandPool(void);
    VkResult createCommandBuffers(void);
    VkResult createVertexBuffer(void);
	VkResult createIndexBuffer(void);
    VkResult createTexture(const char*);
    VkResult createUniformBuffer(void);
    VkResult createShaders(void);
    VkResult createDescriptorSetLayout(void);
    VkResult createPipelineLayout(void);
    VkResult createDescriptorPool(void);
    VkResult createDescriptorSet(void);
    VkResult createRenderPass(void);
    VkResult createPipeline(void);
    VkResult createFrameBuffers(void);
    VkResult createSemaphores(void);
    VkResult createFences(void);
    VkResult buildCommandBuffers(void);
        
    //variable delaration
    VkResult vkResult = VK_SUCCESS;

    //code
    vkResult = createVulkanInstance();
    /*Main points:
        vkEnumerateInstanceExtensionProperties()
        
        struct --> vkApplicationInfo
        struct --> vkInstanceCreateInfo
        vkCreateInstance()
    */
    
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createVulkanInstance() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createVulkanInstance() is succedded\n");
        fflush(gpFile);
    }

    //CreateVulkan Presntation Surface
    vkResult = getSupportedSurface();
    /* Main points:
        struct --> vkWin32SurfaceCreateInfoKHR
        vkCreateWin32SurfaceKHR()
    */
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> getSupportedSurface() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "Initialize() --> getSupportedSurface() is succedded\n");
        fflush(gpFile);
    }

    //Get required Physical Device and its Queue family index
    vkResult = getPhysicalDevice();
    /* Main points:
        vkEnumeratePhysicalDevices()
        vkGetPhysicalDeviceQueueFamilyProperties()
        vkGetPhysicalDeviceSurfaceSupportKHR()
        vkGetPhysicalDeviceMemoryProperties()
        vkGetPhysicalDeviceFeatures()
    */
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> getPhysicalDevice() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "Initialize() --> getPhysicalDevice() is succedded\n");
        fflush(gpFile);
    }
    
    //Printing Vulkan Infomration
    vkResult = printVkInfo();
    /* Main points:
        vkGetPhysicalDeviceProperties()
    */
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> printVkInfo() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "Initialize() --> printVkInfo() is succedded\n");
        fflush(gpFile);
    }
    
    vkResult = createVulkanDevice();
    /* Main Points:
        vkEnumerateDeviceExtensionProperties()
        struct --> vkDeviceQueueCreateInfo
        struct --> vkDeviceCreateInfo
        vkCreateDevice()
        
    */
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createVulkanDevice() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createVulkanDevice() is succedded\n");
        fflush(gpFile);
    }
    
    //getDeviceQueue
    getDeviceQueue();
    /* Main Points
        vkGetDeviceQueue()
    */

        
    //Swapchain
    vkResult = createSwapchain(VK_FALSE);
    /*Main Points:
        vkGetPhysicalDeviceSurfaceFormatsKHR()
        vkGetPhysicalDeviceSurfaceCapabilitiesKHR()
        vkGetPhysicalDeviceSurfacePresentModesKHR()
        
    */
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createSwapchain() is failed %d\n", vkResult);
        fflush(gpFile);
        return VK_ERROR_INITIALIZATION_FAILED;
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createSwapchain() is succedded\n");
        fflush(gpFile);
    }
    
    //Create Vulkan Images and ImageViews
    vkResult = createImagesAndImageViews();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createImagesAndImageViews() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createImagesAndImageViews() is succedded\n");
        fflush(gpFile);
    }
    
    //Create Command Pool
    vkResult = createCommandPool();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createCommandPool() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createCommandPool() is succedded\n");
        fflush(gpFile);
    }
    
    //Command Buffers
    vkResult = createCommandBuffers();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createCommandBuffers() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createCommandBuffers() is succedded\n");
        fflush(gpFile);
    }
    
    getSphereVertexData(sphere_vertices, sphere_normals, sphere_textures, sphere_elements);
    numVertices = getNumberOfSphereVertices();
    numElements = getNumberOfSphereElements();
    
    //create VertexBUffer
    vkResult = createVertexBuffer();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createVertexBuffer() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createVertexBuffer() is succedded\n");
        fflush(gpFile);
    }
    
	//create Index Buffer
    vkResult = createIndexBuffer();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createIndexBuffer() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createIndexBuffer() is succedded\n");
        fflush(gpFile);
    }
	
    //create texture
    vkResult = createTexture("sun.png");
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createTexture() is failed for sun texture %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createTexture() is succedded for sun texture\n");
        fflush(gpFile);
    }
    
    vkResult = createTexture("mercury.png");
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createTexture() is failed for mercury texture %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createTexture() is succedded for mercury texture\n");
        fflush(gpFile);
    }
    
    vkResult = createTexture("venus.png");
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createTexture() is failed for venus texture %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createTexture() is succedded for venus texture\n");
        fflush(gpFile);
    }
    
    vkResult = createTexture("earth.png");
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createTexture() is failed for earth texture %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createTexture() is succedded for earth texture\n");
        fflush(gpFile);
    }
    
    vkResult = createTexture("mars.png");
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createTexture() is failed for mars texture %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createTexture() is succedded for mars texture\n");
        fflush(gpFile);
    }
    
    vkResult = createTexture("jupitor.png");
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createTexture() is failed for jupitor texture %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createTexture() is succedded for jupitor texture\n");
        fflush(gpFile);  
    }
    
    vkResult = createTexture("saturn.png");
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createTexture() is failed for saturn texture %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createTexture() is succedded for saturn texture\n");
        fflush(gpFile);
    }
    
    vkResult = createTexture("uranus.png");
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createTexture() is failed for uranus texture %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createTexture() is succedded for uranus texture\n");
        fflush(gpFile);
    }
    
    vkResult = createTexture("neptune.png");
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createTexture() is failed for neptune texture %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createTexture() is succedded for neptune texture\n");
        fflush(gpFile);
    }
    
    //create Uniform Buffer
    vkResult = createUniformBuffer();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createUniformBuffer() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createUniformBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    //Create RenderPass
    vkResult = createShaders();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createShaders() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createShaders() is succedded\n");
        fflush(gpFile);
    }
    
    
    
    //Create Dewscriptor Set Layout
    vkResult = createDescriptorSetLayout();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createDescriptorSetLayout() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createDescriptorSetLayout() is succedded\n");
        fflush(gpFile);
    }
    
    //Create Descriptor Set Layout
    vkResult = createPipelineLayout();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createPipelineLayout() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createPipelineLayout() is succedded\n");
        fflush(gpFile);
    }
    
    //create Descriptor pool
    vkResult = createDescriptorPool();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createDescriptorPool() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createDescriptorPool() is succedded\n");
        fflush(gpFile);
    }
    
    //create Descriptor set
    vkResult = createDescriptorSet();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createDescriptorSet() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createDescriptorPool() is succedded\n");
        fflush(gpFile);
    }
    
    //Create RenderPass
    vkResult = createRenderPass();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createRenderPass() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createRenderPass() is succedded\n");
        fflush(gpFile);
    }
    
    //Create Pipeline
    vkResult = createPipeline();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createPipeline() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createPipeline() is succedded\n");
        fflush(gpFile);
    }
    
    
    //CreateBuffer
    vkResult = createFrameBuffers();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createFrameBuffers() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createFrameBuffers() is succedded\n");
        fflush(gpFile);
    }
    
    //CreateSemaphores
    vkResult = createSemaphores();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createSemaphores() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createSemaphores() is succedded\n");
        fflush(gpFile);
    }
    
    //CreateFences
    vkResult = createFences();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> createFences() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> createFences() is succedded\n");
        fflush(gpFile);
    }
    
    //Initlaize vkClearColorValue
    memset((void*)&vkClearColorValue, 0, sizeof(VkClearColorValue));
    vkClearColorValue.float32[0] = 0.0f;// R
    vkClearColorValue.float32[1] = 0.0f;// G
    vkClearColorValue.float32[2] = 0.0f;// B
    vkClearColorValue.float32[3] = 1.0f;//Analogous to glClearColor()
    
    memset((void*)&vkClearDepthStencilValue, 0, sizeof(VkClearDepthStencilValue));
    //setDefaultClearDepth
    vkClearDepthStencilValue.depth = 1.0f; //flaot value
    //setDeafaultStencilValue
    vkClearDepthStencilValue.stencil = 0; //uint32_t value
    
    //BuildCommandBuffers
    vkResult = buildCommandBuffers();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Initialize() --> buildCommandBuffers() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "Initialize() --> buildCommandBuffers() is succedded\n");
        fflush(gpFile);
    }
    
    //Initialization is completed
    bInitialized = TRUE;
    fprintf(gpFile, "Initialize() --> Initialization is completed successfully\n");
    fflush(gpFile);
  
    return vkResult;
}


VkResult Resize(int width, int height)
{
    //Function declarations
    VkResult createSwapchain(VkBool32);
    VkResult createImagesAndImageViews(void);
    VkResult createCommandBuffers(void);
    VkResult createPipelineLayout(void);
    VkResult createPipeline(void);
    VkResult createRenderPass(void);
    VkResult createFrameBuffers(void);
    VkResult buildCommandBuffers(void);
    
    
    //variables
    VkResult vkResult = VK_SUCCESS;
	//code
	if (height == 0)
		height = 1;
    
    giHeight = height;
    giWidth = width;
    

    //check the bInitialized variable
    if(bInitialized == FALSE)
    {
        fprintf(gpFile, "Resize() --> Initialization yet not completed or failed\n");
        fflush(gpFile);
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        return vkResult;
    }
    
    //As recreation of swapchain is needed we are goring to repeat many steps of initialized again, hence set bINitialized to \False again
    bInitialized = FALSE;

    //Set gloabl winwidth and winheight variable
    winWidth = width;
    winHeight = height;
    
    //wait for device to complete inhand tasks
    vkDeviceWaitIdle(vkDevice);
    fprintf(gpFile, "Resize() --> vkDeviceWaitIdle() is done\n");
        fflush(gpFile);
    
    //check presence of swapchain
    if(vkSwapchainKHR == VK_NULL_HANDLE)
    {
        fprintf(gpFile, "Resize() --> swapchain is already NULL cannot proceed\n");
        fflush(gpFile);
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
    }
    
    //Destroy vkframebuffer
    for(uint32_t i = 0; i < swapchainImageCount ; i++)
    {
        vkDestroyFramebuffer(vkDevice, vkFrameBuffer_array[i], NULL);
    }
    if(vkFrameBuffer_array)
    {
        free(vkFrameBuffer_array);
        vkFrameBuffer_array = NULL;
        fprintf(gpFile, "Resize() --> vkFrameBuffer_array() is done\n");
        fflush(gpFile);
    }
    
    //Destroy Commandbuffer
    for(uint32_t i = 0; i < swapchainImageCount; i++)
    {
        vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_array[i]);
        fprintf(gpFile, "Resize() --> vkFreeCommandBuffers() is done\n");
        fflush(gpFile);
    }
    
    if(vkCommandBuffer_array)
    {
        free(vkCommandBuffer_array);
        vkCommandBuffer_array = NULL;
        fprintf(gpFile, "Resize() --> vkCommandBuffer_array is freed\n");
        fflush(gpFile);
    }
    
    
    //Destroy Pipeline
    if(vkPipeline)
    {
        vkDestroyPipeline(vkDevice, vkPipeline, NULL);
        vkPipeline = VK_NULL_HANDLE;
        fprintf(gpFile, "Resize() --> vkDestroyPipeline() is done\n");
        fflush(gpFile);
    }
    
    //Destroy vkPipelineLayout
    if(vkPipelineLayout)
    {
        vkDestroyPipelineLayout(vkDevice, vkPipelineLayout, NULL);
        vkPipelineLayout = VK_NULL_HANDLE;
        fprintf(gpFile, "Resize() --> vkPipelineLayout() is done\n");
        fflush(gpFile);
    }
    
    //Destroy Renderpass
    if(vkRenderPass)
    {
        vkDestroyRenderPass(vkDevice, vkRenderPass, NULL);
        vkRenderPass = VK_NULL_HANDLE;
    }
    
    //destroy depth image view
    if(vkImageView_depth)
    {
        vkDestroyImageView(vkDevice, vkImageView_depth, NULL);
        vkImageView_depth = VK_NULL_HANDLE;
    }
    
    //destroy device memory for depth image
    if(vkDeviceMemory_depth)
    {
        vkFreeMemory(vkDevice, vkDeviceMemory_depth, NULL);
        vkDeviceMemory_depth = VK_NULL_HANDLE;
    }
    
    if(vkImage_depth)
    {
        vkDestroyImage(vkDevice, vkImage_depth, NULL);
        vkImage_depth = VK_NULL_HANDLE;
    }
    //destory image views
    for(uint32_t i = 0; i < swapchainImageCount; i++)
    {
        vkDestroyImageView(vkDevice, swapchainImageView_array[i], NULL);
        fprintf(gpFile, "Resize() --> vkDestoryImageView() is done\n");
        fflush(gpFile);
    }
    
    if(swapchainImageView_array)
    {
        free(swapchainImageView_array);
        swapchainImageView_array = NULL;
        fprintf(gpFile, "Resize() --> swapchainImageView_array is freed\n");
        fflush(gpFile);
    }
    
    //free swapchainImages
    // for(uint32_t i = 0; i < swapchainImageCount; i++)
    // {
        // vkDestroyImage(vkDevice, swapchainImage_array[i], NULL);
        // fprintf(gpFile, "Resize() --> vkDestroyImage() is done\n");
    // }
    
    
    if(swapchainImage_array)
    {
        free(swapchainImage_array);
        swapchainImage_array = NULL;
        fprintf(gpFile, "Resize() --> swapchainImage_array is freed\n");
        fflush(gpFile);
    }
    
    //Destory Swapchain
    if(vkSwapchainKHR)
    {
        vkDestroySwapchainKHR(vkDevice, vkSwapchainKHR, NULL);
        vkSwapchainKHR = VK_NULL_HANDLE;
        fprintf(gpFile, "Resize() --> vkSwapchainCreateInfoKHR() is done\n");
        fflush(gpFile);
    }
    
    //RECREATE FOR RESIZE
    
    //Swapchain
    vkResult = createSwapchain(VK_FALSE);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Resize() --> createSwapchain() is failed %d\n", vkResult);
        fflush(gpFile);
        return VK_ERROR_INITIALIZATION_FAILED;
    }
    
    //Create Vulkan Images and ImageViews
    vkResult = createImagesAndImageViews();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Resize() --> createImagesAndImageViews() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    
    //Create RenderPass
    vkResult = createRenderPass();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Resize() --> createRenderPass() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    
    //Create Descriptor Set Layout
    vkResult = createPipelineLayout();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Resize() --> createPipelineLayout() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    
    //Create Pipeline
    vkResult = createPipeline();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Resize() --> createPipeline() is failed %d\n", vkResult);
        fflush(gpFile);
    }
      
    //CreateBuffer
    vkResult = createFrameBuffers();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Resize() --> createFrameBuffers() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    
    //Command Buffers
    vkResult = createCommandBuffers();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Resize() --> createCommandBuffers() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    
    //BuildCommandBuffers
    vkResult = buildCommandBuffers();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Resize() --> buildCommandBuffers() is failed %d\n", vkResult);
        fflush(gpFile);
    }

    bInitialized = TRUE;

    return vkResult;
}


VkResult Display(void)
{
    //Function Declarations
    VkResult Resize(int, int);
    VkResult updateUniformBuffer(void);
    
    //variable declarations
    VkResult vkResult = VK_SUCCESS; 

    //code
    // if control comes here before initlaization is completed, return FALSE
    if(bInitialized == FALSE)
    {
        fprintf(gpFile, "Display() --> Initialization yet not completed\n");
        fflush(gpFile);
        return (VkResult)VK_FALSE;
    }
    
    //acquire index of next swapchin image
    //if timour occurs, then function returns VK_NOT_READY
    vkResult = vkAcquireNextImageKHR(vkDevice,
                                     vkSwapchainKHR,
                                     UINT64_MAX, //waiting time in nanaoseconds for swapchain to get the image
                                     vkSemaphore_backBuffer, //semaphore, waiting for another queue to relaease the image held by another queue demanded by swapchain, (InterQueue semaphore)
                                     VK_NULL_HANDLE, //Fence, when you want to halt host also, for device::: (Use Semaphore and fences exclusively, using both is not recommended(Redbook)
                                     &currentImageIndex);
    if(vkResult != VK_SUCCESS)
    {
        if((vkResult == VK_ERROR_OUT_OF_DATE_KHR) || (vkResult == VK_SUBOPTIMAL_KHR))
        {
            Resize(winWidth, winHeight);
        }
        else
        {
            fprintf(gpFile, "Display() --> vkAcquireNextImageKHR() is failed errorcode = %d\n", vkResult);
            fflush(gpFile);
            return vkResult;   
        }
    }
    
    //use fence to allow host to wait for completion of execution of previous commandbuffer
    vkResult = vkWaitForFences(vkDevice,
                               1, //waiting for how many fences
                               &vkFence_array[currentImageIndex], //Which fence
                               VK_TRUE, // wait till all fences get signalled(Blocking and unblocking function)
                               UINT64_MAX); //waiting time in nanaoseconds
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Display() --> vkWaitForFences() is failed errorcode = %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }

    //Now make Fences execution of next command buffer
    vkResult = vkResetFences(vkDevice,
                             1, //How many fences to reset
                             &vkFence_array[currentImageIndex]);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Display() --> vkResetFences() is failed errorcode = %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    
    //One of the mmeber of vkSubmitinfo structure requires array of pipeline stages, we have only one of the completion of color attachment output, still we need 1 member array
    const VkPipelineStageFlags waitDstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;

    //Declare memset and initialize VkSubmitInfo structure
    VkSubmitInfo vkSubmitInfo;
    memset((void*)&vkSubmitInfo, 0, sizeof(VkSubmitInfo));
    
    vkSubmitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    vkSubmitInfo.pNext = NULL;
    vkSubmitInfo.pWaitDstStageMask = &waitDstStageMask;
    vkSubmitInfo.waitSemaphoreCount = 1;
    vkSubmitInfo.pWaitSemaphores = &vkSemaphore_backBuffer;
    vkSubmitInfo.commandBufferCount = 1;
    vkSubmitInfo.pCommandBuffers = &vkCommandBuffer_array[currentImageIndex];
    vkSubmitInfo.signalSemaphoreCount = 1;
    vkSubmitInfo.pSignalSemaphores = &vkSemaphore_renderComplete;
    
    //Now submit our work to the Queue
    vkResult = vkQueueSubmit(vkQueue,
                             1,
                             &vkSubmitInfo,
                             vkFence_array[currentImageIndex]);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Display() --> vkQueueSubmit() is failed errorcode = %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    
    //We are going to present rendered image after declaring and initlaizing VkPresentInfoKHR structure
    VkPresentInfoKHR vkPresentInfoKHR;
    memset((void*)&vkPresentInfoKHR, 0, sizeof(VkPresentInfoKHR));
    
    vkPresentInfoKHR.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
    vkPresentInfoKHR.pNext = NULL;
    vkPresentInfoKHR.swapchainCount = 1;
    vkPresentInfoKHR.pSwapchains = &vkSwapchainKHR;
    vkPresentInfoKHR.pImageIndices = &currentImageIndex;
    vkPresentInfoKHR.waitSemaphoreCount = 1;
    vkPresentInfoKHR.pWaitSemaphores = &vkSemaphore_renderComplete;
    
    //Now present the Queue
    vkResult = vkQueuePresentKHR(vkQueue, &vkPresentInfoKHR);
    if(vkResult != VK_SUCCESS)
    {
        if((vkResult == VK_ERROR_OUT_OF_DATE_KHR) || (vkResult == VK_SUBOPTIMAL_KHR))
        {
            Resize(winWidth, winHeight);
        }
        else
        {
            fprintf(gpFile, "Display() --> vkQueuePresentKHR() is failed errorcode = %d\n", vkResult);
            fflush(gpFile);
            return vkResult;
        }
    }
    
    vkResult = updateUniformBuffer();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "Display() --> updateUniformBuffer() is failed errorcode = %d\n", vkResult);
        fflush(gpFile);
    }
        
    //validation
    vkDeviceWaitIdle(vkDevice);    
    
    return vkResult;
}
    

void Update(void)
{
    angle = angle + 0.0000011f;
    angle_mercury = angle_mercury + 0.01f;
    angle_venus = angle_venus + 0.009f;
    angle_earth = angle_earth + 0.002f;
    angle_mars = angle_mars + 0.0011f;
    angle_jupitor = angle_jupitor + 0.00013f;
    angle_saturn = angle_saturn + 0.00015f;
    angle_uranus = angle_uranus + 0.00017f;
    angle_neptune = angle_neptune + 0.00019f;
    
}


void Uninitialize(void)
{
	//code
	if (gbFullscreen == 1)
	{
		dwStyle = GetWindowLong(ghwnd, GWL_STYLE);
		SetWindowLong(ghwnd, GWL_STYLE, (dwStyle | WS_OVERLAPPEDWINDOW));//Restoring flags of WS_OVERLAPPEDWINDOW
		SetWindowPlacement(ghwnd, &wpPrev); //setting placement of window
		SetWindowPos(ghwnd,
			HWND_TOP,
			0,  //already set in wpPrev
			0,  //already set in wpPrev
			0,  //already set in wpPrev
			0,  //already set in wpPrev
			SWP_NOMOVE | // do not change x, y cordinates for starting position
			SWP_NOSIZE | // do not change height and width cordinates
			SWP_NOOWNERZORDER | //do not change the position even if its parent window is changed
			SWP_NOZORDER | //Window flag --> don't change the Z order
			SWP_FRAMECHANGED); //Window flag --> WM_NCCALCSIZE (Window message calculate Non Client area)
		ShowCursor(TRUE); //Appear the cursor in full screen or Game mode
	}

	/**************Shader removal code*******************/


	if (ghdc)
	{
		ReleaseDC(ghwnd, ghdc);
		ghdc = NULL;
	}

    //synchronisation function
    vkDeviceWaitIdle(vkDevice);
    fprintf(gpFile, "Uninitialize() --> vkDeviceWaitIdle() is done\n");
    fflush(gpFile);
    
    //DestroyFences
    for(uint32_t i = 0; i < swapchainImageCount; i++)
    {
        vkDestroyFence(vkDevice, vkFence_array[i], NULL);
    }
    
    if(vkFence_array)
    {
        free(vkFence_array);
        vkFence_array = NULL;
        fprintf(gpFile, "Uninitialize() --> vkDestroyFence() is done\n");
        fflush(gpFile);
    }
    
    //DestroySemaphore
    if(vkSemaphore_renderComplete)
    {
        vkDestroySemaphore(vkDevice, vkSemaphore_renderComplete, NULL);
        vkSemaphore_renderComplete = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroySemaphore() for vkSemaphore_renderComplete is done\n");
        fflush(gpFile);
    }
    
    if(vkSemaphore_backBuffer)
    {
        vkDestroySemaphore(vkDevice, vkSemaphore_backBuffer, NULL);
        vkSemaphore_backBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroySemaphore() for vkSemaphore_backBuffer is done\n");
        fflush(gpFile);
    }
    
    //vkframebuffer
    for(uint32_t i = 0; i < swapchainImageCount ; i++)
    {
        vkDestroyFramebuffer(vkDevice, vkFrameBuffer_array[i], NULL);
    }
    if(vkFrameBuffer_array)
    {
        free(vkFrameBuffer_array);
        vkFrameBuffer_array = NULL;
        fprintf(gpFile, "Uninitialize() --> vkFrameBuffer_array() is done\n");
        fflush(gpFile);
    }
    
    //Destroy Descriptor Pool
    //When Descriptor pool is destroyed, descriptor set created  by that pool get destroyed implicitly
    if(vkDescriptorPool)
    {
        vkDestroyDescriptorPool(vkDevice, vkDescriptorPool, NULL);        
        vkDescriptorPool = VK_NULL_HANDLE;
        // vkDescriptorSet_cube = VK_NULL_HANDLE;
        // vkDescriptorSet_pyramid = VK_NULL_HANDLE;
        vkDescriptorSet_sun = VK_NULL_HANDLE;
        vkDescriptorSet_mercury = VK_NULL_HANDLE;
        vkDescriptorSet_venus = VK_NULL_HANDLE;
        vkDescriptorSet_earth = VK_NULL_HANDLE;
        vkDescriptorSet_mars = VK_NULL_HANDLE;
        vkDescriptorSet_jupitor = VK_NULL_HANDLE;
        vkDescriptorSet_saturn = VK_NULL_HANDLE;
        vkDescriptorSet_uranus = VK_NULL_HANDLE;
        vkDescriptorSet_neptune = VK_NULL_HANDLE;
        
        fprintf(gpFile, "Uninitialize() --> vkDescriptorPool and DescriptorSet() is done\n");
        fflush(gpFile);
    }
    
    //VkDescritporSetLayout
    if(vkPipelineLayout)
    {
        vkDestroyPipelineLayout(vkDevice, vkPipelineLayout, NULL);
        vkPipelineLayout = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkPipelineLayout() is done\n");
        fflush(gpFile);
    }
    
    //VkDescritporSetLayout
    if(vkDescriptorSetLayout)
    {
        vkDestroyDescriptorSetLayout(vkDevice, vkDescriptorSetLayout, NULL);
        vkDescriptorSetLayout = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDescriptorSetLayout() is done\n");
        fflush(gpFile);
    }
    
    if(vkPipeline)
    {
        vkDestroyPipeline(vkDevice, vkPipeline, NULL);
        vkPipeline = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyPipeline() is done\n");
        fflush(gpFile);
    }
    
    //Renderpass
    if(vkRenderPass)
    {
        vkDestroyRenderPass(vkDevice, vkRenderPass, NULL);
        vkRenderPass = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyRenderPass() is done\n");
        fflush(gpFile);
    }
    
    //destroy shader modules
    if(vkShaderModule_fragment_shader)
    {
        vkDestroyShaderModule(vkDevice, vkShaderModule_fragment_shader, NULL);
        vkShaderModule_fragment_shader = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyShaderModule() is done\n");
        fflush(gpFile);
    }
    
    if(vkShaderModule_vertex_shader)
    {
        vkDestroyShaderModule(vkDevice, vkShaderModule_vertex_shader, NULL);
        vkShaderModule_vertex_shader = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyShaderModule() is done\n");
        fflush(gpFile);
    }
    
    //Destroy uniform buffer
    // if(uniformData_cube.vkBuffer)
    // {
        // vkDestroyBuffer(vkDevice, uniformData_cube.vkBuffer, NULL);
        // uniformData_cube.vkBuffer = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_cube.vkBuffer is done\n");
    // }
    
    // if(uniformData_cube.vkDeviceMemory)
    // {
        // vkFreeMemory(vkDevice, uniformData_cube.vkDeviceMemory, NULL);
        // uniformData_cube.vkDeviceMemory = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_cube.vkDeviceMemory is done\n");
    // }
    
    // if(uniformData_pyramid.vkBuffer)
    // {
        // vkDestroyBuffer(vkDevice, uniformData_pyramid.vkBuffer, NULL);
        // uniformData_pyramid.vkBuffer = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_pyramid.vkBuffer is done\n");
    // }
    
    // if(uniformData_pyramid.vkDeviceMemory)
    // {
        // vkFreeMemory(vkDevice, uniformData_pyramid.vkDeviceMemory, NULL);
        // uniformData_pyramid.vkDeviceMemory = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_pyramid.vkDeviceMemory is done\n");
    // }
    
    //Destroy uniform buffer
    if(uniformData_neptune.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, uniformData_neptune.vkBuffer, NULL);
        uniformData_neptune.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_neptune.vkBuffer is done\n");
        fflush(gpFile);
    }

    if(uniformData_neptune.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, uniformData_neptune.vkDeviceMemory, NULL);
        uniformData_neptune.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_neptune.vkDeviceMemory is done\n");
        fflush(gpFile);
    }
    
    //Destroy uniform buffer
    if(uniformData_uranus.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, uniformData_uranus.vkBuffer, NULL);
        uniformData_uranus.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_uranus.vkBuffer is done\n");
        fflush(gpFile);
    }

    if(uniformData_uranus.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, uniformData_uranus.vkDeviceMemory, NULL);
        uniformData_uranus.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_uranus.vkDeviceMemory is done\n");
        fflush(gpFile);
    }
    
    //Destroy uniform buffer
    if(uniformData_saturn.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, uniformData_saturn.vkBuffer, NULL);
        uniformData_saturn.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_saturn.vkBuffer is done\n");
        fflush(gpFile);
    }

    if(uniformData_saturn.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, uniformData_saturn.vkDeviceMemory, NULL);
        uniformData_saturn.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_saturn.vkDeviceMemory is done\n");
        fflush(gpFile);
    }
    
    //Destroy uniform buffer
    if(uniformData_jupitor.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, uniformData_jupitor.vkBuffer, NULL);
        uniformData_jupitor.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_jupitor.vkBuffer is done\n");
        fflush(gpFile);
    }

    if(uniformData_jupitor.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, uniformData_jupitor.vkDeviceMemory, NULL);
        uniformData_jupitor.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_jupitor.vkDeviceMemory is done\n");
        fflush(gpFile);
    }
    
    //Destroy uniform buffer
    if(uniformData_mars.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, uniformData_mars.vkBuffer, NULL);
        uniformData_mars.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_mars.vkBuffer is done\n");
        fflush(gpFile);
    }

    if(uniformData_mars.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, uniformData_mars.vkDeviceMemory, NULL);
        uniformData_mars.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_mars.vkDeviceMemory is done\n");
        fflush(gpFile);
    }
    
    //Destroy uniform buffer
    if(uniformData_earth.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, uniformData_earth.vkBuffer, NULL);
        uniformData_earth.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_earth.vkBuffer is done\n");
        fflush(gpFile);
    }

    if(uniformData_earth.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, uniformData_earth.vkDeviceMemory, NULL);
        uniformData_earth.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_earth.vkDeviceMemory is done\n");
        fflush(gpFile);
    }

    //Destroy uniform buffer
    if(uniformData_venus.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, uniformData_venus.vkBuffer, NULL);
        uniformData_venus.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_venus.vkBuffer is done\n");
        fflush(gpFile);
    }

    if(uniformData_venus.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, uniformData_venus.vkDeviceMemory, NULL);
        uniformData_venus.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_venus.vkDeviceMemory is done\n");
        fflush(gpFile);
    }
    
    //Destroy uniform buffer
    if(uniformData_mercury.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, uniformData_mercury.vkBuffer, NULL);
        uniformData_mercury.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_mercury.vkBuffer is done\n");
        fflush(gpFile);
    }

    if(uniformData_mercury.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, uniformData_mercury.vkDeviceMemory, NULL);
        uniformData_mercury.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_mercury.vkDeviceMemory is done\n");
        fflush(gpFile);
    }
    
    
    //Destroy uniform buffer
    if(uniformData_sun.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, uniformData_sun.vkBuffer, NULL);
        uniformData_sun.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer()  for uniformData_sun.vkBuffer is done\n");
        fflush(gpFile);
    }

    if(uniformData_sun.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, uniformData_sun.vkDeviceMemory, NULL);
        uniformData_sun.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory()  for uniformData_sun.vkDeviceMemory is done\n");
        fflush(gpFile);
    }
    
    // if(vkSampler_texture_kundali)
    // {
        // vkDestroySampler(vkDevice, vkSampler_texture_kundali, NULL);
        // vkSampler_texture_kundali = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkDestroySampler() for vkSampler_texture_kundali is done\n");
    // }
    
    // if(vkSampler_texture_stone)
    // {
        // vkDestroySampler(vkDevice, vkSampler_texture_stone, NULL);
        // vkSampler_texture_stone = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkDestroySampler() for vkSampler_texture_stone is done\n");
    // }
    
    if(vkSampler_texture)
    {
        vkDestroySampler(vkDevice, vkSampler_texture, NULL);
        vkSampler_texture = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroySampler() for vkSampler_texture is done\n");
        fflush(gpFile);
    }
    
    // if(vkImageView_texture_kundali)
    // {
        // vkDestroyImageView(vkDevice, vkImageView_texture_kundali, NULL);
        // vkImageView_texture_kundali = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkDestroySampler() for vkImageView_texture_kundali is done\n");
    // }
    
    // if(vkImageView_texture_stone)
    // {
        // vkDestroyImageView(vkDevice, vkImageView_texture_stone, NULL);
        // vkImageView_texture_stone = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkDestroySampler() for vkImageView_texture_stone is done\n");
    // }
    
    if(vkImageView_texture)
    {
        vkDestroyImageView(vkDevice, vkImageView_texture, NULL);
        vkImageView_texture = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroySampler() for vkImageView_texture is done\n");
        fflush(gpFile);
    }
    
    if(vkDeviceMemory_texture)
    {
        vkFreeMemory(vkDevice, vkDeviceMemory_texture, NULL);
        vkDeviceMemory_texture = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() for vkDeviceMemory_texture is done\n");
        fflush(gpFile);
    }
    
    if(vkImage_texture)
    {
        vkDestroyImage(vkDevice, vkImage_texture, NULL);
        vkImage_texture = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyImage() for vkImage_texture is done\n");
        fflush(gpFile);
    }

    
    //Vertex Tecoord buffer
    // if(vertexData_texcoord_cube.vkDeviceMemory)
    // {
        // vkFreeMemory(vkDevice, vertexData_texcoord_cube.vkDeviceMemory, NULL);
        // vertexData_texcoord_cube.vkDeviceMemory = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
    // }
    
    // if(vertexData_texcoord_cube.vkBuffer)
    // {
        // vkDestroyBuffer(vkDevice, vertexData_texcoord_cube.vkBuffer, NULL);
        // vertexData_texcoord_cube.vkBuffer = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
    // }
    
    // if(vertexData_texcoord_pyramid.vkDeviceMemory)
    // {
        // vkFreeMemory(vkDevice, vertexData_texcoord_pyramid.vkDeviceMemory, NULL);
        // vertexData_texcoord_pyramid.vkDeviceMemory = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
    // }
    
    // if(vertexData_texcoord_pyramid.vkBuffer)
    // {
        // vkDestroyBuffer(vkDevice, vertexData_texcoord_pyramid.vkBuffer, NULL);
        // vertexData_texcoord_pyramid.vkBuffer = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
    // }

    // Vertex position BUffer
    // if(vertexData_position_cube.vkDeviceMemory)
    // {
        // vkFreeMemory(vkDevice, vertexData_position_cube.vkDeviceMemory, NULL);
        // vertexData_position_cube.vkDeviceMemory = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
    // }
    
    // if(vertexData_position_cube.vkBuffer)
    // {
        // vkDestroyBuffer(vkDevice, vertexData_position_cube.vkBuffer, NULL);
        // vertexData_position_cube.vkBuffer = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
    // }
    
     // if(vertexData_position_pyramid.vkDeviceMemory)
    // {
        // vkFreeMemory(vkDevice, vertexData_position_pyramid.vkDeviceMemory, NULL);
        // vertexData_position_pyramid.vkDeviceMemory = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
    // }
    
    // if(vertexData_position_pyramid.vkBuffer)
    // {
        // vkDestroyBuffer(vkDevice, vertexData_position_pyramid.vkBuffer, NULL);
        // vertexData_position_pyramid.vkBuffer = VK_NULL_HANDLE;
        // fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
    // }


    //Destroying all index buffers
    if(vertexData_index_neptune.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_index_neptune.vkDeviceMemory, NULL);
        vertexData_index_neptune.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_index_neptune.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_index_neptune.vkBuffer, NULL);
        vertexData_index_neptune.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_index_uranus.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_index_uranus.vkDeviceMemory, NULL);
        vertexData_index_uranus.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_index_uranus.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_index_uranus.vkBuffer, NULL);
        vertexData_index_uranus.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_index_saturn.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_index_saturn.vkDeviceMemory, NULL);
        vertexData_index_saturn.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_index_saturn.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_index_saturn.vkBuffer, NULL);
        vertexData_index_saturn.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_index_jupitor.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_index_jupitor.vkDeviceMemory, NULL);
        vertexData_index_jupitor.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_index_jupitor.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_index_jupitor.vkBuffer, NULL);
        vertexData_index_jupitor.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_index_mars.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_index_mars.vkDeviceMemory, NULL);
        vertexData_index_mars.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_index_mars.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_index_mars.vkBuffer, NULL);
        vertexData_index_mars.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_index_earth.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_index_earth.vkDeviceMemory, NULL);
        vertexData_index_earth.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_index_earth.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_index_earth.vkBuffer, NULL);
        vertexData_index_earth.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }

    if(vertexData_index_venus.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_index_venus.vkDeviceMemory, NULL);
        vertexData_index_venus.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_index_venus.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_index_venus.vkBuffer, NULL);
        vertexData_index_venus.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    
    if(vertexData_index_mercury.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_index_mercury.vkDeviceMemory, NULL);
        vertexData_index_mercury.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_index_mercury.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_index_mercury.vkBuffer, NULL);
        vertexData_index_mercury.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    
    if(vertexData_index_sun.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_index_sun.vkDeviceMemory, NULL);
        vertexData_index_sun.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_index_sun.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_index_sun.vkBuffer, NULL);
        vertexData_index_sun.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    

    //Destroying all normal buffer
    if(vertexData_normal_neptune.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_normal_neptune.vkDeviceMemory, NULL);
        vertexData_normal_neptune.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_normal_neptune.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_normal_neptune.vkBuffer, NULL);
        vertexData_normal_neptune.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_normal_uranus.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_normal_uranus.vkDeviceMemory, NULL);
        vertexData_normal_uranus.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_normal_uranus.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_normal_uranus.vkBuffer, NULL);
        vertexData_normal_uranus.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_normal_saturn.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_normal_saturn.vkDeviceMemory, NULL);
        vertexData_normal_saturn.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_normal_saturn.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_normal_saturn.vkBuffer, NULL);
        vertexData_normal_saturn.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_normal_jupitor.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_normal_jupitor.vkDeviceMemory, NULL);
        vertexData_normal_jupitor.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_normal_jupitor.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_normal_jupitor.vkBuffer, NULL);
        vertexData_normal_jupitor.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_normal_mars.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_normal_mars.vkDeviceMemory, NULL);
        vertexData_normal_mars.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_normal_mars.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_normal_mars.vkBuffer, NULL);
        vertexData_normal_mars.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_normal_earth.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_normal_earth.vkDeviceMemory, NULL);
        vertexData_normal_earth.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_normal_earth.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_normal_earth.vkBuffer, NULL);
        vertexData_normal_earth.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }

    if(vertexData_normal_venus.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_normal_venus.vkDeviceMemory, NULL);
        vertexData_normal_venus.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_normal_venus.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_normal_venus.vkBuffer, NULL);
        vertexData_normal_venus.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    
    if(vertexData_normal_mercury.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_normal_mercury.vkDeviceMemory, NULL);
        vertexData_normal_mercury.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_normal_mercury.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_normal_mercury.vkBuffer, NULL);
        vertexData_normal_mercury.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    
    if(vertexData_normal_sun.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_normal_sun.vkDeviceMemory, NULL);
        vertexData_normal_sun.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_normal_sun.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_normal_sun.vkBuffer, NULL);
        vertexData_normal_sun.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    

    //Destroying all texcoord buffers
    if(vertexData_texcoord_neptune.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_texcoord_neptune.vkDeviceMemory, NULL);
        vertexData_texcoord_neptune.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_neptune.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_texcoord_neptune.vkBuffer, NULL);
        vertexData_texcoord_neptune.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
   
    if(vertexData_texcoord_uranus.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_texcoord_uranus.vkDeviceMemory, NULL);
        vertexData_texcoord_uranus.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_uranus.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_texcoord_uranus.vkBuffer, NULL);
        vertexData_texcoord_uranus.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_saturn.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_texcoord_saturn.vkDeviceMemory, NULL);
        vertexData_texcoord_saturn.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_saturn.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_texcoord_saturn.vkBuffer, NULL);
        vertexData_texcoord_saturn.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_jupitor.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_texcoord_jupitor.vkDeviceMemory, NULL);
        vertexData_texcoord_jupitor.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_jupitor.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_texcoord_jupitor.vkBuffer, NULL);
        vertexData_texcoord_jupitor.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_mars.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_texcoord_mars.vkDeviceMemory, NULL);
        vertexData_texcoord_mars.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_mars.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_texcoord_mars.vkBuffer, NULL);
        vertexData_texcoord_mars.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
     if(vertexData_texcoord_earth.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_texcoord_earth.vkDeviceMemory, NULL);
        vertexData_texcoord_earth.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_earth.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_texcoord_earth.vkBuffer, NULL);
        vertexData_texcoord_earth.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
    }

    if(vertexData_texcoord_venus.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_texcoord_venus.vkDeviceMemory, NULL);
        vertexData_texcoord_venus.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_venus.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_texcoord_venus.vkBuffer, NULL);
        vertexData_texcoord_venus.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_texcoord_mercury.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_texcoord_mercury.vkDeviceMemory, NULL);
        vertexData_texcoord_mercury.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_mercury.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_texcoord_mercury.vkBuffer, NULL);
        vertexData_texcoord_mercury.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    
    
    if(vertexData_texcoord_sun.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_texcoord_sun.vkDeviceMemory, NULL);
        vertexData_texcoord_sun.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    if(vertexData_texcoord_sun.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_texcoord_sun.vkBuffer, NULL);
        vertexData_texcoord_sun.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    

    //Vertex position BUffer
    if(vertexData_position_neptune.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_position_neptune.vkDeviceMemory, NULL);
        vertexData_position_neptune.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_position_neptune.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_position_neptune.vkBuffer, NULL);
        vertexData_position_neptune.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    if(vertexData_position_uranus.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_position_uranus.vkDeviceMemory, NULL);
        vertexData_position_uranus.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_position_uranus.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_position_uranus.vkBuffer, NULL);
        vertexData_position_uranus.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
     if(vertexData_position_saturn.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_position_saturn.vkDeviceMemory, NULL);
        vertexData_position_saturn.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_position_saturn.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_position_saturn.vkBuffer, NULL);
        vertexData_position_saturn.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    if(vertexData_position_jupitor.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_position_jupitor.vkDeviceMemory, NULL);
        vertexData_position_jupitor.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_position_jupitor.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_position_jupitor.vkBuffer, NULL);
        vertexData_position_jupitor.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    if(vertexData_position_mars.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_position_mars.vkDeviceMemory, NULL);
        vertexData_position_mars.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_position_mars.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_position_mars.vkBuffer, NULL);
        vertexData_position_mars.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    if(vertexData_position_earth.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_position_earth.vkDeviceMemory, NULL);
        vertexData_position_earth.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_position_earth.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_position_earth.vkBuffer, NULL);
        vertexData_position_earth.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }

    if(vertexData_position_venus.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_position_venus.vkDeviceMemory, NULL);
        vertexData_position_venus.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_position_venus.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_position_venus.vkBuffer, NULL);
        vertexData_position_venus.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_position_mercury.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_position_mercury.vkDeviceMemory, NULL);
        vertexData_position_mercury.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_position_mercury.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_position_mercury.vkBuffer, NULL);
        vertexData_position_mercury.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    
    if(vertexData_position_sun.vkDeviceMemory)
    {
        vkFreeMemory(vkDevice, vertexData_position_sun.vkDeviceMemory, NULL);
        vertexData_position_sun.vkDeviceMemory = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done\n");
        fflush(gpFile);
    }
    
    if(vertexData_position_sun.vkBuffer)
    {
        vkDestroyBuffer(vkDevice, vertexData_position_sun.vkBuffer, NULL);
        vertexData_position_sun.vkBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyBuffer() is done\n");
        fflush(gpFile);
    }
    
    for(uint32_t i = 0; i < swapchainImageCount; i++)
    {
        vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_array[i]);
        fprintf(gpFile, "Uninitialize() --> vkFreeCommandBuffers() is done\n");
        fflush(gpFile);
    }
    
    if(vkCommandBuffer_array)
    {
        free(vkCommandBuffer_array);
        vkCommandBuffer_array = NULL;
        fprintf(gpFile, "Uninitialize() --> vkCommandBuffer_array is freed\n");
        fflush(gpFile);
    }
    
    
    if(vkCommandPool)
    {
        vkDestroyCommandPool(vkDevice, vkCommandPool, NULL);
        vkCommandPool = NULL;
        fprintf(gpFile, "Uninitialize() --> vkDestroyCommandPool() is done\n");
        fflush(gpFile);
    }
    
    //destroy depth image view
    if(vkImageView_depth)
    {
        vkDestroyImageView(vkDevice, vkImageView_depth, NULL);
        vkImageView_depth = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestoryImageView() is done for depth\n");
        fflush(gpFile);
    }
    
    //destroy device memory for depth image
    if(vkDeviceMemory_depth)
    {
        vkFreeMemory(vkDevice, vkDeviceMemory_depth, NULL);
        vkDeviceMemory_depth = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkFreeMemory() is done for depth\n");
        fflush(gpFile);
    }
    
    if(vkImage_depth)
    {
        vkDestroyImage(vkDevice, vkImage_depth, NULL);
        vkImage_depth = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestoryImage() is done for depth\n");
        fflush(gpFile);
    }
    
    //destory image views
    for(uint32_t i = 0; i < swapchainImageCount; i++)
    {
        vkDestroyImageView(vkDevice, swapchainImageView_array[i], NULL);
        fprintf(gpFile, "Uninitialize() --> vkDestoryImageView() is done for color\n");
        fflush(gpFile);
    }
    
    if(swapchainImageView_array)
    {
        free(swapchainImageView_array);
        swapchainImageView_array = NULL;
        fprintf(gpFile, "Uninitialize() --> swapchainImageView_array is freed\n");
        fflush(gpFile);
    }
    
    //free swapchainImages
    // for(uint32_t i = 0; i < swapchainImageCount; i++)
    // {
        // vkDestroyImage(vkDevice, swapchainImage_array[i], NULL);
        // fprintf(gpFile, "Uninitialize() --> vkDestroyImage() is done\n");
    // }
    
    if(swapchainImage_array)
    {
        free(swapchainImage_array);
        swapchainImage_array = NULL;
        fprintf(gpFile, "Uninitialize() --> swapchainImage_array is freed\n");
        fflush(gpFile);
    }
    
  
    
    //Destory Swapchain
    if(vkSwapchainKHR)
    {
        vkDestroySwapchainKHR(vkDevice, vkSwapchainKHR, NULL);
        vkSwapchainKHR = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkSwapchainCreateInfoKHR() is done\n");
        fflush(gpFile);
    }

    //No need to Destroy/Uninitialize the DeviceQueue

    //Destroy vulkan device
    if(vkDevice)
    {
        vkDestroyDevice(vkDevice, NULL);
        vkDevice = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestoryDevice() is done\n");
        fflush(gpFile);
    }

    //No need to free slected physical device

    //Destroy vkSurfaceKHR:This function is generic and not platform specific
    if(vkSurfaceKHR)
    {
        vkDestroySurfaceKHR(vkInstance, vkSurfaceKHR, NULL);
        vkSurfaceKHR = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroySurfaceKHR() is done\n");
        fflush(gpFile);
    }
    
    //Validation destroying
    if(vkDebugReportCallbackEXT && vkDestroyDebugReportCallbackEXT_fnptr)
    {
        vkDestroyDebugReportCallbackEXT_fnptr(vkInstance, 
                                              vkDebugReportCallbackEXT,
                                              NULL);
        vkDebugReportCallbackEXT = VK_NULL_HANDLE;
        vkDestroyDebugReportCallbackEXT_fnptr = NULL;
    }
    
    
    //Destroy Vulkan Instance
    if(vkInstance)
    {
        vkDestroyInstance(vkInstance, NULL);
        vkInstance = VK_NULL_HANDLE;
        fprintf(gpFile, "Uninitialize() --> vkDestroyInstance() is done\n");
        fflush(gpFile);
    }
    
    if (gpFile)
	{
		fprintf(gpFile, "Uninitialize() --> Program terminated successfully\n");
        fflush(gpFile);
		fclose(gpFile);
		gpFile = NULL;
	}
}

/***************Definition of Vulkan functions***********************/
/********************************************************************/

VkResult createVulkanInstance(void)
{
    //Function declarations
    VkResult fillInstanceExtensionNames(void);
    VkResult fillValidationLayerNames(void);
    VkResult createValidationCallbackFunction(void);

    //variable declarations
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //Step1: Fill and initialize required extension names and count in global variable
    vkResult = fillInstanceExtensionNames();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVulkanInstance() --> fillInstanceExtensionNames() is failed\n");
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "createVulkanInstance() --> fillInstanceExtensionNames() is succedded\n");
        fflush(gpFile);
    }

    if(bValidation == TRUE)
    {
        //Fill validation Layer Names
        vkResult = fillValidationLayerNames();
        if(vkResult != VK_SUCCESS)
        {
            fprintf(gpFile, "createVulkanInstance() --> fillValidationLayerNames() is failed\n");
            fflush(gpFile);
        }
        else
        {
            fprintf(gpFile, "createVulkanInstance() --> fillValidationLayerNames() is succedded\n");
            fflush(gpFile);
        }
    }


    //Step1: Initialize struct VkApplicationInfo
    VkApplicationInfo vkApplicationInfo;
    memset((void*)&vkApplicationInfo, 0, sizeof(VkApplicationInfo));

    vkApplicationInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO; //type safety, generic names
    vkApplicationInfo.pNext = NULL; //Linked List
    vkApplicationInfo.pApplicationName = gpszAppName;
    vkApplicationInfo.applicationVersion = 1;
    vkApplicationInfo.pEngineName = gpszAppName;
    vkApplicationInfo.engineVersion = 1;
    vkApplicationInfo.apiVersion = VK_API_VERSION_1_4;


    //Step3: Initialize struct VkInstanceCreateInfo by using information in Step1 and Step2
    VkInstanceCreateInfo vkInstanceCreateInfo;
    memset((void*)&vkInstanceCreateInfo, 0, sizeof(VkInstanceCreateInfo));
    vkInstanceCreateInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    vkInstanceCreateInfo.pNext = NULL;
    vkInstanceCreateInfo.pApplicationInfo = &vkApplicationInfo;
    vkInstanceCreateInfo.enabledExtensionCount = enabledInstanceExtensionCount;
    vkInstanceCreateInfo.ppEnabledExtensionNames = enabledInstanceExtensionNames_array;
    
    if(bValidation == TRUE)
    {
        vkInstanceCreateInfo.enabledLayerCount = enabledValidationLayerCount;
        vkInstanceCreateInfo.ppEnabledLayerNames = enabledValidationLayerNames_array;
    }
    else
    {
        vkInstanceCreateInfo.enabledLayerCount = 0;
        vkInstanceCreateInfo.ppEnabledLayerNames = NULL;
    }

    /*
	// Provided by VK_VERSION_1_0
		VkResult vkCreateInstance(
		const VkInstanceCreateInfo* pCreateInfo,
		const VkAllocationCallbacks* pAllocator,
		VkInstance* pInstance);

		• pCreateInfo is a pointer to a VkInstanceCreateInfo structure controlling creation of the instance.
		• pAllocator controls host memory allocation as described in the Memory Allocation chapter.
		• pInstance points a VkInstance handle in which the resulting instance is returned.
	 */
    //Step4: Call VkCreateInstance() to get vkInstance in a global variable and do error checking
    vkResult = vkCreateInstance(&vkInstanceCreateInfo,
                                 NULL,  //no custom Memory allocater
                                 &vkInstance);
    if(vkResult == VK_ERROR_INCOMPATIBLE_DRIVER)
    {
        fprintf(gpFile, "createVulkanInstance() --> vkCreateInstance:: vkCreateInstance failed due to incompatible driver %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else if(vkResult == VK_ERROR_EXTENSION_NOT_PRESENT)
    {
        fprintf(gpFile, "createVulkanInstance() --> vkCreateInstance:: vkCreateInstance failed due to required extension not present %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVulkanInstance() --> vkCreateInstance:: vkCreateInstance failed due to unknown reason %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVulkanInstance() --> vkCreateInstance:: vkCreateInstance succedded\n");
        fflush(gpFile);
    }
    
    //do for validation callbacks
    if(bValidation == TRUE)
    {
        vkResult = createValidationCallbackFunction();
        if(vkResult != VK_SUCCESS)
        {
            fprintf(gpFile, "createVulkanInstance() --> createValidationCallbackFunction() is failed\n");
            fflush(gpFile);
        }
        else
        {
            fprintf(gpFile, "createVulkanInstance() --> createValidationCallbackFunction() is succedded\n");
            fflush(gpFile);
        }
    }


   //Step5: Destroy

    return vkResult;
}


VkResult fillInstanceExtensionNames(void)
{
    //variable declaration
    VkResult vkResult = VK_SUCCESS;

    //Step1: Find how many Instacne Extension are supported by the vulkan driver of this version and keep the count in local variable
    uint32_t instanceExtensionCount = 0;

    /*
    // Provided by VK_VERSION_1_0
        VkResult vkEnumerateInstanceExtensionProperties(
        const char* pLayerName,
        uint32_t* pPropertyCount,
        VkExtensionProperties* pProperties);
    
        • pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to
          retrieve extensions from.
        • pPropertyCount is a pointer to an integer related to the number of extension properties available
          or queried, as described below.
        • pProperties is either NULL or a pointer to an array of VkExtensionProperties structures
    */

    vkResult = vkEnumerateInstanceExtensionProperties(NULL, //Which layer's extenion is needed: Mention extension name: For all driver's extension use NULL
                                                      &instanceExtensionCount,
                                                      NULL); // Instance Extensions Properties array: As we dont have count, so its NULL
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "fillInstanceExtensionNames() --> 1st call to vkEnumerateInstanceExtensionProperties() is failed\n");
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "fillInstanceExtensionNames() --> 1st call to vkEnumerateInstanceExtensionProperties() is succedded\n");
        fflush(gpFile);
    }



    //Step2: Allocate and fill VkExtensionProperties corresponding to above count
    VkExtensionProperties* vkExtensionProperties_array = NULL;
    vkExtensionProperties_array = (VkExtensionProperties*) malloc (sizeof(VkExtensionProperties) * instanceExtensionCount);
    //Should be error checking for malloc: assert() can also be used

    vkResult = vkEnumerateInstanceExtensionProperties(NULL, //Which layer's extenion is needed: Mention extension name: For all driver's extension use NULL
                                                      &instanceExtensionCount,
                                                      vkExtensionProperties_array); // Instance Extensions Properties array: As we have count, so it is value
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "fillInstanceExtensionNames() --> 2nd call to vkEnumerateInstanceExtensionProperties() is failed\n");
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "fillInstanceExtensionNames() --> 2nd call to vkEnumerateInstanceExtensionProperties() is succedded\n");
        fflush(gpFile);
    }



    //Step3: Fill and Display a local string array of extension names obtained from vkExtensionProperties
    char** instanceExtensionNames_array = NULL;

    instanceExtensionNames_array = (char**)malloc(sizeof(char*) * instanceExtensionCount);
    //Should be error checking for malloc: assert() can also be used
    for(uint32_t i = 0; i < instanceExtensionCount; i++)
    {
        instanceExtensionNames_array[i] = (char*)malloc(sizeof(char) * strlen(vkExtensionProperties_array[i].extensionName) + 1);
        memcpy(instanceExtensionNames_array[i], vkExtensionProperties_array[i].extensionName, strlen(vkExtensionProperties_array[i].extensionName) + 1);
        fprintf(gpFile, "fillInstanceExtensionNames() --> Vulkan Instance Extension names = %s\n", instanceExtensionNames_array[i]);
        fflush(gpFile);
    }



   //Step4: As not required henceforth, free the vkExtensionProperties_array;
   free(vkExtensionProperties_array);
   vkExtensionProperties_array = NULL;



   // Step5: Find whether below extension names contains our required two extensions
   //VK_KHR_SURFACE_EXTENSION_NAME
   //VK_KHR_WIN32_SURFACE_EXTENSION_NAME
   VkBool32 vulkanSurfaceExtensionFound = VK_FALSE;
   VkBool32 vulkanWin32SurfaceExtensionFound = VK_FALSE;
   VkBool32 vulkanDebugReportExtensionFound = VK_FALSE;

    for(uint32_t i = 0; i < instanceExtensionCount; i++)
    {
        if(strcmp(instanceExtensionNames_array[i], VK_KHR_SURFACE_EXTENSION_NAME) == 0)
        {
            vulkanSurfaceExtensionFound = VK_TRUE;
            enabledInstanceExtensionNames_array[enabledInstanceExtensionCount++] = VK_KHR_SURFACE_EXTENSION_NAME;
        }
        
        if(strcmp(instanceExtensionNames_array[i], VK_KHR_WIN32_SURFACE_EXTENSION_NAME) == 0)
        {
            vulkanWin32SurfaceExtensionFound = VK_TRUE;
            enabledInstanceExtensionNames_array[enabledInstanceExtensionCount++] = VK_KHR_WIN32_SURFACE_EXTENSION_NAME;
        }
        
        if(strcmp(instanceExtensionNames_array[i], VK_EXT_DEBUG_REPORT_EXTENSION_NAME) == 0)
        {
            vulkanDebugReportExtensionFound = VK_TRUE;
            if(bValidation == TRUE)
            {
                enabledInstanceExtensionNames_array[enabledInstanceExtensionCount++] = VK_EXT_DEBUG_REPORT_EXTENSION_NAME;
            }
            else
            {
                //array will not have entry of VK_EXT_DEBUG_REPORT_EXTENSION_NAME;
            }
        }
    }



    //Step 6:
    //As not required henceforth, free the local string array
    for(uint32_t i = 0; i < instanceExtensionCount; i++)
    {
        free(instanceExtensionNames_array[i]);
    }
    free(instanceExtensionNames_array);



    //Step7:Print whether our vulkan driver supports our required extension names or not
    if(vulkanSurfaceExtensionFound == VK_FALSE)
    {
        // return hardcoded failure
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        fprintf(gpFile, "fillInstanceExtensionNames() --> VK_KHR_SURFACE_EXTENSION_NAME not found\n");
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "fillInstanceExtensionNames() --> VK_KHR_SURFACE_EXTENSION_NAME found\n");
        fflush(gpFile);
    }

    if(vulkanWin32SurfaceExtensionFound == VK_FALSE)
    {
        // return hardcoded failure
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        fprintf(gpFile, "fillInstanceExtensionNames() --> VK_KHR_WIN32_SURFACE_EXTENSION_NAME not found\n");
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "fillInstanceExtensionNames() --> VK_KHR_WIN32_SURFACE_EXTENSION_NAME found\n");
        fflush(gpFile);
    }
    
    if(vulkanDebugReportExtensionFound == VK_FALSE)
    {
        if(bValidation == TRUE)
        {
            // return hardcoded failure
            vkResult = VK_ERROR_INITIALIZATION_FAILED;
            fprintf(gpFile, "fillInstanceExtensionNames() --> VK_EXT_DEBUG_REPORT_EXTENSION_NAME not found:: Validation is ON But required VK_EXT_DEBUG_REPORT_EXTENSION_NAME is not supported\n");
            fflush(gpFile);
            return vkResult;
        }
        else
        {
            fprintf(gpFile, "fillInstanceExtensionNames() --> VK_EXT_DEBUG_REPORT_EXTENSION_NAME not found:: Validation is OFF But required VK_EXT_DEBUG_REPORT_EXTENSION_NAME is not supported\n");
            fflush(gpFile);
        }
    }
    else
    {
        if(bValidation == TRUE)
        {
            fprintf(gpFile, "fillInstanceExtensionNames() --> VK_EXT_DEBUG_REPORT_EXTENSION_NAME found:: Validation is ON and required VK_EXT_DEBUG_REPORT_EXTENSION_NAME is supported\n");
            fflush(gpFile);
        }
        else
        {
            fprintf(gpFile, "fillInstanceExtensionNames() --> VK_EXT_DEBUG_REPORT_EXTENSION_NAME found:: Validation is OFF and required VK_EXT_DEBUG_REPORT_EXTENSION_NAME is supported\n");
            fflush(gpFile);
        }
    }


    //Step8: Print only Enabled Extension Names 
    for(uint32_t i = 0; i < enabledInstanceExtensionCount; i++)
    {
        fprintf(gpFile, "fillInstanceExtensionNames() --> Enabled vulkan Instance extension Names = %s\n", enabledInstanceExtensionNames_array[i]);
        fflush(gpFile);
    }

    return vkResult;
}


VkResult fillValidationLayerNames(void)
{
    //code
    //variables
    VkResult vkResult = VK_SUCCESS;
    uint32_t validationLayerCount = 0;
    
    vkResult = vkEnumerateInstanceLayerProperties(&validationLayerCount,
                                                  NULL); // Instance Validation Properties array: As we dont have count, so its NULL
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "fillValidationLayerNames() --> 1st call to vkEnumerateInstanceLayerProperties() is failed: error code %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "fillValidationLayerNames() --> 1st call to vkEnumerateInstanceLayerProperties() is succedded\n");
        fflush(gpFile);
    }
    
    VkLayerProperties* vkLayerProperties_array = NULL;
    vkLayerProperties_array = (VkLayerProperties*) malloc (sizeof(VkLayerProperties) * validationLayerCount);
    //Should be error checking for malloc: assert() can also be used

    vkResult = vkEnumerateInstanceLayerProperties(&validationLayerCount,
                                                  vkLayerProperties_array); // Instance Validation Properties array: As we dont have count, so its NULL
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "fillValidationLayerNames() --> 2nd call to vkEnumerateInstanceLayerProperties() is failed: error code %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "fillValidationLayerNames() --> 2nd call to vkEnumerateInstanceLayerProperties() is succedded\n");
        fflush(gpFile);
    }
    
    char** validationLayerNames_array = NULL;
    validationLayerNames_array = (char**) malloc(sizeof(char*) * validationLayerCount);
    //Should be error checking for malloc: assert() can also be used
    for(uint32_t i = 0; i < validationLayerCount; i++)
    {
        validationLayerNames_array[i] = (char*)malloc(sizeof(char) * strlen(vkLayerProperties_array[i].layerName) + 1);
        //Should be error checking for malloc: assert() can also be used
        memcpy(validationLayerNames_array[i], vkLayerProperties_array[i].layerName, strlen(vkLayerProperties_array[i].layerName) + 1);
        fprintf(gpFile, "fillValidationLayerNames() --> Vulkan Validation Layer names = %s\n", vkLayerProperties_array[i].layerName);
        fflush(gpFile);
    }
    
    if(vkLayerProperties_array) 
        free(vkLayerProperties_array);
    vkLayerProperties_array = NULL;

    // Step5: Find whether below layer names contains our required two extensions
    //VK_KHR_SURFACE_EXTENSION_NAME
    VkBool32 vulkanValidationLayerFound = VK_FALSE;
    for(uint32_t i = 0; i < validationLayerCount; i++)
    {
        if(strcmp(validationLayerNames_array[i], "VK_LAYER_KHRONOS_validation") == 0)
        {
            vulkanValidationLayerFound = VK_TRUE;
            enabledValidationLayerNames_array[enabledValidationLayerCount++] = "VK_LAYER_KHRONOS_validation";
        }
    }
    
     //As not required henceforth, free the local string array
    for(uint32_t i = 0; i < validationLayerCount; i++)
    {
        free(validationLayerNames_array[i]);
    }
    free(validationLayerNames_array);
    
    if(bValidation == TRUE)
    {
        //Step7:Print whether our vulkan driver supports our required extension names or not
        if(vulkanValidationLayerFound == VK_FALSE)
        {
            // return hardcoded failure
            vkResult = VK_ERROR_INITIALIZATION_FAILED;
            fprintf(gpFile, "fillValidationLayerNames() --> VK_LAYER_KHRONOS_validation not supported\n");
            fflush(gpFile);
            return vkResult;
        }
        else
        {
            fprintf(gpFile, "fillValidationLayerNames() --> VK_LAYER_KHRONOS_validation is supported\n");
            fflush(gpFile);
        }
    }
    
    //Step8: Print only Enabled validation layer Names
    for(uint32_t i = 0; i < enabledValidationLayerCount; i++)
    {
        fprintf(gpFile, "fillValidationLayerNames() --> Enabled vulkan validation layer Names = %s\n", enabledValidationLayerNames_array[i]);
        fflush(gpFile);
    }
    
    return (vkResult);    
}


VkResult createValidationCallbackFunction(void)
{
    //code
    //function declarations
    VKAPI_ATTR VkBool32 VKAPI_CALL debugReportCallback(VkDebugReportFlagsEXT, 
                                                       VkDebugReportObjectTypeEXT,
                                                       uint64_t,
                                                       size_t,
                                                       int32_t,
                                                       const char*,
                                                       const char*,
                                                       void*);
    
    //variables
    VkResult vkResult = VK_SUCCESS;
    
    PFN_vkCreateDebugReportCallbackEXT vkCreateDebugReportCallbackEXT_fnptr = NULL;
    
    //Get the required function pointers
    vkCreateDebugReportCallbackEXT_fnptr = (PFN_vkCreateDebugReportCallbackEXT) vkGetInstanceProcAddr(vkInstance, "vkCreateDebugReportCallbackEXT");
    if(vkCreateDebugReportCallbackEXT_fnptr == NULL)
    {
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        fprintf(gpFile, "createValidationCallbackFunction() --> vkGetInstanceProcAddr() is failed to get function pointer for vkCreateDebugReportCallbackEXT \n");
        fflush(gpFile);
        return (vkResult);
    }
    else
    {
        fprintf(gpFile, "createValidationCallbackFunction() --> vkGetInstanceProcAddr() is succedded to get function pointer for vkCreateDebugReportCallbackEXT \n");
        fflush(gpFile);
    }
    
    
    PFN_vkDestroyDebugReportCallbackEXT vkDestroyDebugReportCallbackEXT_fnptr = NULL;
    
    //Get the required function pointers
    vkDestroyDebugReportCallbackEXT_fnptr = (PFN_vkDestroyDebugReportCallbackEXT) vkGetInstanceProcAddr(vkInstance, "vkDestroyDebugReportCallbackEXT");
    if(vkDestroyDebugReportCallbackEXT_fnptr == NULL)
    {
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        fprintf(gpFile, "createValidationCallbackFunction() --> vkGetInstanceProcAddr() is failed to get function pointer for vkDestroyDebugReportCallbackEXT \n");
        fflush(gpFile);
        return (vkResult);
    }
    else
    {
        fprintf(gpFile, "createValidationCallbackFunction() --> vkGetInstanceProcAddr() is succedded to get function pointer for vkDestroyDebugReportCallbackEXT \n");
        fflush(gpFile);
    }
    
    
    //Get the vulkanDebugReportCallback object
    VkDebugReportCallbackCreateInfoEXT vkDebugReportCallbackCreateInfoEXT;
    memset((void*)&vkDebugReportCallbackCreateInfoEXT, 0, sizeof(VkDebugReportCallbackCreateInfoEXT));
    vkDebugReportCallbackCreateInfoEXT.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT;
    vkDebugReportCallbackCreateInfoEXT.pNext = NULL;
    vkDebugReportCallbackCreateInfoEXT.flags = VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT;
    vkDebugReportCallbackCreateInfoEXT.pfnCallback = debugReportCallback;
    vkDebugReportCallbackCreateInfoEXT.pUserData = NULL;
    
    vkResult = vkCreateDebugReportCallbackEXT_fnptr(vkInstance,
                                                    &vkDebugReportCallbackCreateInfoEXT,
                                                    NULL,
                                                    &vkDebugReportCallbackEXT);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createValidationCallbackFunction() --> vkCreateDebugReportCallbackEXT_fnptr() is failed: error code %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "createValidationCallbackFunction() --> vkCreateDebugReportCallbackEXT_fnptr() is succedded\n");
        fflush(gpFile);
    }
    
    return (vkResult);
    
}


//Create Vulkan Presentation Surface
VkResult getSupportedSurface(void)
{
    //local variable declaration
    VkResult vkResult = VK_SUCCESS;

    //Step2
    VkWin32SurfaceCreateInfoKHR vkWin32SurfaceCreateInfoKHR;
    memset((void*)&vkWin32SurfaceCreateInfoKHR, 0, sizeof(VkWin32SurfaceCreateInfoKHR));
    vkWin32SurfaceCreateInfoKHR.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    vkWin32SurfaceCreateInfoKHR.pNext = NULL;
    vkWin32SurfaceCreateInfoKHR.flags = 0;
    //one way
    // vkWin32SurfaceCreateInfoKHR.hinstance = (HINSTANCE)GetModuleHandle(NULL);
    //another way for 64bit
    vkWin32SurfaceCreateInfoKHR.hinstance = (HINSTANCE)GetWindowLongPtr(ghwnd, GWLP_HINSTANCE);
    vkWin32SurfaceCreateInfoKHR.hwnd = ghwnd;

    //Step3:
    vkResult = vkCreateWin32SurfaceKHR(vkInstance,
                                       &vkWin32SurfaceCreateInfoKHR,
                                       NULL, //Memory mamnagement function is default
                                       &vkSurfaceKHR);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "getSupportedSurface() --> vkCreateWin32SurfaceKHR() is failed %d\n", vkResult);
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "getSupportedSurface() --> vkCreateWin32SurfaceKHR() is succedded\n");
        fflush(gpFile);
    }

    return vkResult;
}


VkResult getPhysicalDevice(void)
{
    //local variable declaration
    VkResult vkResult = VK_SUCCESS;
    

    //code
    vkResult = vkEnumeratePhysicalDevices(vkInstance,
                                          &physicalDeviceCount,
                                          NULL);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "getPhysicalDevice() --> 1st call to vkEnumeratePhysicalDevices() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else if(physicalDeviceCount == 0)
    {
        fprintf(gpFile, "getPhysicalDevice() --> 1st call to vkEnumeratePhysicalDevices() resulted in zero devices\n");
        fflush(gpFile);
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "getPhysicalDevice() --> 1st call to vkEnumeratePhysicalDevices() is succedded\n");
        fflush(gpFile);
    }

    vkPhysicalDevice_array = (VkPhysicalDevice*)malloc(sizeof(VkPhysicalDevice) * physicalDeviceCount);
    //error checking to be done
    
    vkResult = vkEnumeratePhysicalDevices(vkInstance, 
                                          &physicalDeviceCount,
                                          vkPhysicalDevice_array);
     if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "getPhysicalDevice() --> 2nd call to vkEnumeratePhysicalDevices() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "getPhysicalDevice() --> 2nd call to vkEnumeratePhysicalDevices() is succedded\n");
        fflush(gpFile);
    }

    VkBool32 bFound = VK_FALSE;
    for(uint32_t i = 0; i < physicalDeviceCount; i++)
    {
        uint32_t qCount = UINT32_MAX;
        
        //If physical device is present then it must support at least 1 queue family
        vkGetPhysicalDeviceQueueFamilyProperties(vkPhysicalDevice_array[i], 
                                               &qCount, 
                                               NULL);
        VkQueueFamilyProperties *vkQueueFamilyProperties_array = NULL;
        vkQueueFamilyProperties_array = (VkQueueFamilyProperties*)malloc(sizeof(VkQueueFamilyProperties) * qCount);
        //error checking to be done
        
        vkGetPhysicalDeviceQueueFamilyProperties(vkPhysicalDevice_array[i], 
                                               &qCount, 
                                               vkQueueFamilyProperties_array);
        
        VkBool32* isQueueSurfaceSupported_array = NULL;
        isQueueSurfaceSupported_array = (VkBool32*)malloc(sizeof(VkBool32) * qCount);
        //error checking to be done
        
        for(uint32_t j = 0; j < qCount; j++)
        {
            vkGetPhysicalDeviceSurfaceSupportKHR(vkPhysicalDevice_array[i], 
                                                 j,
                                                 vkSurfaceKHR,
                                                 &isQueueSurfaceSupported_array[j]);
        }
        
        for(uint32_t j = 0; j < qCount; j++)
        {
            if(vkQueueFamilyProperties_array[j].queueFlags & VK_QUEUE_GRAPHICS_BIT)
            {
                if(isQueueSurfaceSupported_array[j] == VK_TRUE)
                {
                    vkPhysicalDevice_selected = vkPhysicalDevice_array[i];
                    graphicsQueueFamilyIndex_selected = j;
                    bFound = VK_TRUE;
                    break;
                }
            }
        }
        
        if(isQueueSurfaceSupported_array)
        {
            free(isQueueSurfaceSupported_array);
            isQueueSurfaceSupported_array = NULL;
            fprintf(gpFile, "getPhysicalDevice() --> isQueueSurfaceSupported_array succedded to free\n");
            fflush(gpFile);
        }
        
        if(vkQueueFamilyProperties_array)
        {
            free(vkQueueFamilyProperties_array);
            vkQueueFamilyProperties_array = NULL;
            fprintf(gpFile, "getPhysicalDevice() --> vkQueueFamilyProperties_array succedded to free\n");
            fflush(gpFile);
        }
        
        if(bFound == VK_TRUE)
        {
            break;
        }
    }
    
    if(bFound == VK_TRUE)
    {
        fprintf(gpFile, "getPhysicalDevice() -->is succedded to select the required device with graphics enabled\n");
        fflush(gpFile);
    }
    else
    {
        if(vkPhysicalDevice_array)
        {
            free(vkPhysicalDevice_array);
            vkPhysicalDevice_array = NULL;
            fprintf(gpFile, "getPhysicalDevice() --> vkPhysicalDevice_array succedded to free\n");
            fflush(gpFile);
        }
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        fprintf(gpFile, "getPhysicalDevice() -->is failed to select the required device with graphics enabled\n");
        fflush(gpFile);
    }
    
    
    memset((void*)&vkPhysicalDeviceMemoryProperties, 0, sizeof(VkPhysicalDeviceMemoryProperties));
    vkGetPhysicalDeviceMemoryProperties(vkPhysicalDevice_selected, 
                                        &vkPhysicalDeviceMemoryProperties);
                                        
    VkPhysicalDeviceFeatures vkPhysicalDeviceFeatures;
    memset((void*)&vkPhysicalDeviceFeatures, 0, sizeof(VkPhysicalDeviceFeatures));
    
    vkGetPhysicalDeviceFeatures(vkPhysicalDevice_selected, 
                                &vkPhysicalDeviceFeatures);
                                
    if(vkPhysicalDeviceFeatures.tessellationShader)
    {
        fprintf(gpFile, "getPhysicalDevice() -->selected device supports tessellationShader\n");
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "getPhysicalDevice() -->selected device not supports tessellationShader\n");
        fflush(gpFile);
    }
    
    if(vkPhysicalDeviceFeatures.geometryShader)
    {
        fprintf(gpFile, "getPhysicalDevice() -->selected device supports geometryShader\n");
        fflush(gpFile);
    }
    else
    {
        fprintf(gpFile, "getPhysicalDevice() -->selected device not supports geometryShader\n");
        fflush(gpFile);
    }
    
    return vkResult;
}


VkResult printVkInfo(void)
{
    //local variable declaration
    VkResult vkResult = VK_SUCCESS;
    
    //code
    fprintf(gpFile, "*******************VULKAN INFORMATION*********************\n");
    fflush(gpFile);
    for(uint32_t i = 0; i < physicalDeviceCount; i++)    
    {
        fprintf(gpFile, "Infomration of Device = %d\n", i);
        fflush(gpFile);
        
        VkPhysicalDeviceProperties vkPhysicalDeviceProperties;
        memset((void*)&vkPhysicalDeviceProperties, 0, sizeof(VkPhysicalDeviceProperties));
        
        vkGetPhysicalDeviceProperties(vkPhysicalDevice_array[i], &vkPhysicalDeviceProperties);
        
        uint32_t majorVersion = VK_API_VERSION_MAJOR(vkPhysicalDeviceProperties.apiVersion);
        uint32_t minorVersion = VK_API_VERSION_MINOR(vkPhysicalDeviceProperties.apiVersion);;
        uint32_t patchVersion = VK_API_VERSION_PATCH(vkPhysicalDeviceProperties.apiVersion);;
        //API Version
        fprintf(gpFile, "apiVersion = %d.%d.%d\n", majorVersion, minorVersion, patchVersion);
        fflush(gpFile);
        
        //Device Name
        fprintf(gpFile, "DeviceName = %s\n", vkPhysicalDeviceProperties.deviceName);
        fflush(gpFile);
        
        //DeviceType
        switch(vkPhysicalDeviceProperties.deviceType)
        {
            case(VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU):
                fprintf(gpFile, "DeviceType = Integrated GPU(iGPU)\n");
                fflush(gpFile);
                break;
            
            case(VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU):
                fprintf(gpFile, "DeviceType = Discrete GPU(dGPU)\n");
                fflush(gpFile);
                break;
                
            case(VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU):
                fprintf(gpFile, "DeviceType = Virtual GPU(vGPU)\n");
                fflush(gpFile);
                break;
                
            case(VK_PHYSICAL_DEVICE_TYPE_CPU):
                fprintf(gpFile, "DeviceType = CPU\n");
                fflush(gpFile);
                break;    
                
            case(VK_PHYSICAL_DEVICE_TYPE_OTHER):
                fprintf(gpFile, "DeviceType = Other\n");
                fflush(gpFile);
                break; 
                
            default: 
                fprintf(gpFile, "DeviceType = UNKNOWN\n");  
                fflush(gpFile);              
        }
        
        //Vendor Id
        fprintf(gpFile, "VendorId = 0x%04x\n", vkPhysicalDeviceProperties.vendorID);
        fflush(gpFile);
        
        //DeviceId
        fprintf(gpFile, "DeviceId = 0x%04x\n\n", vkPhysicalDeviceProperties.deviceID);
        fflush(gpFile);
   }
   
   fprintf(gpFile, "****************END OF VULKAN INFORMATION********************\n");
   fflush(gpFile);
   
    //Freephysical device array
    if(vkPhysicalDevice_array)
    {
        free(vkPhysicalDevice_array);
        vkPhysicalDevice_array = NULL;
        fprintf(gpFile, "printVkInfo() --> vkPhysicalDevice_array succedded to free\n");
        fflush(gpFile);
    }
    
    return vkResult;
}


VkResult fillDeviceExtensionNames(void)
{
    //variable declaration
    VkResult vkResult = VK_SUCCESS;

    //Step1: Find how many Device Extension are supported by the vulkan driver of this version and keep the count in local variable
    uint32_t deviceExtensionCount = 0;

    vkResult = vkEnumerateDeviceExtensionProperties(vkPhysicalDevice_selected,
                                                    NULL,  //Layer name: All layers
                                                    &deviceExtensionCount,
                                                    NULL); // Device Extensions Properties array: As we dont have count, so its NULL
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "fillDeviceExtensionNames() --> 1st call to vkEnumerateDeviceExtensionProperties() is failed: %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "fillDeviceExtensionNames() --> 1st call to vkEnumerateDeviceExtensionProperties() is succedded\n");
        fprintf(gpFile, "deviceExtensionCount is %u\n", deviceExtensionCount);
        fflush(gpFile);
    }


    //Step2: Allocate and fill VkExtensionProperties corresponding to above count
    VkExtensionProperties* vkExtensionProperties_array = NULL;
    vkExtensionProperties_array = (VkExtensionProperties*) malloc (sizeof(VkExtensionProperties) * deviceExtensionCount);
    //Should be error checking for malloc: assert() can also be used

    vkResult = vkEnumerateDeviceExtensionProperties(vkPhysicalDevice_selected,
                                                    NULL, //Which layer's extenion is needed: Mention extension name: For all driver's extension use NULL
                                                    &deviceExtensionCount,
                                                    vkExtensionProperties_array); // Instance Extensions Properties array: As we have count, so it is value
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "fillDeviceExtensionNames() --> 2nd call to vkEnumerateDeviceExtensionProperties() is failed: %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "fillDeviceExtensionNames() --> 2nd call to vkEnumerateDeviceExtensionProperties() is succedded\n");
        fflush(gpFile);
    }



    //Step3: Fill and Display a local string array of extension names obtained from vkExtensionProperties
    char** deviceExtensionNames_array = NULL;

    deviceExtensionNames_array = (char**)malloc(sizeof(char*) * deviceExtensionCount);
    //Should be error checking for malloc: assert() can also be used
    for(uint32_t i = 0; i < deviceExtensionCount; i++)
    {
        deviceExtensionNames_array[i] = (char*)malloc(sizeof(char) * strlen(vkExtensionProperties_array[i].extensionName) + 1);
        memcpy(deviceExtensionNames_array[i], vkExtensionProperties_array[i].extensionName, strlen(vkExtensionProperties_array[i].extensionName) + 1);
        fprintf(gpFile, "fillDeviceExtensionNames() --> Vulkan Device Extension names = %s\n", deviceExtensionNames_array[i]);
        fflush(gpFile);
    }



   //Step4: As not required henceforth, free the vkExtensionProperties_array;
   free(vkExtensionProperties_array);
   vkExtensionProperties_array = NULL;



   // Step5: Find whether below extension names contains our required two extensions
   //VK_KHR_SWAPCHAIN_EXTENSION_NAME
   VkBool32 vulkanSwapChainExtensionFound = VK_FALSE;
  
    for(uint32_t i = 0; i < deviceExtensionCount; i++)
    {
        if(strcmp(deviceExtensionNames_array[i], VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0)
        {
            vulkanSwapChainExtensionFound = VK_TRUE;
            enabledDeviceExtensionNames_array[enabledDeviceExtensionCount++] = VK_KHR_SWAPCHAIN_EXTENSION_NAME;
        }
    }



    //Step 6:
    //As not required henceforth, free the local string array
    for(uint32_t i = 0; i < deviceExtensionCount; i++)
    {
        free(deviceExtensionNames_array[i]);
    }
    free(deviceExtensionNames_array);



    //Step7:Print whether our vulkan driver supports our required extension names or not
    if(vulkanSwapChainExtensionFound == VK_FALSE)
    {
        // return hardcoded failure
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        fprintf(gpFile, "fillDeviceExtensionNames() --> VK_KHR_SWAPCHAIN_EXTENSION_NAME not found\n");
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "fillDeviceExtensionNames() --> VK_KHR_SWAPCHAIN_EXTENSION_NAME found\n");
        fflush(gpFile);
    }


    //Step8: Print only Enabled Extension Names
    for(uint32_t i = 0; i < enabledDeviceExtensionCount; i++)
    {
        fprintf(gpFile, "fillDeviceExtensionNames() --> Enabled vulkan Device extension Names = %s\n", enabledDeviceExtensionNames_array[i]);
        fflush(gpFile);
    }

    return vkResult;
}


VkResult createVulkanDevice(void)
{  
    //Function declarations
    VkResult fillDeviceExtensionNames(void);
    
    //variable declaration
    VkResult vkResult = VK_SUCCESS;
    
    //Fill Device Extensions
    vkResult = fillDeviceExtensionNames();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVulkanDevice() --> fillDeviceExtensionNames() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVulkanDevice() --> fillDeviceExtensionNames() is succedded\n");
        fflush(gpFile);
    }
    
    /////Newly added code//////
    
    float QueuePriorities[] = {1.0};
    VkDeviceQueueCreateInfo vkDeviceQueueCreateInfo;
    memset((void*)&vkDeviceQueueCreateInfo, 0, sizeof(VkDeviceQueueCreateInfo));
    vkDeviceQueueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    vkDeviceQueueCreateInfo.pNext = NULL;
    vkDeviceQueueCreateInfo.flags = 0;
    vkDeviceQueueCreateInfo.queueFamilyIndex = graphicsQueueFamilyIndex_selected;
    vkDeviceQueueCreateInfo.queueCount = 1;
    vkDeviceQueueCreateInfo.pQueuePriorities = QueuePriorities;
    
    //Initialize VkDeviceCreateinfo structure
    VkDeviceCreateInfo vkDeviceCreateInfo;
    memset((void*)&vkDeviceCreateInfo, 0, sizeof(VkDeviceCreateInfo));
    
    vkDeviceCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    vkDeviceCreateInfo.pNext = NULL;
    vkDeviceCreateInfo.flags = 0;
    vkDeviceCreateInfo.enabledExtensionCount = enabledDeviceExtensionCount;
    vkDeviceCreateInfo.ppEnabledExtensionNames = enabledDeviceExtensionNames_array;
    vkDeviceCreateInfo.enabledLayerCount = 0;  // Deprecated
    vkDeviceCreateInfo.ppEnabledLayerNames = NULL;  // Deprecated
    vkDeviceCreateInfo.pEnabledFeatures = NULL;
    vkDeviceCreateInfo.queueCreateInfoCount = 1;
    vkDeviceCreateInfo.pQueueCreateInfos = &vkDeviceQueueCreateInfo;
        
    vkResult = vkCreateDevice(vkPhysicalDevice_selected,
                              &vkDeviceCreateInfo,
                              NULL,
                              &vkDevice);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVulkanDevice() --> vkCreateDevice() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVulkanDevice() --> vkCreateDevice() is succedded\n");
        fflush(gpFile);
    }                     
    
    return vkResult;
}


void getDeviceQueue(void)
{
    //code
    vkGetDeviceQueue(vkDevice, 
                     graphicsQueueFamilyIndex_selected,
                     0, //0th Queue index in that family queue
                     &vkQueue);
    if(vkQueue == VK_NULL_HANDLE) //rarest possibility
    {
        fprintf(gpFile, "getDeviceQueue() --> vkGetDeviceQueue() returned NULL for vkQueue\n");
        fflush(gpFile);
        return;
    }
    else
    {
        fprintf(gpFile, "getDeviceQueue() --> vkGetDeviceQueue() is succedded\n");
        fflush(gpFile);
    }
}


VkResult getPhysicalDeviceSurfaceFormatAndColorSpace(void)
{
    //variable declarations
    VkResult vkResult = VK_SUCCESS;   
    uint32_t formatCount = 0;
    
    //code
    //get the count of supported SurfaceColorFormats
    vkResult = vkGetPhysicalDeviceSurfaceFormatsKHR(vkPhysicalDevice_selected,
                                                    vkSurfaceKHR,
                                                    &formatCount,
                                                    NULL);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "getPhysicalDeviceSurfaceFormatAndColorSpace() --> 1st call to vkGetPhysicalDeviceSurfaceFormatsKHR() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else if(formatCount == 0)
    {
        fprintf(gpFile, "getPhysicalDeviceSurfaceFormatAndColorSpace() --> 1st call to vkGetPhysicalDeviceSurfaceFormatsKHR() is failed as formatCount is zero:: %d\n", vkResult);
        fflush(gpFile);
        return VK_ERROR_INITIALIZATION_FAILED;
    }
    else
    {
        fprintf(gpFile, "getPhysicalDeviceSurfaceFormatAndColorSpace() --> 1st call to vkGetPhysicalDeviceSurfaceFormatsKHR() is succedded\n");
        fflush(gpFile);
    }
    
    fprintf(gpFile, "getPhysicalDeviceSurfaceFormatAndColorSpace() --> total formatCount are:: %d\n", formatCount);
    fflush(gpFile);
    
    VkSurfaceFormatKHR* vkSurfaceFormatKHR_array = (VkSurfaceFormatKHR*) malloc(formatCount * sizeof(VkSurfaceFormatKHR));
    //Malloc error checking
    
    //Fillig the array
    vkResult = vkGetPhysicalDeviceSurfaceFormatsKHR(vkPhysicalDevice_selected,
                                                    vkSurfaceKHR,
                                                    &formatCount,
                                                    vkSurfaceFormatKHR_array);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "getPhysicalDeviceSurfaceFormatAndColorSpace() --> 2nd call to vkGetPhysicalDeviceSurfaceFormatsKHR() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "getPhysicalDeviceSurfaceFormatAndColorSpace() --> 2nd call to vkGetPhysicalDeviceSurfaceFormatsKHR() is succedded\n");
        fflush(gpFile);
    }
    
    if(formatCount == 1 && vkSurfaceFormatKHR_array[0].format == VK_FORMAT_UNDEFINED) //bydefault it is not there
    {
        vkFormat_color = VK_FORMAT_B8G8R8A8_UNORM;
        fprintf(gpFile, "getPhysicalDeviceSurfaceFormatAndColorSpace() --> vkFormat_color is VK_FORMAT_B8G8R8A8_UNORM\n");
        fflush(gpFile);
    }
    else
    {
        vkFormat_color = vkSurfaceFormatKHR_array[0].format;
        fprintf(gpFile, "getPhysicalDeviceSurfaceFormatAndColorSpace() --> vkFormat_color is %d\n", vkFormat_color);
        fflush(gpFile);
    }
    
    //Decide the ColorSpace
    vkColorSpaceKHR = vkSurfaceFormatKHR_array[0].colorSpace;
    
    if(vkSurfaceFormatKHR_array)
    {
        free(vkSurfaceFormatKHR_array);
        vkSurfaceFormatKHR_array = NULL;
        fprintf(gpFile, "getPhysicalDeviceSurfaceFormatAndColorSpace() --> vkSurfaceFormatKHR_array is freed\n");
        fflush(gpFile);
    }
    
    return vkResult;
}


VkResult getPhysicalDevicePresentMode(void)
{
    //variable declarations
    VkResult vkResult = VK_SUCCESS;   
    
    uint32_t presentModeCount = 0;
    
    //code
    vkResult = vkGetPhysicalDeviceSurfacePresentModesKHR(vkPhysicalDevice_selected,
                                                         vkSurfaceKHR,
                                                         &presentModeCount,
                                                         NULL);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "getPhysicalDevicePresentMode() --> 1st call to vkGetPhysicalDeviceSurfacePresentModesKHR() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else if(presentModeCount == 0)
    {
        fprintf(gpFile, "getPhysicalDevicePresentMode() --> 1st call to vkGetPhysicalDeviceSurfacePresentModesKHR() is failed as formatCount is zero:: %d\n", vkResult);
        fflush(gpFile);
        return VK_ERROR_INITIALIZATION_FAILED;
    }
    else
    {
        fprintf(gpFile, "getPhysicalDevicePresentMode() --> 1st call to vkGetPhysicalDeviceSurfacePresentModesKHR() is succedded\n");
        fflush(gpFile);
    }   

    fprintf(gpFile, "getPhysicalDevicePresentMode() --> total presentModeCount are:: %d\n", presentModeCount);
    fflush(gpFile);

    VkPresentModeKHR* vkPresentModeKHR_array = (VkPresentModeKHR*) malloc(presentModeCount * sizeof(VkPresentModeKHR));
    //Malloc error checking
    
    vkResult = vkGetPhysicalDeviceSurfacePresentModesKHR(vkPhysicalDevice_selected,
                                                         vkSurfaceKHR,
                                                         &presentModeCount,
                                                         vkPresentModeKHR_array);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "getPhysicalDevicePresentMode() --> 2nd call to vkGetPhysicalDeviceSurfacePresentModesKHR() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "getPhysicalDevicePresentMode() --> 2nd call to vkGetPhysicalDeviceSurfacePresentModesKHR() is succedded\n");
        fflush(gpFile);
    }
    
    //Decide Presentation mode
    for(uint32_t i = 0; i < presentModeCount; i++)
    {
        if(vkPresentModeKHR_array[i] == VK_PRESENT_MODE_MAILBOX_KHR)
        {
            vkPresentModeKHR = VK_PRESENT_MODE_MAILBOX_KHR;
            fprintf(gpFile, "getPhysicalDevicePresentMode() --> vkPresentModeKHR is VK_PRESENT_MODE_MAILBOX_KHR\n");
            fflush(gpFile);
            break;
        }
    }
    
    if(vkPresentModeKHR != VK_PRESENT_MODE_MAILBOX_KHR)
    {
        vkPresentModeKHR = VK_PRESENT_MODE_FIFO_KHR;
        fprintf(gpFile, "getPhysicalDevicePresentMode() --> vkPresentModeKHR is VK_PRESENT_MODE_FIFO_KHR\n");   
        fflush(gpFile);
    }
  
    
    if(vkPresentModeKHR_array)
    {
        free(vkPresentModeKHR_array);
        vkPresentModeKHR_array = NULL;
        fprintf(gpFile, "getPhysicalDevicePresentMode() --> vkPresentModeKHR_array is freed\n");
        fflush(gpFile);
    }
    
    return vkResult;
  
}


VkResult createSwapchain(VkBool32 vsync)  // vertical sync
{
    //fucntion Declarations
    VkResult getPhysicalDeviceSurfaceFormatAndColorSpace(void);
    VkResult getPhysicalDevicePresentMode(void);
    
    //variables
    VkResult vkResult = VK_SUCCESS;
        
    //code
    //Color Format and ColorSpace
    vkResult = getPhysicalDeviceSurfaceFormatAndColorSpace();
    /*Main Points
        vkGetPhysicalDeviceSurfaceFormatsKHR()
    */
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createSwapchain() --> getPhysicalDeviceSurfaceFormatAndColorSpace() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createSwapchain() --> getPhysicalDeviceSurfaceFormatAndColorSpace() is succedded\n");
        fflush(gpFile);
    }
   
   
    //Step 2:
    VkSurfaceCapabilitiesKHR vkSurfaceCapabilitiesKHR;
    memset((void*)&vkSurfaceCapabilitiesKHR, 0, sizeof(VkSurfaceCapabilitiesKHR));
    
    vkResult = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(vkPhysicalDevice_selected,
                                                         vkSurfaceKHR,
                                                         &vkSurfaceCapabilitiesKHR);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createSwapchain() --> vkGetPhysicalDeviceSurfaceCapabilitiesKHR() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createSwapchain() --> vkGetPhysicalDeviceSurfaceCapabilitiesKHR() is succedded\n");
        fflush(gpFile);
    }
   
    //Step3: Find out desired swapchain image count
    uint32_t testingNumberOfSwapchainImages = vkSurfaceCapabilitiesKHR.minImageCount + 1;
    uint32_t desiredNumbeOfSwapchainImages = 0;
    
    
    if(vkSurfaceCapabilitiesKHR.maxImageCount > 0 && vkSurfaceCapabilitiesKHR.maxImageCount < testingNumberOfSwapchainImages)
    {
        desiredNumbeOfSwapchainImages = vkSurfaceCapabilitiesKHR.maxImageCount;
    }
    else
    {
        desiredNumbeOfSwapchainImages = vkSurfaceCapabilitiesKHR.minImageCount;
    }
    
    //Step4: Choose size of swapchain image
    memset((void*)&vkExtent2D_swapchain, 0, sizeof(VkExtent2D));
    if(vkSurfaceCapabilitiesKHR.currentExtent.width != UINT32_MAX)
    {
        vkExtent2D_swapchain.width = vkSurfaceCapabilitiesKHR.currentExtent.width;
        vkExtent2D_swapchain.height = vkSurfaceCapabilitiesKHR.currentExtent.height;
        
        fprintf(gpFile, "createSwapchain() --> Swapchain image width X height = %d X %d \n", vkExtent2D_swapchain.width, vkExtent2D_swapchain.height);
        fflush(gpFile);
    }
    else
    {
        // if surface is already defined then swapchain image size must match with it
        VkExtent2D vkExtent2D;
        memset((void*)&vkExtent2D, 0 , sizeof(VkExtent2D));
        vkExtent2D.width = (uint32_t)winWidth;
        vkExtent2D.height = (uint32_t)winHeight;
        
        vkExtent2D_swapchain.width = glm::max(vkSurfaceCapabilitiesKHR.minImageExtent.width, glm::min(vkSurfaceCapabilitiesKHR.maxImageExtent.width, vkExtent2D.width));
        vkExtent2D_swapchain.height = glm::max(vkSurfaceCapabilitiesKHR.minImageExtent.height, glm::min(vkSurfaceCapabilitiesKHR.maxImageExtent.height, vkExtent2D.height));
        
        fprintf(gpFile, "createSwapchain() --> Swapchain image width X height = %d X %d \n", vkExtent2D_swapchain.width, vkExtent2D_swapchain.height);
        fflush(gpFile);
    }
    
    //step5: Set SwapchainImageUsageFlag
    VkImageUsageFlags vkImageUsageFlags = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT/*Texture, Compute, FBO*/; 
    
    //enum
    VkSurfaceTransformFlagBitsKHR vkSurfaceTransformFlagBitsKHR;
    if(vkSurfaceCapabilitiesKHR.supportedTransforms & VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
    {
        vkSurfaceTransformFlagBitsKHR = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
    }
    else
    {
        vkSurfaceTransformFlagBitsKHR = vkSurfaceCapabilitiesKHR.currentTransform;
    }
   
    
    //Step 7: Presentation mode
    vkResult = getPhysicalDevicePresentMode();
    /*Main Points
        
    */
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createSwapchain() --> getPhysicalDevicePresentMode() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createSwapchain() --> getPhysicalDevicePresentMode() is succedded\n");
        fflush(gpFile);
    }
    
    //Step 8: Initialie vkCreateSwapchinCreateInfoStructure
    VkSwapchainCreateInfoKHR vkSwapchainCreateInfoKHR;
    memset((void*)&vkSwapchainCreateInfoKHR, 0 , sizeof(VkSwapchainCreateInfoKHR));
    vkSwapchainCreateInfoKHR.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    vkSwapchainCreateInfoKHR.pNext = NULL;
    vkSwapchainCreateInfoKHR.flags = 0;
    vkSwapchainCreateInfoKHR.surface = vkSurfaceKHR;
    vkSwapchainCreateInfoKHR.minImageCount = desiredNumbeOfSwapchainImages;
    vkSwapchainCreateInfoKHR.imageFormat = vkFormat_color;
    vkSwapchainCreateInfoKHR.imageColorSpace = vkColorSpaceKHR;
    vkSwapchainCreateInfoKHR.imageExtent.width = vkExtent2D_swapchain.width;
    vkSwapchainCreateInfoKHR.imageExtent.height = vkExtent2D_swapchain.height;
    vkSwapchainCreateInfoKHR.imageUsage = vkImageUsageFlags;
    vkSwapchainCreateInfoKHR.preTransform = vkSurfaceTransformFlagBitsKHR;
    vkSwapchainCreateInfoKHR.imageArrayLayers = 1;
    vkSwapchainCreateInfoKHR.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
    vkSwapchainCreateInfoKHR.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    vkSwapchainCreateInfoKHR.presentMode = vkPresentModeKHR;
    vkSwapchainCreateInfoKHR.clipped = VK_TRUE;
    
    //Step9:
    vkResult = vkCreateSwapchainKHR(vkDevice,
                                    &vkSwapchainCreateInfoKHR,
                                    NULL,
                                    &vkSwapchainKHR);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createSwapchain() --> vkCreateSwapchainKHR() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createSwapchain() --> vkCreateSwapchainKHR() is succedded\n");
        fflush(gpFile);
    }
    
    return vkResult;
}


VkResult createImagesAndImageViews(void)
{
    //fuction  declarations
    VkResult GetSupportedDepthFormat(void);
    
    //variables
    VkResult vkResult = VK_SUCCESS;
    
    //step1: Get desired SwapchainImage count
    vkResult = vkGetSwapchainImagesKHR(vkDevice, 
                                       vkSwapchainKHR,
                                       &swapchainImageCount,
                                       NULL);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createImagesAndImageViews() --> 1st call to vkGetSwapchainImagesKHR() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else if(0 == swapchainImageCount)
    {
        fprintf(gpFile, "createImagesAndImageViews() --> 1st call to vkGetSwapchainImagesKHR() is failed %d\n", vkResult);
        fflush(gpFile);
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createImagesAndImageViews() --> gives swapchainImagecount = %d\n", swapchainImageCount);
        fprintf(gpFile, "createImagesAndImageViews() --> vkGetSwapchainImagesKHR() is succedded\n");
        fflush(gpFile);
    }
    
    
    //step2: Allocate the swapchain Image array
    swapchainImage_array = (VkImage*)malloc(sizeof(VkImage) * swapchainImageCount);
    //malloc check to be done

    //step3: fill this array by swapchain imagesize
    vkResult = vkGetSwapchainImagesKHR(vkDevice, 
                                       vkSwapchainKHR,
                                       &swapchainImageCount,
                                       swapchainImage_array);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createImagesAndImageViews() --> 2nd call to vkGetSwapchainImagesKHR() is failed %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createImagesAndImageViews() --> 2nd call to vkGetSwapchainImagesKHR() is succedded\n");
        fflush(gpFile);
    }
    
    //step4: allocate array of swapchainImageViews   
    swapchainImageView_array = (VkImageView*)malloc(sizeof(VkImageView) * swapchainImageCount);
    //malloc check to be done
    
    //step5: Initialize vkImageViewCreateInfo structure
    VkImageViewCreateInfo vkImageViewCreateInfo;
    memset((void*)&vkImageViewCreateInfo, 0, sizeof(VkImageViewCreateInfo));

    vkImageViewCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    vkImageViewCreateInfo.pNext = NULL;
    vkImageViewCreateInfo.flags = 0;
    vkImageViewCreateInfo.format = vkFormat_color;
    vkImageViewCreateInfo.components.r = VK_COMPONENT_SWIZZLE_R;
    vkImageViewCreateInfo.components.g = VK_COMPONENT_SWIZZLE_G;
    vkImageViewCreateInfo.components.b = VK_COMPONENT_SWIZZLE_B;
    vkImageViewCreateInfo.components.a = VK_COMPONENT_SWIZZLE_A;
    vkImageViewCreateInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    vkImageViewCreateInfo.subresourceRange.baseMipLevel = 0;
    vkImageViewCreateInfo.subresourceRange.levelCount = 1;
    vkImageViewCreateInfo.subresourceRange.baseArrayLayer = 0;
    vkImageViewCreateInfo.subresourceRange.layerCount = 1;
    vkImageViewCreateInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    
    //Step6: Fill Imageview Array by using above struct
    for(uint32_t i = 0; i < swapchainImageCount; i++)
    {
        vkImageViewCreateInfo.image = swapchainImage_array[i];
        
        vkResult = vkCreateImageView(vkDevice,
                                 &vkImageViewCreateInfo,
                                 NULL,
                                 &swapchainImageView_array[i]);
        if(vkResult != VK_SUCCESS)
        {
            fprintf(gpFile, "createImagesAndImageViews() --> vkCreateImageViews() is failed for iteration %d and error code is %d\n", i, vkResult);
            fflush(gpFile);
            return vkResult;
        }
        else
        {
            fprintf(gpFile, "createImagesAndImageViews() --> vkCreateImageViews() is succedded for iteration for %d\n", i);
            fflush(gpFile);
        }
    }
    
    //for depth image
    vkResult = GetSupportedDepthFormat();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createImagesAndImageViews() --> GetSupportedDepthFormat() is failed error code is %d\n",vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createImagesAndImageViews() --> GetSupportedDepthFormat() is succedded\n");
        fflush(gpFile);
    }
    
    //for depth image Initialize VkImageCreateInfo
    VkImageCreateInfo vkImageCreateInfo;
    memset((void*)&vkImageCreateInfo, 0, sizeof(VkImageCreateInfo));
    vkImageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    vkImageCreateInfo.pNext = NULL;
    vkImageCreateInfo.flags = 0;
    vkImageCreateInfo.imageType = VK_IMAGE_TYPE_2D;
    vkImageCreateInfo.format = vkFormat_depth;
    vkImageCreateInfo.extent.width = winWidth;
    vkImageCreateInfo.extent.height = winHeight;
    vkImageCreateInfo.extent.depth = 1;
    vkImageCreateInfo.mipLevels = 1;
    vkImageCreateInfo.arrayLayers = 1;
    vkImageCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    vkImageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
    vkImageCreateInfo.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;

    vkResult = vkCreateImage(vkDevice, &vkImageCreateInfo, NULL, &vkImage_depth);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createImagesAndImageViews() --> vkCreateImage() is failed error code is %d\n",vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createImagesAndImageViews() --> vkCreateImage() is succedded\n");
        fflush(gpFile);
    }
    
    //Memory requirement for depth image
    
    VkMemoryRequirements vkMemoryRequirements;
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetImageMemoryRequirements(vkDevice, vkImage_depth, &vkMemoryRequirements);
    
    //8" Allocate
    VkMemoryAllocateInfo vkMemoryAllocateInfo;
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vkDeviceMemory_depth);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createImagesAndImageViews() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createImagesAndImageViews() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindImageMemory(vkDevice, vkImage_depth, vkDeviceMemory_depth, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createImagesAndImageViews() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createImagesAndImageViews() --> vkBindBufferMemory() is succedded\n");
        fflush(gpFile);
    }
    
    
    //create image view for above depth image
    memset((void*)&vkImageViewCreateInfo, 0, sizeof(VkImageViewCreateInfo));

    vkImageViewCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    vkImageViewCreateInfo.pNext = NULL;
    vkImageViewCreateInfo.flags = 0;
    vkImageViewCreateInfo.format = vkFormat_depth;
    vkImageViewCreateInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT;
    vkImageViewCreateInfo.subresourceRange.baseMipLevel = 0;
    vkImageViewCreateInfo.subresourceRange.levelCount = 1;
    vkImageViewCreateInfo.subresourceRange.baseArrayLayer = 0;
    vkImageViewCreateInfo.subresourceRange.layerCount = 1;
    vkImageViewCreateInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    vkImageViewCreateInfo.image = vkImage_depth;
    
    vkResult = vkCreateImageView(vkDevice,
                                 &vkImageViewCreateInfo,
                                 NULL,
                                 &vkImageView_depth);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createImagesAndImageViews() --> vkCreateImageView() is failed error code is %d\n",vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createImagesAndImageViews() --> vkCreateImageView() is succedded\n");
        fflush(gpFile);
    }
    
    
    return vkResult;
}


VkResult GetSupportedDepthFormat(void)
{
    //code
    //variables
    VkResult vkResult = VK_SUCCESS;
    VkFormat vkFormat_depth_array[] = { VK_FORMAT_D32_SFLOAT_S8_UINT, 
                                       VK_FORMAT_D32_SFLOAT,
                                       VK_FORMAT_D24_UNORM_S8_UINT,
                                       VK_FORMAT_D16_UNORM_S8_UINT,
                                       VK_FORMAT_D16_UNORM };
    
    for(uint32_t i = 0; i < (sizeof(vkFormat_depth_array)/sizeof(vkFormat_depth_array[0])); i++)
    {
        VkFormatProperties vkFormatProperties;
        memset((void*)&vkFormatProperties, 0, sizeof(VkFormatProperties));
        
        vkGetPhysicalDeviceFormatProperties(vkPhysicalDevice_selected, vkFormat_depth_array[i], &vkFormatProperties);
        
        if(vkFormatProperties.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT)
        {
           vkFormat_depth = vkFormat_depth_array[i];
           vkResult = VK_SUCCESS;
           break;
        }
    }
    
   return vkResult;
}


VkResult createCommandPool(void)
{
    //variables
   VkResult vkResult = VK_SUCCESS;
    
   //code
   VkCommandPoolCreateInfo vkCommandPoolCreateInfo;
   memset((void*)&vkCommandPoolCreateInfo, 0, sizeof(VkCommandPoolCreateInfo));
   
   vkCommandPoolCreateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
   vkCommandPoolCreateInfo.pNext = NULL;
   vkCommandPoolCreateInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT; //such command buffers will be resetted and resatrted, and these command buffers are long lived
   vkCommandPoolCreateInfo.queueFamilyIndex = graphicsQueueFamilyIndex_selected;
   
   vkResult = vkCreateCommandPool(vkDevice, 
                                  &vkCommandPoolCreateInfo,
                                  NULL,
                                  &vkCommandPool);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createCommandPool() --> vkCreateCommandPool() is failed and error code is %d\n",vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createCommandPool() --> vkCreateCommandPool() is succedded \n");
        fflush(gpFile);
    }

   return vkResult;   
}


VkResult createCommandBuffers(void)
{
   //variables
   VkResult vkResult = VK_SUCCESS;
   
   //code
   //vkCommandBuffer allocate info structure initliazation
   VkCommandBufferAllocateInfo vkCommandBufferAllocateInfo; 
   memset((void*)&vkCommandBufferAllocateInfo, 0, sizeof(VkCommandBufferAllocateInfo));
   
   vkCommandBufferAllocateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
   vkCommandBufferAllocateInfo.pNext = NULL;
   vkCommandBufferAllocateInfo.commandPool = vkCommandPool;
   vkCommandBufferAllocateInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
   vkCommandBufferAllocateInfo.commandBufferCount = 1;
   
   vkCommandBuffer_array = (VkCommandBuffer*)malloc(sizeof(VkCommandBuffer) * swapchainImageCount);
   //malloc check to be done
   
   for(uint32_t i = 0; i < swapchainImageCount; i++)
    {
        vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo, &vkCommandBuffer_array[i]);
        if(vkResult != VK_SUCCESS)
        {
            fprintf(gpFile, "createCommandBuffers() --> vkAllocateCommandBuffers() is failed for %d iteration and error code is %d\n",i, vkResult);
            fflush(gpFile);
            return vkResult;
        }
        else
        {
            fprintf(gpFile, "createCommandBuffers() --> vkAllocateCommandBuffers() is succedded for iteration %d\n", i);
            fflush(gpFile);
        }
    }
   
   return vkResult;   
}

VkResult createVertexBuffer(void)
{
    //variable
    VkResult vkResult = VK_SUCCESS; 
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_position_sun, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    VkBufferCreateInfo vkBufferCreateInfo;
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_vertices);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_position_sun.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for position \n");
        fflush(gpFile);
    }
    
    VkMemoryRequirements vkMemoryRequirements;
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_position_sun.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    VkMemoryAllocateInfo vkMemoryAllocateInfo;
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_position_sun.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_position_sun.vkBuffer, vertexData_position_sun.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#11
    void* data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_position_sun.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for position \n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_vertices, sizeof(sphere_vertices));
    
    vkUnmapMemory(vkDevice, vertexData_position_sun.vkDeviceMemory);
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_texcoord_sun, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_textures);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_texcoord_sun.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_texcoord_sun.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_texcoord_sun.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_texcoord_sun.vkBuffer, vertexData_texcoord_sun.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_texcoord_sun.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_textures, sizeof(sphere_textures));
    
    vkUnmapMemory(vkDevice, vertexData_texcoord_sun.vkDeviceMemory);
   
   
    // Sphere
    // Normal
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_normal_sun, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_normals);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_normal_sun.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for normal\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_normal_sun.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_normal_sun.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_normal_sun.vkBuffer, vertexData_normal_sun.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_normal_sun.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for normal\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_normals, sizeof(sphere_normals));
    
    vkUnmapMemory(vkDevice, vertexData_normal_sun.vkDeviceMemory);
    
    
    /**********************************************MECRURY************************************************************/
    //#4 memset the global strucure variable
    memset((void*)&vertexData_position_mercury, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_vertices);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_position_mercury.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for position \n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_position_mercury.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_position_mercury.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_position_mercury.vkBuffer, vertexData_position_mercury.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_position_mercury.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for position \n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_vertices, sizeof(sphere_vertices));
    
    vkUnmapMemory(vkDevice, vertexData_position_mercury.vkDeviceMemory);
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_texcoord_mercury, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_textures);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_texcoord_mercury.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_texcoord_mercury.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_texcoord_mercury.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_texcoord_mercury.vkBuffer, vertexData_texcoord_mercury.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_texcoord_mercury.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_textures, sizeof(sphere_textures));
    
    vkUnmapMemory(vkDevice, vertexData_texcoord_mercury.vkDeviceMemory);
   
   
    // Sphere
    // Normal
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_normal_mercury, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_normals);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_normal_mercury.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for normal\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_normal_mercury.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_normal_mercury.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_normal_mercury.vkBuffer, vertexData_normal_mercury.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_normal_mercury.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for normal\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_normals, sizeof(sphere_normals));
    
    vkUnmapMemory(vkDevice, vertexData_normal_mercury.vkDeviceMemory);
    
    
    /**********************************************Venus************************************************************/
    //#4 memset the global strucure variable
    memset((void*)&vertexData_position_venus, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_vertices);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_position_venus.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for position \n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_position_venus.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_position_venus.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_position_venus.vkBuffer, vertexData_position_venus.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_position_venus.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for position \n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_vertices, sizeof(sphere_vertices));
    
    vkUnmapMemory(vkDevice, vertexData_position_venus.vkDeviceMemory);
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_texcoord_venus, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_textures);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_texcoord_venus.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_texcoord_venus.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_texcoord_venus.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_texcoord_venus.vkBuffer, vertexData_texcoord_venus.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for texcoord\n");
        fflush(gpFile); 
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_texcoord_venus.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_textures, sizeof(sphere_textures));
    
    vkUnmapMemory(vkDevice, vertexData_texcoord_venus.vkDeviceMemory);
   
   
    // Sphere
    // Normal
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_normal_venus, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_normals);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_normal_venus.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for normal\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_normal_venus.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_normal_venus.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_normal_venus.vkBuffer, vertexData_normal_venus.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_normal_venus.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for normal\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_normals, sizeof(sphere_normals));
    
    vkUnmapMemory(vkDevice, vertexData_normal_venus.vkDeviceMemory);
   
   
    /**********************************************earth************************************************************/
    //#4 memset the global strucure variable
    memset((void*)&vertexData_position_earth, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_vertices);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_position_earth.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for position \n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_position_earth.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_position_earth.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_position_earth.vkBuffer, vertexData_position_earth.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_position_earth.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for position \n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_vertices, sizeof(sphere_vertices));
    
    vkUnmapMemory(vkDevice, vertexData_position_earth.vkDeviceMemory);
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_texcoord_earth, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_textures);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_texcoord_earth.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_texcoord_earth.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_texcoord_earth.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_texcoord_earth.vkBuffer, vertexData_texcoord_earth.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_texcoord_earth.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_textures, sizeof(sphere_textures));
    
    vkUnmapMemory(vkDevice, vertexData_texcoord_earth.vkDeviceMemory);
   
   
    // Sphere
    // Normal
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_normal_earth, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_normals);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_normal_earth.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for normal\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_normal_earth.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_normal_earth.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_normal_earth.vkBuffer, vertexData_normal_earth.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_normal_earth.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for normal\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_normals, sizeof(sphere_normals));
    
    vkUnmapMemory(vkDevice, vertexData_normal_earth.vkDeviceMemory);
    
     /**********************************************mars************************************************************/
    //#4 memset the global strucure variable
    memset((void*)&vertexData_position_mars, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_vertices);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_position_mars.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for position \n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_position_mars.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_position_mars.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_position_mars.vkBuffer, vertexData_position_mars.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_position_mars.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for position \n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_vertices, sizeof(sphere_vertices));
    
    vkUnmapMemory(vkDevice, vertexData_position_mars.vkDeviceMemory);
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_texcoord_mars, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_textures);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_texcoord_mars.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_texcoord_mars.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_texcoord_mars.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_texcoord_mars.vkBuffer, vertexData_texcoord_mars.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_texcoord_mars.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_textures, sizeof(sphere_textures));
    
    vkUnmapMemory(vkDevice, vertexData_texcoord_mars.vkDeviceMemory);
   
   
    // Sphere
    // Normal
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_normal_mars, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_normals);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_normal_mars.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for normal\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_normal_mars.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_normal_mars.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_normal_mars.vkBuffer, vertexData_normal_mars.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_normal_mars.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for normal\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_normals, sizeof(sphere_normals));
    
    vkUnmapMemory(vkDevice, vertexData_normal_mars.vkDeviceMemory);
   
   
    /**********************************************jupitor************************************************************/
    //#4 memset the global strucure variable
    memset((void*)&vertexData_position_jupitor, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_vertices);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_position_jupitor.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for position \n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_position_jupitor.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_position_jupitor.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_position_jupitor.vkBuffer, vertexData_position_jupitor.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_position_jupitor.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for position \n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_vertices, sizeof(sphere_vertices));
    
    vkUnmapMemory(vkDevice, vertexData_position_jupitor.vkDeviceMemory);
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_texcoord_jupitor, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_textures);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_texcoord_jupitor.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_texcoord_jupitor.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_texcoord_jupitor.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_texcoord_jupitor.vkBuffer, vertexData_texcoord_jupitor.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_texcoord_jupitor.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_textures, sizeof(sphere_textures));
    
    vkUnmapMemory(vkDevice, vertexData_texcoord_jupitor.vkDeviceMemory);
   
   
    // Sphere
    // Normal
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_normal_jupitor, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_normals);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_normal_jupitor.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for normal\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_normal_jupitor.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_normal_jupitor.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_normal_jupitor.vkBuffer, vertexData_normal_jupitor.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_normal_jupitor.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for normal\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_normals, sizeof(sphere_normals));
    
    vkUnmapMemory(vkDevice, vertexData_normal_jupitor.vkDeviceMemory);
   
    /**********************************************saturn************************************************************/
    //#4 memset the global strucure variable
    memset((void*)&vertexData_position_saturn, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_vertices);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_position_saturn.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for position \n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_position_saturn.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_position_saturn.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_position_saturn.vkBuffer, vertexData_position_saturn.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_position_saturn.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for position \n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_vertices, sizeof(sphere_vertices));
    
    vkUnmapMemory(vkDevice, vertexData_position_saturn.vkDeviceMemory);
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_texcoord_saturn, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_textures);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_texcoord_saturn.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_texcoord_saturn.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_texcoord_saturn.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_texcoord_saturn.vkBuffer, vertexData_texcoord_saturn.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_texcoord_saturn.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_textures, sizeof(sphere_textures));
    
    vkUnmapMemory(vkDevice, vertexData_texcoord_saturn.vkDeviceMemory);
   
   
    // Sphere
    // Normal
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_normal_saturn, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_normals);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_normal_saturn.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for normal\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_normal_saturn.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_normal_saturn.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_normal_saturn.vkBuffer, vertexData_normal_saturn.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_normal_saturn.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for normal\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_normals, sizeof(sphere_normals));
    
    vkUnmapMemory(vkDevice, vertexData_normal_saturn.vkDeviceMemory);
   
    /**********************************************uranus************************************************************/
    //#4 memset the global strucure variable
    memset((void*)&vertexData_position_uranus, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_vertices);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_position_uranus.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for position \n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_position_uranus.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_position_uranus.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_position_uranus.vkBuffer, vertexData_position_uranus.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_position_uranus.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for position \n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_vertices, sizeof(sphere_vertices));
    
    vkUnmapMemory(vkDevice, vertexData_position_uranus.vkDeviceMemory);
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_texcoord_uranus, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_textures);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_texcoord_uranus.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_texcoord_uranus.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_texcoord_uranus.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_texcoord_uranus.vkBuffer, vertexData_texcoord_uranus.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_texcoord_uranus.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_textures, sizeof(sphere_textures));
    
    vkUnmapMemory(vkDevice, vertexData_texcoord_uranus.vkDeviceMemory);
   
   
    // Sphere
    // Normal
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_normal_uranus, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_normals);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_normal_uranus.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for normal\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_normal_uranus.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_normal_uranus.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_normal_uranus.vkBuffer, vertexData_normal_uranus.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_normal_uranus.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for normal\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_normals, sizeof(sphere_normals));
    
    vkUnmapMemory(vkDevice, vertexData_normal_uranus.vkDeviceMemory);
   
    /**********************************************neptune************************************************************/
    //#4 memset the global strucure variable
    memset((void*)&vertexData_position_neptune, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_vertices);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_position_neptune.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for position \n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_position_neptune.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_position_neptune.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_position_neptune.vkBuffer, vertexData_position_neptune.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for position \n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_position_neptune.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for position and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for position \n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_vertices, sizeof(sphere_vertices));
    
    vkUnmapMemory(vkDevice, vertexData_position_neptune.vkDeviceMemory);
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_texcoord_neptune, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_textures);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_texcoord_neptune.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_texcoord_neptune.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_texcoord_neptune.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_texcoord_neptune.vkBuffer, vertexData_texcoord_neptune.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_texcoord_neptune.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for texcoord and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for texcoord\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_textures, sizeof(sphere_textures));
    
    vkUnmapMemory(vkDevice, vertexData_texcoord_neptune.vkDeviceMemory);
   
   
    // Sphere
    // Normal
   
    
    //#4 memset the global strucure variable
    memset((void*)&vertexData_normal_neptune, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_normals);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_normal_neptune.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkCreateBuffer() is succedded for normal\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_normal_neptune.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_normal_neptune.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkAllocateMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_normal_neptune.vkBuffer, vertexData_normal_neptune.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkBindBufferMemory() is succedded for normal\n");
        fflush(gpFile);
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_normal_neptune.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is failed for normal and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createVertexBuffer() --> vkMapMemory() is succedded for normal\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_normals, sizeof(sphere_normals));
    
    vkUnmapMemory(vkDevice, vertexData_normal_neptune.vkDeviceMemory);
   
    return (vkResult);
}

VkResult createIndexBuffer(void)
{
    //variable
    VkResult vkResult = VK_SUCCESS;
    
    //POSITION INDEX BUFFER
    //#4 memset the global strucure variable
    memset((void*)&vertexData_index_sun, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    VkBufferCreateInfo vkBufferCreateInfo;
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_elements);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_index_sun.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is succedded\n");
        fflush(gpFile);
    }
    
    VkMemoryRequirements vkMemoryRequirements;
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_index_sun.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    VkMemoryAllocateInfo vkMemoryAllocateInfo;
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_index_sun.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is failed for rindex buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is succedded for index buffer\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_index_sun.vkBuffer, vertexData_index_sun.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is succedded for index buffer\n");
        fflush(gpFile);
    }
    
    //#11
    void* data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_index_sun.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is succedded for index buffer\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_elements, sizeof(sphere_elements));
    
    vkUnmapMemory(vkDevice, vertexData_index_sun.vkDeviceMemory);
    
    
    /******************************************Mercury*******************************************/
    
    //POSITION INDEX BUFFER
    //#4 memset the global strucure variable
    memset((void*)&vertexData_index_mercury, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_elements);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_index_mercury.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is succedded\n");
        fflush(gpFile);
    }
    

    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_index_mercury.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_index_mercury.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is failed for rindex buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is succedded for index buffer\n");
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_index_mercury.vkBuffer, vertexData_index_mercury.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is succedded for index buffer\n");
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_index_mercury.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is succedded for index buffer\n");
    }
   
    //#12
    memcpy(data, sphere_elements, sizeof(sphere_elements));
    
    vkUnmapMemory(vkDevice, vertexData_index_mercury.vkDeviceMemory);
    
    
    /******************************************venus*******************************************/
    
    //POSITION INDEX BUFFER
    //#4 memset the global strucure variable
    memset((void*)&vertexData_index_venus, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_elements);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_index_venus.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is succedded\n");
    }
    

    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_index_venus.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_index_venus.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is failed for rindex buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is succedded for index buffer\n");
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_index_venus.vkBuffer, vertexData_index_venus.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is succedded for index buffer\n");
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_index_venus.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is succedded for index buffer\n");
        fflush(gpFile);
    }
   
    //#12
    memcpy(data, sphere_elements, sizeof(sphere_elements));
    
    vkUnmapMemory(vkDevice, vertexData_index_venus.vkDeviceMemory);
    
    /******************************************earth*******************************************/
    
    //POSITION INDEX BUFFER
    //#4 memset the global strucure variable
    memset((void*)&vertexData_index_earth, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_elements);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_index_earth.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is succedded\n");
    }
    

    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_index_earth.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_index_earth.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is failed for rindex buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is succedded for index buffer\n");
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_index_earth.vkBuffer, vertexData_index_earth.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is succedded for index buffer\n");
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_index_earth.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is succedded for index buffer\n");
    }
   
    //#12
    memcpy(data, sphere_elements, sizeof(sphere_elements));
    
    vkUnmapMemory(vkDevice, vertexData_index_earth.vkDeviceMemory);

/******************************************mars*******************************************/
    
    //POSITION INDEX BUFFER
    //#4 memset the global strucure variable
    memset((void*)&vertexData_index_mars, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_elements);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_index_mars.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is succedded\n");
    }
    

    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_index_mars.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_index_mars.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is failed for rindex buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is succedded for index buffer\n");
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_index_mars.vkBuffer, vertexData_index_mars.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is succedded for index buffer\n");
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_index_mars.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is succedded for index buffer\n");
    }
   
    //#12
    memcpy(data, sphere_elements, sizeof(sphere_elements));
    
    vkUnmapMemory(vkDevice, vertexData_index_mars.vkDeviceMemory);
    
    /******************************************jupitor*******************************************/
    
    //POSITION INDEX BUFFER
    //#4 memset the global strucure variable
    memset((void*)&vertexData_index_jupitor, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_elements);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_index_jupitor.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is succedded\n");
    }
    

    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_index_jupitor.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_index_jupitor.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is failed for rindex buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is succedded for index buffer\n");
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_index_jupitor.vkBuffer, vertexData_index_jupitor.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is succedded for index buffer\n");
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_index_jupitor.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is succedded for index buffer\n");
    }
   
    //#12
    memcpy(data, sphere_elements, sizeof(sphere_elements));
    
    vkUnmapMemory(vkDevice, vertexData_index_jupitor.vkDeviceMemory);
    
    /******************************************saturn*******************************************/
    
    //POSITION INDEX BUFFER
    //#4 memset the global strucure variable
    memset((void*)&vertexData_index_saturn, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_elements);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_index_saturn.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is succedded\n");
    }
    

    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_index_saturn.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_index_saturn.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is failed for rindex buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is succedded for index buffer\n");
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_index_saturn.vkBuffer, vertexData_index_saturn.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is succedded for index buffer\n");
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_index_saturn.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is succedded for index buffer\n");
    }
   
    //#12
    memcpy(data, sphere_elements, sizeof(sphere_elements));
    
    vkUnmapMemory(vkDevice, vertexData_index_saturn.vkDeviceMemory);
    
    
    /******************************************uranus*******************************************/
    
    //POSITION INDEX BUFFER
    //#4 memset the global strucure variable
    memset((void*)&vertexData_index_uranus, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_elements);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_index_uranus.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is succedded\n");
    }
    

    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_index_uranus.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_index_uranus.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is failed for rindex buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is succedded for index buffer\n");
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_index_uranus.vkBuffer, vertexData_index_uranus.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is succedded for index buffer\n");
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_index_uranus.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is succedded for index buffer\n");
    }
   
    //#12
    memcpy(data, sphere_elements, sizeof(sphere_elements));
    
    vkUnmapMemory(vkDevice, vertexData_index_uranus.vkDeviceMemory);
    
    /******************************************neptune*******************************************/
    
    //POSITION INDEX BUFFER
    //#4 memset the global strucure variable
    memset((void*)&vertexData_index_neptune, 0, sizeof(VertexData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(sphere_elements);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    
    ///#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &vertexData_index_neptune.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkCreateBuffer() of index buffer is succedded\n");
    }
    

    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, vertexData_index_neptune.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(int i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &vertexData_index_neptune.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is failed for rindex buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkAllocateMemory() is succedded for index buffer\n");
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vertexData_index_neptune.vkBuffer, vertexData_index_neptune.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkBindBufferMemory() is succedded for index buffer\n");
    }
    
    //#11
    data = NULL;
    vkResult = vkMapMemory(vkDevice, vertexData_index_neptune.vkDeviceMemory, 0, vkMemoryAllocateInfo.allocationSize, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is failed for index buffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createIndexBuffer() --> vkMapMemory() is succedded for index buffer\n");
    }
   
    //#12
    memcpy(data, sphere_elements, sizeof(sphere_elements));
    
    vkUnmapMemory(vkDevice, vertexData_index_neptune.vkDeviceMemory);

    return (vkResult);
}


VkResult createTexture(const char* textureFileName)
{
    //variable
    VkResult vkResult = VK_SUCCESS;
    bool bSun_texture = VK_FALSE;
    bool bMercury_texture = VK_FALSE;
    bool bVenus_texture = VK_FALSE;
    bool bEarth_texture = VK_FALSE;
    bool bMars_texture = VK_FALSE;
    bool bJupitor_texture = VK_FALSE;
    bool bSaturn_texture = VK_FALSE;
    bool bUranus_texture = VK_FALSE;
    bool bNeptune_texture = VK_FALSE;
    
    //code
    //step 1
    FILE* fp = NULL;
    fp = fopen(textureFileName, "rb");
    if(fp == NULL)
    {
        fprintf(gpFile, "createTexture() --> fOpen() failed to open sun.png texture file\n");
        return VK_ERROR_INITIALIZATION_FAILED;
    }
    
    if(textureFileName[0] == 's' && textureFileName[1] == 'u' && textureFileName[2] == 'n')
    {
        bSun_texture = VK_TRUE;
        fprintf(gpFile, "createTexture() --> bSun_texture is VK_TRUE\n");
    }
    if(textureFileName[0] == 'm' && textureFileName[1] == 'e' && textureFileName[2] == 'r')
    {
        bMercury_texture = VK_TRUE;
        fprintf(gpFile, "createTexture() --> bMercury_texture is VK_TRUE\n");
    }
    if(textureFileName[0] == 'v' && textureFileName[1] == 'e' && textureFileName[2] == 'n')
    {
        bVenus_texture = VK_TRUE;
        fprintf(gpFile, "createTexture() --> bVenus_texture is VK_TRUE\n");
    }
    if(textureFileName[0] == 'e' && textureFileName[1] == 'a' && textureFileName[2] == 'r')
    {
        bEarth_texture = VK_TRUE;
        fprintf(gpFile, "createTexture() --> bEarth_texture is VK_TRUE\n");
    }
    if(textureFileName[0] == 'm' && textureFileName[1] == 'a' && textureFileName[2] == 'r')
    {
        bMars_texture = VK_TRUE;
        fprintf(gpFile, "createTexture() --> bMars_texture is VK_TRUE\n");
    }
    if(textureFileName[0] == 'j' && textureFileName[1] == 'u' && textureFileName[2] == 'p')
    {
        bJupitor_texture = VK_TRUE;
        fprintf(gpFile, "createTexture() --> bJupitor_texture is VK_TRUE\n");
    }
    if(textureFileName[0] == 's' && textureFileName[1] == 'a' && textureFileName[2] == 't')
    {
        bSaturn_texture = VK_TRUE;
        fprintf(gpFile, "createTexture() --> bSaturn_texture is VK_TRUE\n");
    }
    if(textureFileName[0] == 'u' && textureFileName[1] == 'r' && textureFileName[2] == 'a')
    {
        bUranus_texture = VK_TRUE;
        fprintf(gpFile, "createTexture() --> bUranus_texture is VK_TRUE\n");
    }
    if(textureFileName[0] == 'n' && textureFileName[1] == 'e' && textureFileName[2] == 'p')
    {
        bNeptune_texture = VK_TRUE;
        fprintf(gpFile, "createTexture() --> bNeptune_texture is VK_TRUE\n");
    }
  
    
    uint8_t* imageData = NULL;
    int texture_width, texture_height, texture_channels;

    imageData = stbi_load_from_file(fp, &texture_width, &texture_height, &texture_channels, STBI_rgb_alpha);
    if(imageData == NULL || texture_width <= 0 || texture_height <= 0 || texture_channels <= 0)
    {
        fprintf(gpFile, "createTexture() --> stbi_load_from_file() failed to read Stone.png texture file\n");
        return VK_ERROR_INITIALIZATION_FAILED;
    }
    
    /*uint64_t :: VkDeviceSize*/
    VkDeviceSize image_size = texture_width * texture_height * 4 /*RCBA*/ ;
    
    //step 2
    VkBuffer vkBuffer_stagingBuffer = VK_NULL_HANDLE;
    VkDeviceMemory vkDeviceMemory_stagingBuffer = VK_NULL_HANDLE;
    
    VkBufferCreateInfo vkBufferCreateInfo_stagingBuffer;
    memset((void*)&vkBufferCreateInfo_stagingBuffer, 0, sizeof(VkBufferCreateInfo));    
    vkBufferCreateInfo_stagingBuffer.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo_stagingBuffer.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo_stagingBuffer.flags = 0;
    vkBufferCreateInfo_stagingBuffer.size = image_size;
    vkBufferCreateInfo_stagingBuffer.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT; // this buffer is source
    vkBufferCreateInfo_stagingBuffer.sharingMode = VK_SHARING_MODE_EXCLUSIVE; // buffer can be used for concurrent usage, for multithreading
    
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo_stagingBuffer,
                              NULL,
                              &vkBuffer_stagingBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkCreateBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkCreateBuffer() is succedded\n");
    }
    
    VkMemoryRequirements vkMemoryRequirements_stagingBuffer;
    memset((void*)&vkMemoryRequirements_stagingBuffer, 0, sizeof(VkMemoryRequirements));
    
    vkGetBufferMemoryRequirements(vkDevice, vkBuffer_stagingBuffer, &vkMemoryRequirements_stagingBuffer);
    
    //8" Allocate
    VkMemoryAllocateInfo vkMemoryAllocateInfo_stagingBuffer;
    memset((void*)&vkMemoryAllocateInfo_stagingBuffer , 0, sizeof(VkMemoryAllocateInfo));
    
    vkMemoryAllocateInfo_stagingBuffer.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo_stagingBuffer.pNext = NULL; 
    vkMemoryAllocateInfo_stagingBuffer.allocationSize = vkMemoryRequirements_stagingBuffer.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo_stagingBuffer.memoryTypeIndex = 0;
    
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements_stagingBuffer.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) //VK_MEMORY_PROPERTY_HOST_COHERENT_BIT--> No need to manage vulkan cache mechanism for flushing and mapping as we order vulkan to maintain coherency
            {
                vkMemoryAllocateInfo_stagingBuffer.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements_stagingBuffer.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo_stagingBuffer, NULL, &vkDeviceMemory_stagingBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkAllocateMemory() is succedded\n");
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, vkBuffer_stagingBuffer, vkDeviceMemory_stagingBuffer, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkBindBufferMemory() is succedded\n");
    }
    
    void* data = NULL;
    vkResult = vkMapMemory(vkDevice, vkDeviceMemory_stagingBuffer, 0, image_size, 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkMapMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkMapMemory() is succedded\n");
    }
    
    //#12
    memcpy(data, imageData, image_size);
    
    vkUnmapMemory(vkDevice, vkDeviceMemory_stagingBuffer);
    
    //As copying of image data into the staging buffer is completed, we can Free the actual image data given by stb 
    stbi_image_free(imageData);
    imageData = NULL;
    fprintf(gpFile, "createTexture() --> stbi_image_free() Freeing of image data is succedded\n");
    
    
    /*
    Step# 3. 
    Create "Device only visible", empty, but enough sized Image equal to size of image(image width * image Height).
    */
    
    VkImageCreateInfo vkImageCreateInfo;
    memset((void*)&vkImageCreateInfo, 0, sizeof(VkImageCreateInfo));
    vkImageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    vkImageCreateInfo.pNext = NULL;
    vkImageCreateInfo.flags = 0;
    vkImageCreateInfo.imageType = VK_IMAGE_TYPE_2D;
    vkImageCreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;  //SRGB can ber found in other tutorials
    vkImageCreateInfo.extent.width = texture_width;
    vkImageCreateInfo.extent.height = texture_height;
    vkImageCreateInfo.extent.depth = 1;
    vkImageCreateInfo.mipLevels = 1;
    vkImageCreateInfo.arrayLayers = 1;
    vkImageCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    vkImageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
    vkImageCreateInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
    vkImageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    vkImageCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

    vkResult = vkCreateImage(vkDevice, &vkImageCreateInfo, NULL, &vkImage_texture);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkCreateImage() is failed error code is %d\n",vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkCreateImage() is succedded\n");
        fflush(gpFile);
    }
    
    //Memory requirement for texture image
    VkMemoryRequirements vkMemoryRequirements_image;
    memset((void*)&vkMemoryRequirements_image, 0, sizeof(VkMemoryRequirements));
    vkGetImageMemoryRequirements(vkDevice, vkImage_texture, &vkMemoryRequirements_image);
    
    //8" Allocate
    VkMemoryAllocateInfo vkMemoryAllocateInfo_image;
    memset((void*)&vkMemoryAllocateInfo_image , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo_image.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo_image.pNext = NULL; 
    vkMemoryAllocateInfo_image.allocationSize = vkMemoryRequirements_image.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo_image.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements_image.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
            {
                vkMemoryAllocateInfo_image.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements_image.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo_image, NULL, &vkDeviceMemory_texture);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindImageMemory(vkDevice, vkImage_texture, vkDeviceMemory_texture, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkBindImageMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkBindImageMemory() is succedded\n");
        fflush(gpFile);
    }
    
    /*
    Step#4. 
    Send "image transition layout" to the Vulkan / GPU, before the actual staging buffer from step 2 to empty vkImage of Step 3, using Pipeline Barrier.
    */
    
    /*
    Steps of Staging buffer, when pushing data to GPU in initialize
    
    Command pool must be allocated before these steps
    
    AllocateCmd buffer
    begin cmd buffer
    vkCMD
    end CMD nbuffer
    summbmit queue
    wait idleQueue
    Free comamnd buffer
    */
    
    //#4.1
    VkCommandBufferAllocateInfo vkCommandBufferAllocateInfo_transition_image_layout; 
    memset((void*)&vkCommandBufferAllocateInfo_transition_image_layout, 0, sizeof(VkCommandBufferAllocateInfo));
    
    vkCommandBufferAllocateInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    vkCommandBufferAllocateInfo_transition_image_layout.pNext = NULL;
    vkCommandBufferAllocateInfo_transition_image_layout.commandPool = vkCommandPool;
    vkCommandBufferAllocateInfo_transition_image_layout.commandBufferCount = 1;
    vkCommandBufferAllocateInfo_transition_image_layout.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
   
    VkCommandBuffer vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;
    vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo_transition_image_layout, &vkCommandBuffer_transition_image_layout);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkAllocateCommandBuffers() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkAllocateCommandBuffers() is succedded\n");
        fflush(gpFile);
    }

    //#4.2
    VkCommandBufferBeginInfo vkCommandBufferBeginInfo_transition_image_layout;
    memset((void*)&vkCommandBufferBeginInfo_transition_image_layout, 0, sizeof(VkCommandBufferBeginInfo));
    
    vkCommandBufferBeginInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkCommandBufferBeginInfo_transition_image_layout.pNext = NULL;
    vkCommandBufferBeginInfo_transition_image_layout.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;  //1. we will use only primary command buffers, 2. we are not going to use this command buffer simultaneoulsy between multipple threads
    
    vkResult = vkBeginCommandBuffer(vkCommandBuffer_transition_image_layout, &vkCommandBufferBeginInfo_transition_image_layout);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkBeginCommandBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkBeginCommandBuffer() is succedded \n");
        fflush(gpFile);
    }

    //#4.3: Setting Barrier
    VkPipelineStageFlags vkPipelineStageFlags_source = 0;
    VkPipelineStageFlags vkPipelineStageFlags_destination = 0;
    VkImageMemoryBarrier vkImageMemoryBarrier;
    memset((void*)&vkImageMemoryBarrier, 0, sizeof(VkImageMemoryBarrier));
    vkImageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    vkImageMemoryBarrier.pNext = NULL;
    vkImageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    vkImageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    vkImageMemoryBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    vkImageMemoryBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    vkImageMemoryBarrier.image = vkImage_texture;
    vkImageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    vkImageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
    vkImageMemoryBarrier.subresourceRange.baseMipLevel = 0;
    vkImageMemoryBarrier.subresourceRange.layerCount = 1;
    vkImageMemoryBarrier.subresourceRange.levelCount = 1;
    
    if(vkImageMemoryBarrier.oldLayout == VK_IMAGE_LAYOUT_UNDEFINED && vkImageMemoryBarrier.newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)
    {
        vkImageMemoryBarrier.srcAccessMask = 0;
        vkImageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        vkPipelineStageFlags_source = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
        vkPipelineStageFlags_destination = VK_PIPELINE_STAGE_TRANSFER_BIT;
        
        //Vulkan Pipeline
        //1. Top Stage
        //2. Drawindirect
        //3. Vertex input stage
        //4. Vertex shader stage
        //5. TSC shader stage
        //6. TSE shader stage
        //7. Geometry Shader
        //8. Fragment shader stage
        //9. Early pixel test stage(implementation dependent) (some of these post processing tests, pixel ownership, scissor, stencil, alpha, dither, blend , depth, logic op)
        //10. Late Pixel Stage(implementation dependent)
        //11. Color attachment output stage
        //12. Compute Shader stage
        //13. Transfer stage
        //14. Bottom stage
        //15. Host stage
        //16. All graphic stage
        //17. All command stage
        
        
    }
    else if(vkImageMemoryBarrier.oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && vkImageMemoryBarrier.newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
    {
        vkImageMemoryBarrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        vkImageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
        vkPipelineStageFlags_source = VK_PIPELINE_STAGE_TRANSFER_BIT;
        vkPipelineStageFlags_destination = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> Unsupported texture layout transition()\n");
        fflush(gpFile);
        return VK_ERROR_INITIALIZATION_FAILED;
    }
    
    vkCmdPipelineBarrier(vkCommandBuffer_transition_image_layout, vkPipelineStageFlags_source, vkPipelineStageFlags_destination, 0, 0, NULL, 0, NULL, 1, &vkImageMemoryBarrier);
    
    //#4.4: End Command Buffer
    vkResult = vkEndCommandBuffer(vkCommandBuffer_transition_image_layout);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkEndCommandBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkEndCommandBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    //#4.5: Submitting Queue
    VkSubmitInfo  vkSubmitInfo_transition_image_layout;
    memset((void*)&vkSubmitInfo_transition_image_layout, 0, sizeof(VkSubmitInfo));
    
    vkSubmitInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    vkSubmitInfo_transition_image_layout.pNext = NULL;
    vkSubmitInfo_transition_image_layout.commandBufferCount = 1;
    vkSubmitInfo_transition_image_layout.pCommandBuffers = &vkCommandBuffer_transition_image_layout;
    // As there is no need of synchrnization for waitDstStageMask and Semaphore is not needed
    
    //Now submit our work to the Queue
    vkResult = vkQueueSubmit(vkQueue,
                             1,
                             &vkSubmitInfo_transition_image_layout,
                             VK_NULL_HANDLE);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkQueueSubmit() is failed errorcode = %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkQueueSubmit() succeded\n", vkResult);
        fflush(gpFile);
    }

    //#4.6: Waiting
    vkResult = vkQueueWaitIdle(vkQueue);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkQueueWaitIdle() is failed errorcode = %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkQueueWaitIdle() succeded\n", vkResult);
        fflush(gpFile);
    }
    
    //#4.7: Freeing
    vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_transition_image_layout);
    vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;
    
    /*
    Step #5 
    Now actually copy the image data from staging buffer to the empty vkImage.
    */
    
    VkCommandBufferAllocateInfo vkCommandBufferAllocateInfo_buffer_to_image_copy; 
    memset((void*)&vkCommandBufferAllocateInfo_buffer_to_image_copy, 0, sizeof(VkCommandBufferAllocateInfo));
    
    vkCommandBufferAllocateInfo_buffer_to_image_copy.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    vkCommandBufferAllocateInfo_buffer_to_image_copy.pNext = NULL;
    vkCommandBufferAllocateInfo_buffer_to_image_copy.commandPool = vkCommandPool;
    vkCommandBufferAllocateInfo_buffer_to_image_copy.commandBufferCount = 1;
    vkCommandBufferAllocateInfo_buffer_to_image_copy.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
   
    VkCommandBuffer vkCommandBuffer_buffer_to_image_copy = VK_NULL_HANDLE;
    vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo_buffer_to_image_copy, &vkCommandBuffer_buffer_to_image_copy);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkAllocateCommandBuffers() is failed for buffer_to_image_copy and error code is %d \n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkAllocateCommandBuffers() is succedded for buffer_to_image_copy\n");
        fflush(gpFile);
    }

    //#5.2
    VkCommandBufferBeginInfo vkCommandBufferBeginInfo_buffer_to_image_copy;
    memset((void*)&vkCommandBufferBeginInfo_buffer_to_image_copy, 0, sizeof(VkCommandBufferBeginInfo));
    
    vkCommandBufferBeginInfo_buffer_to_image_copy.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkCommandBufferBeginInfo_buffer_to_image_copy.pNext = NULL;
    vkCommandBufferBeginInfo_buffer_to_image_copy.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;  //1. we will use only primary command buffers, 2. we are not going to use this command buffer simultaneoulsy between multipple threads
    
    vkResult = vkBeginCommandBuffer(vkCommandBuffer_buffer_to_image_copy, &vkCommandBufferBeginInfo_buffer_to_image_copy);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkBeginCommandBuffer() is failed for buffer_to_image_copy and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkBeginCommandBuffer() is succedded for buffer_to_image_copy \n");
        fflush(gpFile);
    }
    
    //5.3
    VkBufferImageCopy vkBufferImageCopy;
    memset((void*)&vkBufferImageCopy, 0, sizeof(VkBufferImageCopy));
    vkBufferImageCopy.bufferOffset = 0; 
    vkBufferImageCopy.bufferRowLength = 0;
    vkBufferImageCopy.bufferImageHeight = 0;
    vkBufferImageCopy.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    vkBufferImageCopy.imageSubresource.mipLevel = 0;
    vkBufferImageCopy.imageSubresource.baseArrayLayer = 0;
    vkBufferImageCopy.imageSubresource.layerCount = 1;
    // vkBufferImageCopy.imageSubresource.levelCount = 1;
    vkBufferImageCopy.imageOffset.x = 0;
    vkBufferImageCopy.imageOffset.y = 0;
    vkBufferImageCopy.imageOffset.z = 0;
    vkBufferImageCopy.imageExtent.width = texture_width;
    vkBufferImageCopy.imageExtent.height = texture_height;
    vkBufferImageCopy.imageExtent.depth = 1;
    
    vkCmdCopyBufferToImage(vkCommandBuffer_buffer_to_image_copy, 
                           vkBuffer_stagingBuffer, 
                           vkImage_texture, 
                           VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 
                           1, 
                           &vkBufferImageCopy);
    
    //#5.4: End Command Buffer
    vkResult = vkEndCommandBuffer(vkCommandBuffer_buffer_to_image_copy);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkEndCommandBuffer() is failed for buffer_to_image_copy and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkEndCommandBuffer() is succedded for buffer_to_image_copy\n");
        fflush(gpFile);
    }
    
    //#5.5: Submitting Queue
    VkSubmitInfo  vkSubmitInfo_buffer_to_image_copy;
    memset((void*)&vkSubmitInfo_buffer_to_image_copy, 0, sizeof(VkSubmitInfo));
    
    vkSubmitInfo_buffer_to_image_copy.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    vkSubmitInfo_buffer_to_image_copy.pNext = NULL;
    vkSubmitInfo_buffer_to_image_copy.commandBufferCount = 1;
    vkSubmitInfo_buffer_to_image_copy.pCommandBuffers = &vkCommandBuffer_buffer_to_image_copy;
    // As there is no need of synchrnization for waitDstStageMask and Semaphore is not needed
    
    //Now submit our work to the Queue
    vkResult = vkQueueSubmit(vkQueue,
                             1,
                             &vkSubmitInfo_buffer_to_image_copy,
                             VK_NULL_HANDLE);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkQueueSubmit() is failed for buffer_to_image_copy errorcode = %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkQueueSubmit() is succedded for buffer_to_image_copy");
        fflush(gpFile);
    }

    //#5.6: Waiting
    vkResult = vkQueueWaitIdle(vkQueue);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkQueueWaitIdle() is failed for buffer_to_image_copy errorcode = %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkQueueWaitIdle() succeded for buffer_to_image_copy\n");
        fflush(gpFile);
    }
    
    //#5.7: Freeing
    vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_buffer_to_image_copy);
    vkCommandBuffer_buffer_to_image_copy = VK_NULL_HANDLE;
    
    
    /*
    Step 6. 
    Now again do image layout transition similar to the step 4, for the corrext reading/writing of object data by shaders.
    */
    
    //#6.1
    memset((void*)&vkCommandBufferAllocateInfo_transition_image_layout, 0, sizeof(VkCommandBufferAllocateInfo));
    
    vkCommandBufferAllocateInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    vkCommandBufferAllocateInfo_transition_image_layout.pNext = NULL;
    vkCommandBufferAllocateInfo_transition_image_layout.commandPool = vkCommandPool;
    vkCommandBufferAllocateInfo_transition_image_layout.commandBufferCount = 1;
    vkCommandBufferAllocateInfo_transition_image_layout.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
   
    vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;
    vkResult = vkAllocateCommandBuffers(vkDevice, &vkCommandBufferAllocateInfo_transition_image_layout, &vkCommandBuffer_transition_image_layout);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkAllocateCommandBuffers() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkAllocateCommandBuffers() is succedded\n");
        fflush(gpFile);
    }

    //#6.2
    memset((void*)&vkCommandBufferBeginInfo_transition_image_layout, 0, sizeof(VkCommandBufferBeginInfo));
    
    vkCommandBufferBeginInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkCommandBufferBeginInfo_transition_image_layout.pNext = NULL;
    vkCommandBufferBeginInfo_transition_image_layout.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;  //1. we will use only primary command buffers, 2. we are not going to use this command buffer simultaneoulsy between multipple threads
    
    vkResult = vkBeginCommandBuffer(vkCommandBuffer_transition_image_layout, &vkCommandBufferBeginInfo_transition_image_layout);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkBeginCommandBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkBeginCommandBuffer() is succedded \n");
        fflush(gpFile);
    }

    //#6.3: Setting Barrier
    vkPipelineStageFlags_source = 0;
    vkPipelineStageFlags_destination = 0;

    memset((void*)&vkImageMemoryBarrier, 0, sizeof(VkImageMemoryBarrier));
    vkImageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    vkImageMemoryBarrier.pNext = NULL;
    vkImageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    vkImageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkImageMemoryBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    vkImageMemoryBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    vkImageMemoryBarrier.image = vkImage_texture;
    vkImageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    vkImageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
    vkImageMemoryBarrier.subresourceRange.baseMipLevel = 0;
    vkImageMemoryBarrier.subresourceRange.layerCount = 1;
    vkImageMemoryBarrier.subresourceRange.levelCount = 1;
    
    if(vkImageMemoryBarrier.oldLayout == VK_IMAGE_LAYOUT_UNDEFINED && vkImageMemoryBarrier.newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)
    {
        vkImageMemoryBarrier.srcAccessMask = 0;
        vkImageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        vkPipelineStageFlags_source = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
        vkPipelineStageFlags_destination = VK_PIPELINE_STAGE_TRANSFER_BIT;
    }
    else if(vkImageMemoryBarrier.oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && vkImageMemoryBarrier.newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
    {
        vkImageMemoryBarrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        vkImageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
        vkPipelineStageFlags_source = VK_PIPELINE_STAGE_TRANSFER_BIT;
        vkPipelineStageFlags_destination = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> Unsupported texture layout transition for 2nd time in step 6\n");
        fflush(gpFile);
        return VK_ERROR_INITIALIZATION_FAILED;
    }
    
    vkCmdPipelineBarrier(vkCommandBuffer_transition_image_layout, vkPipelineStageFlags_source, vkPipelineStageFlags_destination, 0, 0, NULL, 0, NULL, 1, &vkImageMemoryBarrier);
    
    //#6.4: End Command Buffer
    vkResult = vkEndCommandBuffer(vkCommandBuffer_transition_image_layout);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkEndCommandBuffer() is failed for 2nd time in step 6 and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkEndCommandBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    //#6.5: Submitting Queue
    memset((void*)&vkSubmitInfo_transition_image_layout, 0, sizeof(VkSubmitInfo));
    
    vkSubmitInfo_transition_image_layout.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    vkSubmitInfo_transition_image_layout.pNext = NULL;
    vkSubmitInfo_transition_image_layout.commandBufferCount = 1;
    vkSubmitInfo_transition_image_layout.pCommandBuffers = &vkCommandBuffer_transition_image_layout;
    // As there is no need of synchrnization for waitDstStageMask and Semaphore is not needed
    
    //Now submit our work to the Queue
    vkResult = vkQueueSubmit(vkQueue,
                             1,
                             &vkSubmitInfo_transition_image_layout,
                             VK_NULL_HANDLE);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkQueueSubmit() is failed  for 2nd time in step 6 errorcode = %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkQueueSubmit() succeded  for 2nd time in step 6 \n", vkResult);
        fflush(gpFile);
    }

    //#6.6: Waiting
    vkResult = vkQueueWaitIdle(vkQueue);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkQueueWaitIdle() is failed  for 2nd time in step 6 errorcode = %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkQueueWaitIdle() succeded for 2nd time in step 6 \n", vkResult);
        fflush(gpFile);
    }
    
    //#6.7: Freeing
    vkFreeCommandBuffers(vkDevice, vkCommandPool, 1, &vkCommandBuffer_transition_image_layout);
    vkCommandBuffer_transition_image_layout = VK_NULL_HANDLE;
    
    /*
    Step #7. 
    Now staging buffer is not needed, hence release its memory and itself
    */

    if(vkBuffer_stagingBuffer)
    {
        vkDestroyBuffer(vkDevice, vkBuffer_stagingBuffer, NULL);
        vkBuffer_stagingBuffer = VK_NULL_HANDLE;
        fprintf(gpFile, "createTexture() --> vkDestroyBuffer() is done for vkBuffer_stagingBuffer of setp 7\n");
        fflush(gpFile);
    }
    
    if(vkDeviceMemory_stagingBuffer)
    {
       vkFreeMemory(vkDevice, vkDeviceMemory_stagingBuffer, NULL);
       vkDeviceMemory_stagingBuffer = VK_NULL_HANDLE;
       fprintf(gpFile, "createTexture() --> vkFreeMemory() is done for vkBuffer_stagingBuffer of setp 7\n");
        fflush(gpFile);
    }
    
    /* Step8. 
       Create imageview of above image
    */
    // Initialize vkImageViewCreateInfo structure
    VkImageViewCreateInfo vkImageViewCreateInfo;
    //create image view for above depth image
    memset((void*)&vkImageViewCreateInfo, 0, sizeof(VkImageViewCreateInfo));

    vkImageViewCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    vkImageViewCreateInfo.pNext = NULL;
    vkImageViewCreateInfo.flags = 0;
    vkImageViewCreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
    vkImageViewCreateInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT | VK_IMAGE_ASPECT_STENCIL_BIT;
    vkImageViewCreateInfo.subresourceRange.baseMipLevel = 0;
    vkImageViewCreateInfo.subresourceRange.levelCount = 1;
    vkImageViewCreateInfo.subresourceRange.baseArrayLayer = 0;
    vkImageViewCreateInfo.subresourceRange.layerCount = 1;
    vkImageViewCreateInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    vkImageViewCreateInfo.image = vkImage_texture;
    
    vkResult = vkCreateImageView(vkDevice,
                                 &vkImageViewCreateInfo,
                                 NULL,
                                 &vkImageView_texture);
    
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkCreateImageView() is failed error code is %d\n",vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkCreateImageView() is succedded\n");
        fflush(gpFile);
    }
    
    
    /*Step 9. 
      Create texture sampler of above image
     */
     
    VkSamplerCreateInfo vkSamplerCreateInfo;
    memset((void*)&vkSamplerCreateInfo, 0, sizeof(VkSamplerCreateInfo));
    vkSamplerCreateInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    vkSamplerCreateInfo.pNext = NULL;
    vkSamplerCreateInfo.magFilter = VK_FILTER_LINEAR;
    vkSamplerCreateInfo.minFilter = VK_FILTER_LINEAR;
    vkSamplerCreateInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
    vkSamplerCreateInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    vkSamplerCreateInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    vkSamplerCreateInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    vkSamplerCreateInfo.anisotropyEnable = VK_FALSE;
    vkSamplerCreateInfo.maxAnisotropy = 16;
    vkSamplerCreateInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
    vkSamplerCreateInfo.unnormalizedCoordinates = VK_FALSE;
    vkSamplerCreateInfo.compareEnable = VK_FALSE;
    vkSamplerCreateInfo.compareOp = VK_COMPARE_OP_ALWAYS;
    
    vkResult = vkCreateSampler(vkDevice, &vkSamplerCreateInfo, NULL, &vkSampler_texture);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createTexture() --> vkCreateSampler() is failed error code is %d\n",vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createTexture() --> vkCreateSampler() is succedded\n");
        fflush(gpFile);
    }
    
    if(bSun_texture == VK_TRUE)
    {
        vkImageView_texture_sun = vkImageView_texture;
        vkSampler_texture_sun = vkSampler_texture;
    }
    
    if(bMercury_texture == VK_TRUE)
    {
        vkImageView_texture_mercury = vkImageView_texture;
        vkSampler_texture_mercury = vkSampler_texture;
    }
    
    if(bVenus_texture == VK_TRUE)
    {
        vkImageView_texture_venus = vkImageView_texture;
        vkSampler_texture_venus = vkSampler_texture;
    }
    
    if(bEarth_texture == VK_TRUE)
    {
        vkImageView_texture_earth = vkImageView_texture;
        vkSampler_texture_earth = vkSampler_texture;
    }
    
    if(bMars_texture == VK_TRUE)
    {
        vkImageView_texture_mars = vkImageView_texture;
        vkSampler_texture_mars = vkSampler_texture;
    }
    
    if(bJupitor_texture == VK_TRUE)
    {
        vkImageView_texture_jupitor = vkImageView_texture;
        vkSampler_texture_jupitor = vkSampler_texture;
    }
    
    if(bSaturn_texture == VK_TRUE)
    {
        vkImageView_texture_saturn = vkImageView_texture;
        vkSampler_texture_saturn = vkSampler_texture;
    }
    
    if(bUranus_texture == VK_TRUE)
    {
        vkImageView_texture_uranus = vkImageView_texture;
        vkSampler_texture_uranus = vkSampler_texture;
    }
    if(bNeptune_texture == VK_TRUE)
    {
        vkImageView_texture_neptune = vkImageView_texture;
        vkSampler_texture_neptune = vkSampler_texture;
    }
    
    
    return vkResult; 
}


VkResult createUniformBuffer(void)
{
    //Function declarations
    VkResult updateUniformBuffer(void);
    
    //variable
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //sun
    //#4 memset the global strucure variable
    memset((void*)&uniformData_sun, 0, sizeof(UniformData));
    
    //#5 VkBufferCreateInfo structure filling
    VkBufferCreateInfo vkBufferCreateInfo;
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(struct MyUniformData);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    
    //#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &uniformData_sun.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    VkMemoryRequirements vkMemoryRequirements;
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, uniformData_sun.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    VkMemoryAllocateInfo vkMemoryAllocateInfo;
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &uniformData_sun.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, uniformData_sun.vkBuffer, uniformData_sun.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is succedded\n");
        fflush(gpFile);
    }
    
    
    /**************************************************Mercury************************************************************/
    
    //mercury
    //#4 memset the global strucure variable
    memset((void*)&uniformData_mercury, 0, sizeof(UniformData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(struct MyUniformData);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    
    //#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &uniformData_mercury.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, uniformData_mercury.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &uniformData_mercury.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, uniformData_mercury.vkBuffer, uniformData_mercury.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is succedded\n");
        fflush(gpFile);
    }
    
    /**************************************************venus************************************************************/
    
    //venus
    //#4 memset the global strucure variable
    memset((void*)&uniformData_venus, 0, sizeof(UniformData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(struct MyUniformData);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    
    //#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &uniformData_venus.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, uniformData_venus.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &uniformData_venus.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, uniformData_venus.vkBuffer, uniformData_venus.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is succedded\n");
        fflush(gpFile);
    }
   
   /**************************************************earth************************************************************/
    
    //earth
    //#4 memset the global strucure variable
    memset((void*)&uniformData_earth, 0, sizeof(UniformData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(struct MyUniformData);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    
    //#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &uniformData_earth.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, uniformData_earth.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &uniformData_earth.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, uniformData_earth.vkBuffer, uniformData_earth.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is succedded\n");
        fflush(gpFile);
    }
    
    /**************************************************mars************************************************************/
    
    //mars
    //#4 memset the global strucure variable
    memset((void*)&uniformData_mars, 0, sizeof(UniformData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(struct MyUniformData);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    
    //#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &uniformData_mars.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, uniformData_mars.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &uniformData_mars.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, uniformData_mars.vkBuffer, uniformData_mars.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is succedded\n");
        fflush(gpFile);
    }
    
    /**************************************************jupitor************************************************************/
    
    //jupitor
    //#4 memset the global strucure variable
    memset((void*)&uniformData_jupitor, 0, sizeof(UniformData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(struct MyUniformData);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    
    //#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &uniformData_jupitor.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, uniformData_jupitor.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &uniformData_jupitor.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, uniformData_jupitor.vkBuffer, uniformData_jupitor.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is succedded\n");
        fflush(gpFile);
    }
    
    /**************************************************saturn************************************************************/
    
    //saturn
    //#4 memset the global strucure variable
    memset((void*)&uniformData_saturn, 0, sizeof(UniformData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(struct MyUniformData);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    
    //#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &uniformData_saturn.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, uniformData_saturn.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &uniformData_saturn.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, uniformData_saturn.vkBuffer, uniformData_saturn.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is succedded\n");
        fflush(gpFile);
    }
    
    /**************************************************uranus************************************************************/
    
    //uranus
    //#4 memset the global strucure variable
    memset((void*)&uniformData_uranus, 0, sizeof(UniformData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(struct MyUniformData);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    
    //#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &uniformData_uranus.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, uniformData_uranus.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &uniformData_uranus.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, uniformData_uranus.vkBuffer, uniformData_uranus.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is succedded\n");
        fflush(gpFile);
    }
    
    /**************************************************neptune************************************************************/
    
    //neptune
    //#4 memset the global strucure variable
    memset((void*)&uniformData_neptune, 0, sizeof(UniformData));
    
    //#5 VkBufferCreateInfo structure filling
    memset((void*)&vkBufferCreateInfo , 0, sizeof(VkBufferCreateInfo));
    vkBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    vkBufferCreateInfo.pNext = NULL;
    //valid flags are used in scatterred/sparse buffer
    vkBufferCreateInfo.flags = 0;
    vkBufferCreateInfo.size = sizeof(struct MyUniformData);
    vkBufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    
    //#6
    vkResult = vkCreateBuffer(vkDevice, 
                              &vkBufferCreateInfo,
                              NULL,
                              &uniformData_neptune.vkBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkCreateBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    memset((void*)&vkMemoryRequirements, 0, sizeof(VkMemoryRequirements));
   
    vkGetBufferMemoryRequirements(vkDevice, uniformData_neptune.vkBuffer, &vkMemoryRequirements);
    
    //8" Allocate
    memset((void*)&vkMemoryAllocateInfo , 0, sizeof(VkMemoryAllocateInfo));
    vkMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    vkMemoryAllocateInfo.pNext = NULL; 
    vkMemoryAllocateInfo.allocationSize = vkMemoryRequirements.size;
    //initial value before entering inloop
    vkMemoryAllocateInfo.memoryTypeIndex = 0;
   
    for(uint32_t i = 0; i < vkPhysicalDeviceMemoryProperties.memoryTypeCount; i++)
    {
        if((vkMemoryRequirements.memoryTypeBits & 1) == 1)
        {
            if(vkPhysicalDeviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            {
                vkMemoryAllocateInfo.memoryTypeIndex = i;
                break;
            }
        }
        vkMemoryRequirements.memoryTypeBits >>= 1;
    }
    
    //#9 vkAllocateMemory
    vkResult = vkAllocateMemory(vkDevice, &vkMemoryAllocateInfo, NULL, &uniformData_neptune.vkDeviceMemory);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkAllocateMemory() is succedded\n");
        fflush(gpFile);
    }
    
    //#10: Binds vulkan device memory object handle with vulkan buffer object handle
    vkResult = vkBindBufferMemory(vkDevice, uniformData_neptune.vkBuffer, uniformData_neptune.vkDeviceMemory, 0);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> vkBindBufferMemory() is succedded\n");
        fflush(gpFile);
    }
    
    
    //call updateUniformBuffer()
    vkResult = updateUniformBuffer();
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> updateUniformBuffer() is failed and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createUniformBuffer() --> updateUniformBuffer() is succedded\n");
        fflush(gpFile);
    }
    
    return vkResult;
}

VkResult updateUniformBuffer(void)
{
    VkResult vkResult = VK_SUCCESS;
    
    //code
    
    //Sun
    //Note:glm follows column major matrix just like OpenGL, BUT unlike OpenGL its matrix array is 2D array 4x4 and not 1D array of 16 elements 
    MyUniformData myUniformData;
    memset((void*)&myUniformData, 0, sizeof(MyUniformData));
    //update matrices
    myUniformData.modelMatrix = glm::mat4(1.0f);  //Identity matrix
    
    glm::mat4 translationMatrix = glm::mat4(1.0f);  //Identity matrix
    translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(-8.0f, 0.0f, -10.0f));
    
    glm::mat4 rotationMatrix = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(angle), glm::vec3(0.0f, 1.0f, 0.0f));
    
    glm::mat4 ScaleMatrix = glm::mat4(1.0f);  //Identity matrix
    ScaleMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(10.0f, 10.0f, 10.0f));
    
    myUniformData.modelMatrix = translationMatrix * ScaleMatrix* rotationMatrix;
    
    myUniformData.viewMatrix = glm::mat4(1.0f);  //Identity matrix
    //myUniformData.projectionMatrix = glm::mat4(1.0f);  //Identity matrix
    glm::mat4 perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    
    perspectiveProjectionMatrix = glm::perspective(glm::radians(45.0f), (float)winWidth/(float)winHeight, 0.1f, 100.0f);
    
    perspectiveProjectionMatrix[1][1] = perspectiveProjectionMatrix[1][1] * (-1.0f);
    
    myUniformData.projectionMatrix = perspectiveProjectionMatrix;
    
    //map uniform buffer
    void* data = NULL;
    vkResult = vkMapMemory(vkDevice, uniformData_sun.vkDeviceMemory, 0, sizeof(MyUniformData), 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkMapMemory() is failed and error code is %d for pyramid\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
   
    //#12 copy the data to maped buffer
    memcpy(data, &myUniformData, sizeof(MyUniformData));
    
    //Unmap memory
    vkUnmapMemory(vkDevice, uniformData_sun.vkDeviceMemory);
    
    
    /************************************************************Mercury*************************************************/
    //Mercury
    //Note:glm follows column major matrix just like OpenGL, BUT unlike OpenGL its matrix array is 2D array 4x4 and not 1D array of 16 elements 
    memset((void*)&myUniformData, 0, sizeof(MyUniformData));
    //update matrices
    myUniformData.modelMatrix = glm::mat4(1.0f);  //Identity matrix
    
    translationMatrix = glm::mat4(1.0f);  //Identity matrix
    translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(4.0f * cos(angle_mercury), 0.0f, 4.0f * sin(angle_mercury)));
    
    glm::mat4 translationMatrix1 = glm::mat4(1.0f);  //Identity matrix
    translationMatrix1 = glm::translate(glm::mat4(1.0f), glm::vec3(-6.0f, 0.0f, -10.0f));
    
    glm::mat4 rotationMatrix_self = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_self = glm::rotate(glm::mat4(1.0f), glm::radians(angle_earth), glm::vec3(1.0f, 0.0f, 0.0f));
    
    glm::mat4 rotationMatrix_orbit = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_orbit = glm::rotate(glm::mat4(1.0f), glm::radians(angle_earth), glm::vec3(0.0f, 1.0f, 0.0f));
    
    ScaleMatrix = glm::mat4(1.0f);  //Identity matrix
    ScaleMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(0.3f, 0.3f, 0.3f));
    
    myUniformData.modelMatrix =  translationMatrix1 * rotationMatrix_orbit * translationMatrix * ScaleMatrix * rotationMatrix_self;
    
    myUniformData.viewMatrix = glm::mat4(1.0f);  //Identity matrix
    //myUniformData.projectionMatrix = glm::mat4(1.0f);  //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    
    perspectiveProjectionMatrix = glm::perspective(glm::radians(45.0f), (float)winWidth/(float)winHeight, 0.1f, 100.0f);
    
    perspectiveProjectionMatrix[1][1] = perspectiveProjectionMatrix[1][1] * (-1.0f);
    
    myUniformData.projectionMatrix = perspectiveProjectionMatrix;
    
    //map uniform buffer
    data = NULL;
    vkResult = vkMapMemory(vkDevice, uniformData_mercury.vkDeviceMemory, 0, sizeof(MyUniformData), 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkMapMemory() is failed and error code is %d for pyramid\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
   
    //#12 copy the data to maped buffer
    memcpy(data, &myUniformData, sizeof(MyUniformData));
    
    //Unmap memory
    vkUnmapMemory(vkDevice, uniformData_mercury.vkDeviceMemory);
    
    
    /************************************************************venus*************************************************/
    //venus
    //Note:glm follows column major matrix just like OpenGL, BUT unlike OpenGL its matrix array is 2D array 4x4 and not 1D array of 16 elements 
    memset((void*)&myUniformData, 0, sizeof(MyUniformData));
    //update matrices
    myUniformData.modelMatrix = glm::mat4(1.0f);  //Identity matrix
    
    translationMatrix = glm::mat4(1.0f);  //Identity matrix
    translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(4.5f * cos(angle_venus), 0.0f, 4.5f * sin(angle_venus)));
    
    translationMatrix1 = glm::mat4(1.0f);  //Identity matrix
    translationMatrix1 = glm::translate(glm::mat4(1.0f), glm::vec3(-7.0f, 0.0f, -10.0f));
    
    rotationMatrix_self = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_self = glm::rotate(glm::mat4(1.0f), glm::radians(angle_venus), glm::vec3(1.0f, 0.0f, 0.0f));
    
    rotationMatrix_orbit = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_orbit = glm::rotate(glm::mat4(1.0f), glm::radians(angle_venus), glm::vec3(0.0f, 1.0f, 0.0f));
    
    ScaleMatrix = glm::mat4(1.0f);  //Identity matrix
    ScaleMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(0.9f, 0.9f, 0.9f));
    
    myUniformData.modelMatrix =  translationMatrix1 * rotationMatrix_orbit * translationMatrix * ScaleMatrix * rotationMatrix_self;
    
    myUniformData.viewMatrix = glm::mat4(1.0f);  //Identity matrix
    //myUniformData.projectionMatrix = glm::mat4(1.0f);  //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    
    perspectiveProjectionMatrix = glm::perspective(glm::radians(45.0f), (float)winWidth/(float)winHeight, 0.1f, 100.0f);
    
    perspectiveProjectionMatrix[1][1] = perspectiveProjectionMatrix[1][1] * (-1.0f);
    
    myUniformData.projectionMatrix = perspectiveProjectionMatrix;
    
    //map uniform buffer
    data = NULL;
    vkResult = vkMapMemory(vkDevice, uniformData_venus.vkDeviceMemory, 0, sizeof(MyUniformData), 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkMapMemory() is failed and error code is %d for pyramid\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
   
    //#12 copy the data to maped buffer
    memcpy(data, &myUniformData, sizeof(MyUniformData));
    
    //Unmap memory
    vkUnmapMemory(vkDevice, uniformData_venus.vkDeviceMemory);
    
    /************************************************************earth*************************************************/
    //earth
    //Note:glm follows column major matrix just like OpenGL, BUT unlike OpenGL its matrix array is 2D array 4x4 and not 1D array of 16 elements 
    memset((void*)&myUniformData, 0, sizeof(MyUniformData));
    //update matrices
    myUniformData.modelMatrix = glm::mat4(1.0f);  //Identity matrix
    
    translationMatrix = glm::mat4(1.0f);  //Identity matrix
    translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(5.0f * cos(angle_earth), 0.0f, 5.0f * sin(angle_earth)));
    
    translationMatrix1 = glm::mat4(1.0f);  //Identity matrix
    translationMatrix1 = glm::translate(glm::mat4(1.0f), glm::vec3(-6.0f, 0.0f, -10.0f));
    
    rotationMatrix_self = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_self = glm::rotate(glm::mat4(1.0f), glm::radians(angle_earth), glm::vec3(1.0f, 0.0f, 0.0f));
    
    rotationMatrix_orbit = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_orbit = glm::rotate(glm::mat4(1.0f), glm::radians(angle_earth), glm::vec3(0.0f, 1.0f, 0.0f));
    
    ScaleMatrix = glm::mat4(1.0f);  //Identity matrix
    ScaleMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(0.7f, 0.7f, 0.7f));
    
    myUniformData.modelMatrix =  translationMatrix1 * rotationMatrix_orbit * translationMatrix * ScaleMatrix * rotationMatrix_self;
    
    // myUniformData.modelMatrix = rotationMatrix1 * myUniformData.modelMatrix ;
    
    myUniformData.viewMatrix = glm::mat4(1.0f);  //Identity matrix
    //myUniformData.projectionMatrix = glm::mat4(1.0f);  //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    
    perspectiveProjectionMatrix = glm::perspective(glm::radians(45.0f), (float)winWidth/(float)winHeight, 0.1f, 100.0f);
    
    perspectiveProjectionMatrix[1][1] = perspectiveProjectionMatrix[1][1] * (-1.0f);
    
    myUniformData.projectionMatrix = perspectiveProjectionMatrix;
    
    //map uniform buffer
    data = NULL;
    vkResult = vkMapMemory(vkDevice, uniformData_earth.vkDeviceMemory, 0, sizeof(MyUniformData), 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkMapMemory() is failed and error code is %d for pyramid\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
   
    //#12 copy the data to maped buffer
    memcpy(data, &myUniformData, sizeof(MyUniformData));
    
    //Unmap memory
    vkUnmapMemory(vkDevice, uniformData_earth.vkDeviceMemory);
    
    /************************************************************mars*************************************************/
    //mars
    //Note:glm follows column major matrix just like OpenGL, BUT unlike OpenGL its matrix array is 2D array 4x4 and not 1D array of 16 elements 
    memset((void*)&myUniformData, 0, sizeof(MyUniformData));
    //update matrices
    myUniformData.modelMatrix = glm::mat4(1.0f);  //Identity matrix
    
    translationMatrix = glm::mat4(1.0f);  //Identity matrix
    translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(5.0f * cos(angle_mars), 0.0f, 5.0f * sin(angle_mars)));
    
    translationMatrix1 = glm::mat4(1.0f);  //Identity matrix
    translationMatrix1 = glm::translate(glm::mat4(1.0f), glm::vec3(-4.0f, 0.0f, -10.0f));
    
    rotationMatrix_self = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_self = glm::rotate(glm::mat4(1.0f), glm::radians(angle_mars), glm::vec3(1.0f, 0.0f, 0.0f));
    
    rotationMatrix_orbit = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_orbit = glm::rotate(glm::mat4(1.0f), glm::radians(angle_mars), glm::vec3(0.0f, 1.0f, 0.0f));
    
    ScaleMatrix = glm::mat4(1.0f);  //Identity matrix
    ScaleMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(0.5f, 0.5f, 0.5f));
    
    myUniformData.modelMatrix =  translationMatrix1 * rotationMatrix_orbit * translationMatrix * ScaleMatrix * rotationMatrix_self;
    
    myUniformData.viewMatrix = glm::mat4(1.0f);  //Identity matrix
    //myUniformData.projectionMatrix = glm::mat4(1.0f);  //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    
    perspectiveProjectionMatrix = glm::perspective(glm::radians(45.0f), (float)winWidth/(float)winHeight, 0.1f, 100.0f);
    
    perspectiveProjectionMatrix[1][1] = perspectiveProjectionMatrix[1][1] * (-1.0f);
    
    myUniformData.projectionMatrix = perspectiveProjectionMatrix;
    
    //map uniform buffer
    data = NULL;
    vkResult = vkMapMemory(vkDevice, uniformData_mars.vkDeviceMemory, 0, sizeof(MyUniformData), 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkMapMemory() is failed and error code is %d for pyramid\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
   
    //#12 copy the data to maped buffer
    memcpy(data, &myUniformData, sizeof(MyUniformData));
    
    //Unmap memory
    vkUnmapMemory(vkDevice, uniformData_mars.vkDeviceMemory);
    
    /************************************************************jupitor*************************************************/
    //jupitor
    //Note:glm follows column major matrix just like OpenGL, BUT unlike OpenGL its matrix array is 2D array 4x4 and not 1D array of 16 elements 
    memset((void*)&myUniformData, 0, sizeof(MyUniformData));
    //update matrices
    myUniformData.modelMatrix = glm::mat4(1.0f);  //Identity matrix
    
    translationMatrix = glm::mat4(1.0f);  //Identity matrix
    translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(6.0f * cos(angle_jupitor), 0.0f, 6.0f * sin(angle_jupitor)));
    
    translationMatrix1 = glm::mat4(1.0f);  //Identity matrix
    translationMatrix1 = glm::translate(glm::mat4(1.0f), glm::vec3(-3.50f, 0.0f, -10.0f));
    
    rotationMatrix_self = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_self = glm::rotate(glm::mat4(1.0f), glm::radians(angle_jupitor), glm::vec3(1.0f, 0.0f, 0.0f));
    
    rotationMatrix_orbit = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_orbit = glm::rotate(glm::mat4(1.0f), glm::radians(angle_jupitor), glm::vec3(0.0f, 1.0f, 0.0f));
    
    ScaleMatrix = glm::mat4(1.0f);  //Identity matrix
    ScaleMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(2.0f, 2.0f, 2.0f));
    
    myUniformData.modelMatrix =  translationMatrix1 * rotationMatrix_orbit * translationMatrix * ScaleMatrix * rotationMatrix_self;
    
    myUniformData.viewMatrix = glm::mat4(1.0f);  //Identity matrix
    //myUniformData.projectionMatrix = glm::mat4(1.0f);  //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    
    perspectiveProjectionMatrix = glm::perspective(glm::radians(45.0f), (float)winWidth/(float)winHeight, 0.1f, 100.0f);
    
    perspectiveProjectionMatrix[1][1] = perspectiveProjectionMatrix[1][1] * (-1.0f);
    
    myUniformData.projectionMatrix = perspectiveProjectionMatrix;
    
    //map uniform buffer
    data = NULL;
    vkResult = vkMapMemory(vkDevice, uniformData_jupitor.vkDeviceMemory, 0, sizeof(MyUniformData), 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkMapMemory() is failed and error code is %d for pyramid\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
   
    //#12 copy the data to maped buffer
    memcpy(data, &myUniformData, sizeof(MyUniformData));
    
    //Unmap memory
    vkUnmapMemory(vkDevice, uniformData_jupitor.vkDeviceMemory);
    
    /************************************************************saturn*************************************************/
    //saturn
    //Note:glm follows column major matrix just like OpenGL, BUT unlike OpenGL its matrix array is 2D array 4x4 and not 1D array of 16 elements 
    memset((void*)&myUniformData, 0, sizeof(MyUniformData));
    //update matrices
    myUniformData.modelMatrix = glm::mat4(1.0f);  //Identity matrix
    
    translationMatrix = glm::mat4(1.0f);  //Identity matrix
    translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(6.5f * cos(angle_saturn), 0.0f, 6.5f * sin(angle_saturn)));
    
    translationMatrix1 = glm::mat4(1.0f);  //Identity matrix
    translationMatrix1 = glm::translate(glm::mat4(1.0f), glm::vec3(-3.0f, 0.0f, -10.0f));
    
    rotationMatrix_self = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_self = glm::rotate(glm::mat4(1.0f), glm::radians(angle_saturn), glm::vec3(1.0f, 0.0f, 0.0f));
    
    rotationMatrix_orbit = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_orbit = glm::rotate(glm::mat4(1.0f), glm::radians(angle_saturn), glm::vec3(0.0f, 1.0f, 0.0f));
    
    ScaleMatrix = glm::mat4(1.0f);  //Identity matrix
    ScaleMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(1.2f, 1.2f, 1.2f));
    
    myUniformData.modelMatrix =  translationMatrix1 * rotationMatrix_orbit * translationMatrix * ScaleMatrix * rotationMatrix_self;
    
    myUniformData.viewMatrix = glm::mat4(1.0f);  //Identity matrix
    //myUniformData.projectionMatrix = glm::mat4(1.0f);  //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    
    perspectiveProjectionMatrix = glm::perspective(glm::radians(45.0f), (float)winWidth/(float)winHeight, 0.1f, 100.0f);
    
    perspectiveProjectionMatrix[1][1] = perspectiveProjectionMatrix[1][1] * (-1.0f);
    
    myUniformData.projectionMatrix = perspectiveProjectionMatrix;
    
    //map uniform buffer
    data = NULL;
    vkResult = vkMapMemory(vkDevice, uniformData_saturn.vkDeviceMemory, 0, sizeof(MyUniformData), 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkMapMemory() is failed and error code is %d for pyramid\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
   
    //#12 copy the data to maped buffer
    memcpy(data, &myUniformData, sizeof(MyUniformData));
    
    //Unmap memory
    vkUnmapMemory(vkDevice, uniformData_saturn.vkDeviceMemory);
    
    /************************************************************uranus*************************************************/
    //uranus
    //Note:glm follows column major matrix just like OpenGL, BUT unlike OpenGL its matrix array is 2D array 4x4 and not 1D array of 16 elements 
    memset((void*)&myUniformData, 0, sizeof(MyUniformData));
    //update matrices
    myUniformData.modelMatrix = glm::mat4(1.0f);  //Identity matrix
    
    translationMatrix = glm::mat4(1.0f);  //Identity matrix
    translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(7.2f * cos(angle_uranus), 0.0f, 7.2f * sin(angle_uranus)));
    
    translationMatrix1 = glm::mat4(1.0f);  //Identity matrix
    translationMatrix1 = glm::translate(glm::mat4(1.0f), glm::vec3(-2.5f, 0.0f, -10.0f));
    
    rotationMatrix_self = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_self = glm::rotate(glm::mat4(1.0f), glm::radians(angle_uranus), glm::vec3(1.0f, 0.0f, 0.0f));
    
    rotationMatrix_orbit = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_orbit = glm::rotate(glm::mat4(1.0f), glm::radians(angle_uranus), glm::vec3(0.0f, 1.0f, 0.0f));
    
    ScaleMatrix = glm::mat4(1.0f);  //Identity matrix
    ScaleMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(1.1f, 1.1f, 1.1f));
    
    myUniformData.modelMatrix =  translationMatrix1 * rotationMatrix_orbit * translationMatrix * ScaleMatrix * rotationMatrix_self;
    
    myUniformData.viewMatrix = glm::mat4(1.0f);  //Identity matrix
    //myUniformData.projectionMatrix = glm::mat4(1.0f);  //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    
    perspectiveProjectionMatrix = glm::perspective(glm::radians(45.0f), (float)winWidth/(float)winHeight, 0.1f, 100.0f);
    
    perspectiveProjectionMatrix[1][1] = perspectiveProjectionMatrix[1][1] * (-1.0f);
    
    myUniformData.projectionMatrix = perspectiveProjectionMatrix;
    
    //map uniform buffer
    data = NULL;
    vkResult = vkMapMemory(vkDevice, uniformData_uranus.vkDeviceMemory, 0, sizeof(MyUniformData), 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkMapMemory() is failed and error code is %d for pyramid\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
   
    //#12 copy the data to maped buffer
    memcpy(data, &myUniformData, sizeof(MyUniformData));
    
    //Unmap memory
    vkUnmapMemory(vkDevice, uniformData_uranus.vkDeviceMemory);
    
    /************************************************************neptune*************************************************/
    //neptune
    //Note:glm follows column major matrix just like OpenGL, BUT unlike OpenGL its matrix array is 2D array 4x4 and not 1D array of 16 elements 
    memset((void*)&myUniformData, 0, sizeof(MyUniformData));
    //update matrices
    myUniformData.modelMatrix = glm::mat4(1.0f);  //Identity matrix
    
    translationMatrix = glm::mat4(1.0f);  //Identity matrix
    translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(7.5f * cos(angle_neptune), 0.0f, 7.5f * sin(angle_neptune)));
    
    translationMatrix1 = glm::mat4(1.0f);  //Identity matrix
    translationMatrix1 = glm::translate(glm::mat4(1.0f), glm::vec3(-2.0f, 0.0f, -10.0f));
    
    rotationMatrix_self = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_self = glm::rotate(glm::mat4(1.0f), glm::radians(angle_neptune), glm::vec3(1.0f, 0.0f, 0.0f));
    
    rotationMatrix_orbit = glm::mat4(1.0f);  //Identity matrix
    rotationMatrix_orbit = glm::rotate(glm::mat4(1.0f), glm::radians(angle_neptune), glm::vec3(0.0f, 1.0f, 0.0f));
    
    ScaleMatrix = glm::mat4(1.0f);  //Identity matrix
    ScaleMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(1.01f, 1.01f, 1.01f));
    
    myUniformData.modelMatrix =  translationMatrix1 * rotationMatrix_orbit * translationMatrix * ScaleMatrix * rotationMatrix_self;
    
    myUniformData.viewMatrix = glm::mat4(1.0f);  //Identity matrix
    //myUniformData.projectionMatrix = glm::mat4(1.0f);  //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    perspectiveProjectionMatrix = glm::mat4(1.0f); //Identity matrix
    
    perspectiveProjectionMatrix = glm::perspective(glm::radians(45.0f), (float)winWidth/(float)winHeight, 0.1f, 100.0f);
    
    perspectiveProjectionMatrix[1][1] = perspectiveProjectionMatrix[1][1] * (-1.0f);
    
    myUniformData.projectionMatrix = perspectiveProjectionMatrix;
    
    //map uniform buffer
    data = NULL;
    vkResult = vkMapMemory(vkDevice, uniformData_neptune.vkDeviceMemory, 0, sizeof(MyUniformData), 0, &data);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createUniformBuffer() --> vkMapMemory() is failed and error code is %d for pyramid\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
   
    //#12 copy the data to maped buffer
    memcpy(data, &myUniformData, sizeof(MyUniformData));
    
    //Unmap memory
    vkUnmapMemory(vkDevice, uniformData_neptune.vkDeviceMemory);
    
    return vkResult;
}

VkResult createShaders(void)
{
    //variable
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //for vertex shader
    const char* szFileName = "shader.vert.spv";
    FILE* fp = NULL;
    size_t size;
    
    //#6a
    fp = fopen(szFileName, "rb"); //open for reading in binary format
    if(fp == NULL)
    {
        fprintf(gpFile, "createShaders() --> fopen() failed to open shader.vert.spv\n");
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createShaders() --> fopen() succedded to open shader.vert.spv\n");
    }
    
    //#6b
    fseek(fp, 0L, SEEK_END);
    
    //#6c
    size = ftell(fp);
    if(size == 0)
    {
        fprintf(gpFile, "createShaders() --> ftell() failed to provide size of shader.vert.spv\n");
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        return vkResult;
    }
   
    //#6d
    fseek(fp, 0L, SEEK_SET); //reset to start
    
    //#6e
    char* shaderData = (char*)malloc(sizeof(char) * size);
    size_t retVal = fread(shaderData, size, 1, fp);
    if(retVal != 1)
    {
        fprintf(gpFile, "createShaders() --> fread() failed to read shader.vert.spv\n");
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createShaders() --> fread() succedded to read shader.vert.spv\n");
    }
    
    //#6f
    fclose(fp);
    
    //#7
    VkShaderModuleCreateInfo vkShaderModuleCreateInfo;
    memset((void*)&vkShaderModuleCreateInfo, 0, sizeof(VkShaderModuleCreateInfo));
    vkShaderModuleCreateInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    vkShaderModuleCreateInfo.pNext = NULL;
    vkShaderModuleCreateInfo.flags = 0; // reserved, hence must be zero
    vkShaderModuleCreateInfo.codeSize = size;
    vkShaderModuleCreateInfo.pCode = (uint32_t*)shaderData;

    //8
    vkResult = vkCreateShaderModule(vkDevice, &vkShaderModuleCreateInfo, NULL, &vkShaderModule_vertex_shader);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createShaders() --> vkCreateShaderModule() is failed & error code is %d\n", vkResult);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createShaders() --> vkCreateShaderModule() is succedded\n");
    }
    
    //#9
    if(shaderData)
    {
        free(shaderData);
        shaderData = NULL;
    }
    
    fprintf(gpFile, "createShaders() --> vertex Shader module successfully created\n");
    
    
    //for fragment shader
    szFileName = "shader.frag.spv";
    fp = NULL;
    size = 0;
    
    //#6a
    fp = fopen(szFileName, "rb"); //open for reading in binary format
    if(fp == NULL)
    {
        fprintf(gpFile, "createShaders() --> fopen() failed to open shader.frag.spv\n");
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createShaders() --> fopen() succedded to open shader.frag.spv\n");
    }
    
    //#6b
    fseek(fp, 0L, SEEK_END);
    
    //#6c
    size = ftell(fp);
    if(size == 0)
    {
        fprintf(gpFile, "createShaders() --> ftell() failed to provide size of shader.frag.spv\n");
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        return vkResult;
    }
   
    //#6d
    fseek(fp, 0L, SEEK_SET); //reset to start
    
    //#6e
    shaderData = (char*)malloc(sizeof(char) * size);
    retVal = fread(shaderData, size, 1, fp);
    if(retVal != 1)
    {
        fprintf(gpFile, "createShaders() --> fread() failed to read shader.frag.spv\n");
        vkResult = VK_ERROR_INITIALIZATION_FAILED;
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createShaders() --> fread() succedded to read shader.frag.spv\n");
    }
    
    //#6f
    fclose(fp);
    
    //#7
    memset((void*)&vkShaderModuleCreateInfo, 0, sizeof(VkShaderModuleCreateInfo));
    vkShaderModuleCreateInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    vkShaderModuleCreateInfo.pNext = NULL;
    vkShaderModuleCreateInfo.flags = 0; // reserved, hence must be zero
    vkShaderModuleCreateInfo.codeSize = size;
    vkShaderModuleCreateInfo.pCode = (uint32_t*)shaderData;

    //8
    vkResult = vkCreateShaderModule(vkDevice, &vkShaderModuleCreateInfo, NULL, &vkShaderModule_fragment_shader);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createShaders() --> vkCreateShaderModule() is failed & error code is %d\n", vkResult);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createShaders() --> vkCreateShaderModule() is succedded\n");
    }
    
    //#9
    if(shaderData)
    {
        free(shaderData);
        shaderData = NULL;
    }
    
    fprintf(gpFile, "createShaders() --> fragment Shader module successfully created\n");
     
    return (vkResult);
}

VkResult createDescriptorSetLayout(void)
{
    //variable
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //Descriptor set binding 
    //0th index --> uniform
    //1st index --> texture image
    VkDescriptorSetLayoutBinding vkDescriptorSetLayoutBinding_array[2];
    memset((void*)vkDescriptorSetLayoutBinding_array, 0, sizeof(VkDescriptorSetLayoutBinding) * _ARRAYSIZE(vkDescriptorSetLayoutBinding_array));
    
    // for MVP Uniform
    vkDescriptorSetLayoutBinding_array[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkDescriptorSetLayoutBinding_array[0].binding = 0;  // this zero related with zero binding in vertex shader
    vkDescriptorSetLayoutBinding_array[0].descriptorCount = 1;
    vkDescriptorSetLayoutBinding_array[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;  //shader stage
    vkDescriptorSetLayoutBinding_array[0].pImmutableSamplers = NULL;
    
    // for texture image and sampler
    vkDescriptorSetLayoutBinding_array[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkDescriptorSetLayoutBinding_array[1].binding = 1;  // this one related with 1 binding in fragment shader
    vkDescriptorSetLayoutBinding_array[1].descriptorCount = 1;
    vkDescriptorSetLayoutBinding_array[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;  //shader stage
    vkDescriptorSetLayoutBinding_array[1].pImmutableSamplers = NULL;
    
    
    VkDescriptorSetLayoutCreateInfo vkDescriptorSetLayoutCreateInfo;
    memset((void*)&vkDescriptorSetLayoutCreateInfo, 0, sizeof(VkDescriptorSetLayoutCreateInfo));
    vkDescriptorSetLayoutCreateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    vkDescriptorSetLayoutCreateInfo.pNext = NULL;
    vkDescriptorSetLayoutCreateInfo.flags = 0; //reserved
    vkDescriptorSetLayoutCreateInfo.bindingCount = _ARRAYSIZE(vkDescriptorSetLayoutBinding_array); // one DescriptorSet available
    vkDescriptorSetLayoutCreateInfo.pBindings = vkDescriptorSetLayoutBinding_array;
    
    vkResult = vkCreateDescriptorSetLayout(vkDevice, &vkDescriptorSetLayoutCreateInfo, NULL, &vkDescriptorSetLayout);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorSetLayout() --> vkCreateDescriptorSetLayour() is failed & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorSetLayout() --> vkCreateDescriptorSetLayour() is succedded\n");
        fflush(gpFile);
    }
    
    return (vkResult);
}

VkResult createPipelineLayout(void)
{
    //variable
    VkResult vkResult = VK_SUCCESS;
    
    //code
    VkPipelineLayoutCreateInfo vkPipelineLayoutCreateInfo;
    memset((void*)&vkPipelineLayoutCreateInfo, 0, sizeof(VkPipelineLayoutCreateInfo));
    vkPipelineLayoutCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    vkPipelineLayoutCreateInfo.pNext = NULL;
    vkPipelineLayoutCreateInfo.flags = 0; //reserved
    vkPipelineLayoutCreateInfo.setLayoutCount = 1;
    vkPipelineLayoutCreateInfo.pSetLayouts = &vkDescriptorSetLayout;
    vkPipelineLayoutCreateInfo.pushConstantRangeCount = 0;
    vkPipelineLayoutCreateInfo.pPushConstantRanges = NULL;
    
    vkResult = vkCreatePipelineLayout(vkDevice, &vkPipelineLayoutCreateInfo, NULL, &vkPipelineLayout);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createPipelineLayout() --> vkCreatePipelineLayout() is failed & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createPipelineLayout() --> vkCreatePipelineLayout() is succedded\n");
        fflush(gpFile);
    }
    
    return (vkResult);
}

VkResult createDescriptorPool(void)
{
    //variable
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //before creating actual descriptor pool, vulkan expects descriptor pool size
    //0th index --> uniform
    //1st index --> texture image
    VkDescriptorPoolSize vkDescriptorPoolSize_array[2];
    memset((void*)vkDescriptorPoolSize_array, 0, sizeof(VkDescriptorPoolSize) * _ARRAYSIZE(vkDescriptorPoolSize_array));
    
    //for MVP uniform
    vkDescriptorPoolSize_array[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkDescriptorPoolSize_array[0].descriptorCount = 1;
    
    //for Texture and sampler uniform 
    vkDescriptorPoolSize_array[1].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkDescriptorPoolSize_array[1].descriptorCount = 1;
    
    
    //Create the pool
    VkDescriptorPoolCreateInfo vkDescriptorPoolCreateInfo;
    memset((void*)&vkDescriptorPoolCreateInfo, 0, sizeof(VkDescriptorPoolCreateInfo));
    vkDescriptorPoolCreateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    vkDescriptorPoolCreateInfo.pNext = NULL;
    vkDescriptorPoolCreateInfo.flags = 0;
    vkDescriptorPoolCreateInfo.poolSizeCount = _ARRAYSIZE(vkDescriptorPoolSize_array);
    vkDescriptorPoolCreateInfo.pPoolSizes = vkDescriptorPoolSize_array;
    vkDescriptorPoolCreateInfo.maxSets = 9;
    
    vkResult = vkCreateDescriptorPool(vkDevice, &vkDescriptorPoolCreateInfo, NULL, &vkDescriptorPool);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorPool() --> vkCreateDescriptorPool() is failed & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorPool() --> vkCreateDescriptorPool() is succedded\n");
        fflush(gpFile);
    }
    
    return (vkResult);
}


VkResult createDescriptorSet(void)
{
    //variable
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //Initialize descriptorset allocation info
    VkDescriptorSetAllocateInfo vkDescriptorSetAllocateInfo;
    memset((void*)&vkDescriptorSetAllocateInfo, 0, sizeof(VkDescriptorSetAllocateInfo));
    vkDescriptorSetAllocateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    vkDescriptorSetAllocateInfo.pNext = NULL;
    vkDescriptorSetAllocateInfo.descriptorPool = vkDescriptorPool;
    vkDescriptorSetAllocateInfo.descriptorSetCount = 1;  //though we have 2 descriptors, 1 for MVP uniform and 1 for texture sampler, both are in 1 same descriptor set
    vkDescriptorSetAllocateInfo.pSetLayouts = &vkDescriptorSetLayout;
    
    
    //Sun
    vkResult = vkAllocateDescriptorSets(vkDevice, &vkDescriptorSetAllocateInfo, &vkDescriptorSet_sun);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is failed for sun & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is succedded for sun\n");
        fflush(gpFile);
    }
    
    //Describe whether we want buffer as uniform or image as uniform
    //For Buffer Uniform
    VkDescriptorBufferInfo vkDescriptorBufferInfo;
    memset((void*)&vkDescriptorBufferInfo, 0, sizeof(VkDescriptorBufferInfo));
    vkDescriptorBufferInfo.buffer = uniformData_sun.vkBuffer;
    vkDescriptorBufferInfo.offset = 0;
    vkDescriptorBufferInfo.range = sizeof(MyUniformData);
    
    
    //for Texture image & sampler
    VkDescriptorImageInfo vkDescriptorImageInfo;
    memset((void*)&vkDescriptorImageInfo, 0, sizeof(VkDescriptorImageInfo));
    vkDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkDescriptorImageInfo.imageView = vkImageView_texture_sun;
    vkDescriptorImageInfo.sampler = vkSampler_texture_sun;
    
   
    
    //now update the above descriptor set directly to shader
    //There are two ways to update -->driectly writing in shader or copying from one shader to another shader
    //we will be using writing to shader option, this require initilaization of following structure
    VkWriteDescriptorSet vkWriteDescriptorSet_array[2];
    //2 VkWriteDescriptorSet for above two steructure
    memset((void*)vkWriteDescriptorSet_array, 0, sizeof(VkWriteDescriptorSet) * _ARRAYSIZE(vkWriteDescriptorSet_array));

    //for MVP
    vkWriteDescriptorSet_array[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[0].dstSet = vkDescriptorSet_sun;
    vkWriteDescriptorSet_array[0].dstArrayElement = 0;
    vkWriteDescriptorSet_array[0].descriptorCount = 1;
    vkWriteDescriptorSet_array[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkWriteDescriptorSet_array[0].pBufferInfo = &vkDescriptorBufferInfo;
    vkWriteDescriptorSet_array[0].pImageInfo = NULL;
    vkWriteDescriptorSet_array[0].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[0].dstBinding = 0; //where to bind in shader, and our uniform is at binding 0 index in shader
    
    //for texture image & sampler
    vkWriteDescriptorSet_array[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[1].dstSet = vkDescriptorSet_sun;
    vkWriteDescriptorSet_array[1].dstArrayElement = 0;
    vkWriteDescriptorSet_array[1].descriptorCount = 1;
    vkWriteDescriptorSet_array[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkWriteDescriptorSet_array[1].pBufferInfo = NULL;
    vkWriteDescriptorSet_array[1].pImageInfo = &vkDescriptorImageInfo;
    vkWriteDescriptorSet_array[1].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[1].dstBinding = 1; //where to bind in shader, and our uniform is at binding 1 index in frag shader
    
    
    vkUpdateDescriptorSets(vkDevice, _ARRAYSIZE(vkWriteDescriptorSet_array), vkWriteDescriptorSet_array, 0, NULL);    
    fprintf(gpFile, "createDescriptorSet() --> vkUpdateDescriptorSets() is succedded\n");
    fflush(gpFile);
    
    /************************************************************************************************************************************/
    

    //Mercury
    vkResult = vkAllocateDescriptorSets(vkDevice, &vkDescriptorSetAllocateInfo, &vkDescriptorSet_mercury);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is failed for mercury & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is succedded for mercury\n");
        fflush(gpFile);
    }
    
    //Describe whether we want buffer as uniform or image as uniform
    //For Buffer Uniform
    memset((void*)&vkDescriptorBufferInfo, 0, sizeof(VkDescriptorBufferInfo));
    vkDescriptorBufferInfo.buffer = uniformData_mercury.vkBuffer;
    vkDescriptorBufferInfo.offset = 0;
    vkDescriptorBufferInfo.range = sizeof(MyUniformData);
    
    
    //for Texture image & sampler
    memset((void*)&vkDescriptorImageInfo, 0, sizeof(VkDescriptorImageInfo));
    vkDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkDescriptorImageInfo.imageView = vkImageView_texture_mercury;
    vkDescriptorImageInfo.sampler = vkSampler_texture_mercury;
    
   
    
    //now update the above descriptor set directly to shader
    //There are two ways to update -->driectly writing in shader or copying from one shader to another shader
    //we will be using writing to shader option, this require initilaization of following structure
    //2 VkWriteDescriptorSet for above two steructure
    memset((void*)vkWriteDescriptorSet_array, 0, sizeof(VkWriteDescriptorSet) * _ARRAYSIZE(vkWriteDescriptorSet_array));

    //for MVP
    vkWriteDescriptorSet_array[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[0].dstSet = vkDescriptorSet_mercury;
    vkWriteDescriptorSet_array[0].dstArrayElement = 0;
    vkWriteDescriptorSet_array[0].descriptorCount = 1;
    vkWriteDescriptorSet_array[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkWriteDescriptorSet_array[0].pBufferInfo = &vkDescriptorBufferInfo;
    vkWriteDescriptorSet_array[0].pImageInfo = NULL;
    vkWriteDescriptorSet_array[0].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[0].dstBinding = 0; //where to bind in shader, and our uniform is at binding 0 index in shader
    
    //for texture image & sampler
    vkWriteDescriptorSet_array[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[1].dstSet = vkDescriptorSet_mercury;
    vkWriteDescriptorSet_array[1].dstArrayElement = 0;
    vkWriteDescriptorSet_array[1].descriptorCount = 1;
    vkWriteDescriptorSet_array[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkWriteDescriptorSet_array[1].pBufferInfo = NULL;
    vkWriteDescriptorSet_array[1].pImageInfo = &vkDescriptorImageInfo;
    vkWriteDescriptorSet_array[1].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[1].dstBinding = 1; //where to bind in shader, and our uniform is at binding 1 index in frag shader
    
    
    vkUpdateDescriptorSets(vkDevice, _ARRAYSIZE(vkWriteDescriptorSet_array), vkWriteDescriptorSet_array, 0, NULL);    
    fprintf(gpFile, "createDescriptorSet() --> vkUpdateDescriptorSets() is succedded\n");
    fflush(gpFile);
    
    
    /*******************************************************VENUS*****************************************************************************/
    

    //Venus
    vkResult = vkAllocateDescriptorSets(vkDevice, &vkDescriptorSetAllocateInfo, &vkDescriptorSet_venus);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is failed for venus & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is succedded venus\n");
        fflush(gpFile);
    }
    
    //Describe whether we want buffer as uniform or image as uniform
    //For Buffer Uniform
    memset((void*)&vkDescriptorBufferInfo, 0, sizeof(VkDescriptorBufferInfo));
    vkDescriptorBufferInfo.buffer = uniformData_venus.vkBuffer;
    vkDescriptorBufferInfo.offset = 0;
    vkDescriptorBufferInfo.range = sizeof(MyUniformData);
    
    
    //for Texture image & sampler
    memset((void*)&vkDescriptorImageInfo, 0, sizeof(VkDescriptorImageInfo));
    vkDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkDescriptorImageInfo.imageView = vkImageView_texture_venus;
    vkDescriptorImageInfo.sampler = vkSampler_texture_venus;
    
   
    
    //now update the above descriptor set directly to shader
    //There are two ways to update -->driectly writing in shader or copying from one shader to another shader
    //we will be using writing to shader option, this require initilaization of following structure
    //2 VkWriteDescriptorSet for above two steructure
    memset((void*)vkWriteDescriptorSet_array, 0, sizeof(VkWriteDescriptorSet) * _ARRAYSIZE(vkWriteDescriptorSet_array));

    //for MVP
    vkWriteDescriptorSet_array[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[0].dstSet = vkDescriptorSet_venus;
    vkWriteDescriptorSet_array[0].dstArrayElement = 0;
    vkWriteDescriptorSet_array[0].descriptorCount = 1;
    vkWriteDescriptorSet_array[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkWriteDescriptorSet_array[0].pBufferInfo = &vkDescriptorBufferInfo;
    vkWriteDescriptorSet_array[0].pImageInfo = NULL;
    vkWriteDescriptorSet_array[0].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[0].dstBinding = 0; //where to bind in shader, and our uniform is at binding 0 index in shader
    
    //for texture image & sampler
    vkWriteDescriptorSet_array[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[1].dstSet = vkDescriptorSet_venus;
    vkWriteDescriptorSet_array[1].dstArrayElement = 0;
    vkWriteDescriptorSet_array[1].descriptorCount = 1;
    vkWriteDescriptorSet_array[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkWriteDescriptorSet_array[1].pBufferInfo = NULL;
    vkWriteDescriptorSet_array[1].pImageInfo = &vkDescriptorImageInfo;
    vkWriteDescriptorSet_array[1].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[1].dstBinding = 1; //where to bind in shader, and our uniform is at binding 1 index in frag shader
    
    
    vkUpdateDescriptorSets(vkDevice, _ARRAYSIZE(vkWriteDescriptorSet_array), vkWriteDescriptorSet_array, 0, NULL);    
    fprintf(gpFile, "createDescriptorSet() --> vkUpdateDescriptorSets() is succedded\n");
    fflush(gpFile);
    
    /*******************************************************earth*****************************************************************************/
    

    //earth
    vkResult = vkAllocateDescriptorSets(vkDevice, &vkDescriptorSetAllocateInfo, &vkDescriptorSet_earth);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is failed for earth & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is succedded for earth\n");
        fflush(gpFile);
    }
    
    //Describe whether we want buffer as uniform or image as uniform
    //For Buffer Uniform
    memset((void*)&vkDescriptorBufferInfo, 0, sizeof(VkDescriptorBufferInfo));
    vkDescriptorBufferInfo.buffer = uniformData_earth.vkBuffer;
    vkDescriptorBufferInfo.offset = 0;
    vkDescriptorBufferInfo.range = sizeof(MyUniformData);
    
    
    //for Texture image & sampler
    memset((void*)&vkDescriptorImageInfo, 0, sizeof(VkDescriptorImageInfo));
    vkDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkDescriptorImageInfo.imageView = vkImageView_texture_earth;
    vkDescriptorImageInfo.sampler = vkSampler_texture_earth;
    
   
    
    //now update the above descriptor set directly to shader
    //There are two ways to update -->driectly writing in shader or copying from one shader to another shader
    //we will be using writing to shader option, this require initilaization of following structure
    //2 VkWriteDescriptorSet for above two steructure
    memset((void*)vkWriteDescriptorSet_array, 0, sizeof(VkWriteDescriptorSet) * _ARRAYSIZE(vkWriteDescriptorSet_array));

    //for MVP
    vkWriteDescriptorSet_array[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[0].dstSet = vkDescriptorSet_earth;
    vkWriteDescriptorSet_array[0].dstArrayElement = 0;
    vkWriteDescriptorSet_array[0].descriptorCount = 1;
    vkWriteDescriptorSet_array[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkWriteDescriptorSet_array[0].pBufferInfo = &vkDescriptorBufferInfo;
    vkWriteDescriptorSet_array[0].pImageInfo = NULL;
    vkWriteDescriptorSet_array[0].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[0].dstBinding = 0; //where to bind in shader, and our uniform is at binding 0 index in shader
    
    //for texture image & sampler
    vkWriteDescriptorSet_array[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[1].dstSet = vkDescriptorSet_earth;
    vkWriteDescriptorSet_array[1].dstArrayElement = 0;
    vkWriteDescriptorSet_array[1].descriptorCount = 1;
    vkWriteDescriptorSet_array[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkWriteDescriptorSet_array[1].pBufferInfo = NULL;
    vkWriteDescriptorSet_array[1].pImageInfo = &vkDescriptorImageInfo;
    vkWriteDescriptorSet_array[1].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[1].dstBinding = 1; //where to bind in shader, and our uniform is at binding 1 index in frag shader
    
    
    vkUpdateDescriptorSets(vkDevice, _ARRAYSIZE(vkWriteDescriptorSet_array), vkWriteDescriptorSet_array, 0, NULL);    
    fprintf(gpFile, "createDescriptorSet() --> vkUpdateDescriptorSets() is succedded\n");
    fflush(gpFile);
    
    /*******************************************************mars*****************************************************************************/
    

    //mars
    vkResult = vkAllocateDescriptorSets(vkDevice, &vkDescriptorSetAllocateInfo, &vkDescriptorSet_mars);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is failed for mars & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is succedded for mars\n");
        fflush(gpFile);
    }
    
    //Describe whether we want buffer as uniform or image as uniform
    //For Buffer Uniform
    memset((void*)&vkDescriptorBufferInfo, 0, sizeof(VkDescriptorBufferInfo));
    vkDescriptorBufferInfo.buffer = uniformData_mars.vkBuffer;
    vkDescriptorBufferInfo.offset = 0;
    vkDescriptorBufferInfo.range = sizeof(MyUniformData);
    
    
    //for Texture image & sampler
    memset((void*)&vkDescriptorImageInfo, 0, sizeof(VkDescriptorImageInfo));
    vkDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkDescriptorImageInfo.imageView = vkImageView_texture_mars;
    vkDescriptorImageInfo.sampler = vkSampler_texture_mars;
    
   
    
    //now update the above descriptor set directly to shader
    //There are two ways to update -->driectly writing in shader or copying from one shader to another shader
    //we will be using writing to shader option, this require initilaization of following structure
    //2 VkWriteDescriptorSet for above two steructure
    memset((void*)vkWriteDescriptorSet_array, 0, sizeof(VkWriteDescriptorSet) * _ARRAYSIZE(vkWriteDescriptorSet_array));

    //for MVP
    vkWriteDescriptorSet_array[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[0].dstSet = vkDescriptorSet_mars;
    vkWriteDescriptorSet_array[0].dstArrayElement = 0;
    vkWriteDescriptorSet_array[0].descriptorCount = 1;
    vkWriteDescriptorSet_array[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkWriteDescriptorSet_array[0].pBufferInfo = &vkDescriptorBufferInfo;
    vkWriteDescriptorSet_array[0].pImageInfo = NULL;
    vkWriteDescriptorSet_array[0].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[0].dstBinding = 0; //where to bind in shader, and our uniform is at binding 0 index in shader
    
    //for texture image & sampler
    vkWriteDescriptorSet_array[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[1].dstSet = vkDescriptorSet_mars;
    vkWriteDescriptorSet_array[1].dstArrayElement = 0;
    vkWriteDescriptorSet_array[1].descriptorCount = 1;
    vkWriteDescriptorSet_array[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkWriteDescriptorSet_array[1].pBufferInfo = NULL;
    vkWriteDescriptorSet_array[1].pImageInfo = &vkDescriptorImageInfo;
    vkWriteDescriptorSet_array[1].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[1].dstBinding = 1; //where to bind in shader, and our uniform is at binding 1 index in frag shader
    
    
    vkUpdateDescriptorSets(vkDevice, _ARRAYSIZE(vkWriteDescriptorSet_array), vkWriteDescriptorSet_array, 0, NULL);    
    fprintf(gpFile, "createDescriptorSet() --> vkUpdateDescriptorSets() is succedded\n");
        fflush(gpFile);
    
    /*******************************************************jupitor*****************************************************************************/
    

    //jupitor
    vkResult = vkAllocateDescriptorSets(vkDevice, &vkDescriptorSetAllocateInfo, &vkDescriptorSet_jupitor);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is failed for jupitor & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is succedded for jupitor\n");
        fflush(gpFile);
    }
    
    //Describe whether we want buffer as uniform or image as uniform
    //For Buffer Uniform
    memset((void*)&vkDescriptorBufferInfo, 0, sizeof(VkDescriptorBufferInfo));
    vkDescriptorBufferInfo.buffer = uniformData_jupitor.vkBuffer;
    vkDescriptorBufferInfo.offset = 0;
    vkDescriptorBufferInfo.range = sizeof(MyUniformData);
    
    
    //for Texture image & sampler
    memset((void*)&vkDescriptorImageInfo, 0, sizeof(VkDescriptorImageInfo));
    vkDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkDescriptorImageInfo.imageView = vkImageView_texture_jupitor;
    vkDescriptorImageInfo.sampler = vkSampler_texture_jupitor;
    
   
    
    //now update the above descriptor set directly to shader
    //There are two ways to update -->driectly writing in shader or copying from one shader to another shader
    //we will be using writing to shader option, this require initilaization of following structure
    //2 VkWriteDescriptorSet for above two steructure
    memset((void*)vkWriteDescriptorSet_array, 0, sizeof(VkWriteDescriptorSet) * _ARRAYSIZE(vkWriteDescriptorSet_array));

    //for MVP
    vkWriteDescriptorSet_array[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[0].dstSet = vkDescriptorSet_jupitor;
    vkWriteDescriptorSet_array[0].dstArrayElement = 0;
    vkWriteDescriptorSet_array[0].descriptorCount = 1;
    vkWriteDescriptorSet_array[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkWriteDescriptorSet_array[0].pBufferInfo = &vkDescriptorBufferInfo;
    vkWriteDescriptorSet_array[0].pImageInfo = NULL;
    vkWriteDescriptorSet_array[0].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[0].dstBinding = 0; //where to bind in shader, and our uniform is at binding 0 index in shader
    
    //for texture image & sampler
    vkWriteDescriptorSet_array[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[1].dstSet = vkDescriptorSet_jupitor;
    vkWriteDescriptorSet_array[1].dstArrayElement = 0;
    vkWriteDescriptorSet_array[1].descriptorCount = 1;
    vkWriteDescriptorSet_array[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkWriteDescriptorSet_array[1].pBufferInfo = NULL;
    vkWriteDescriptorSet_array[1].pImageInfo = &vkDescriptorImageInfo;
    vkWriteDescriptorSet_array[1].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[1].dstBinding = 1; //where to bind in shader, and our uniform is at binding 1 index in frag shader
    
    
    vkUpdateDescriptorSets(vkDevice, _ARRAYSIZE(vkWriteDescriptorSet_array), vkWriteDescriptorSet_array, 0, NULL);    
    fprintf(gpFile, "createDescriptorSet() --> vkUpdateDescriptorSets() is succedded\n");
        fflush(gpFile);
    
    /*******************************************************saturn*****************************************************************************/
    

    //saturn
    vkResult = vkAllocateDescriptorSets(vkDevice, &vkDescriptorSetAllocateInfo, &vkDescriptorSet_saturn);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is failed for saturn & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is succedded\n");
        fflush(gpFile);
    }
    
    //Describe whether we want buffer as uniform or image as uniform
    //For Buffer Uniform
    memset((void*)&vkDescriptorBufferInfo, 0, sizeof(VkDescriptorBufferInfo));
    vkDescriptorBufferInfo.buffer = uniformData_saturn.vkBuffer;
    vkDescriptorBufferInfo.offset = 0;
    vkDescriptorBufferInfo.range = sizeof(MyUniformData);
    
    
    //for Texture image & sampler
    memset((void*)&vkDescriptorImageInfo, 0, sizeof(VkDescriptorImageInfo));
    vkDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkDescriptorImageInfo.imageView = vkImageView_texture_saturn;
    vkDescriptorImageInfo.sampler = vkSampler_texture_saturn;
    
   
    
    //now update the above descriptor set directly to shader
    //There are two ways to update -->driectly writing in shader or copying from one shader to another shader
    //we will be using writing to shader option, this require initilaization of following structure
    //2 VkWriteDescriptorSet for above two steructure
    memset((void*)vkWriteDescriptorSet_array, 0, sizeof(VkWriteDescriptorSet) * _ARRAYSIZE(vkWriteDescriptorSet_array));

    //for MVP
    vkWriteDescriptorSet_array[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[0].dstSet = vkDescriptorSet_saturn;
    vkWriteDescriptorSet_array[0].dstArrayElement = 0;
    vkWriteDescriptorSet_array[0].descriptorCount = 1;
    vkWriteDescriptorSet_array[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkWriteDescriptorSet_array[0].pBufferInfo = &vkDescriptorBufferInfo;
    vkWriteDescriptorSet_array[0].pImageInfo = NULL;
    vkWriteDescriptorSet_array[0].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[0].dstBinding = 0; //where to bind in shader, and our uniform is at binding 0 index in shader
    
    //for texture image & sampler
    vkWriteDescriptorSet_array[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[1].dstSet = vkDescriptorSet_saturn;
    vkWriteDescriptorSet_array[1].dstArrayElement = 0;
    vkWriteDescriptorSet_array[1].descriptorCount = 1;
    vkWriteDescriptorSet_array[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkWriteDescriptorSet_array[1].pBufferInfo = NULL;
    vkWriteDescriptorSet_array[1].pImageInfo = &vkDescriptorImageInfo;
    vkWriteDescriptorSet_array[1].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[1].dstBinding = 1; //where to bind in shader, and our uniform is at binding 1 index in frag shader
    
    
    vkUpdateDescriptorSets(vkDevice, _ARRAYSIZE(vkWriteDescriptorSet_array), vkWriteDescriptorSet_array, 0, NULL);    
    fprintf(gpFile, "createDescriptorSet() --> vkUpdateDescriptorSets() is succedded\n");
        fflush(gpFile);
    
    /*******************************************************uranus*****************************************************************************/
    

    //uranus
    vkResult = vkAllocateDescriptorSets(vkDevice, &vkDescriptorSetAllocateInfo, &vkDescriptorSet_uranus);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is failed for uranus & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is succedded\n");
        fflush(gpFile);
    }
    
    //Describe whether we want buffer as uniform or image as uniform
    //For Buffer Uniform
    memset((void*)&vkDescriptorBufferInfo, 0, sizeof(VkDescriptorBufferInfo));
    vkDescriptorBufferInfo.buffer = uniformData_uranus.vkBuffer;
    vkDescriptorBufferInfo.offset = 0;
    vkDescriptorBufferInfo.range = sizeof(MyUniformData);
    
    
    //for Texture image & sampler
    memset((void*)&vkDescriptorImageInfo, 0, sizeof(VkDescriptorImageInfo));
    vkDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkDescriptorImageInfo.imageView = vkImageView_texture_uranus;
    vkDescriptorImageInfo.sampler = vkSampler_texture_uranus;
    
   
    
    //now update the above descriptor set directly to shader
    //There are two ways to update -->driectly writing in shader or copying from one shader to another shader
    //we will be using writing to shader option, this require initilaization of following structure
    //2 VkWriteDescriptorSet for above two steructure
    memset((void*)vkWriteDescriptorSet_array, 0, sizeof(VkWriteDescriptorSet) * _ARRAYSIZE(vkWriteDescriptorSet_array));

    //for MVP
    vkWriteDescriptorSet_array[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[0].dstSet = vkDescriptorSet_uranus;
    vkWriteDescriptorSet_array[0].dstArrayElement = 0;
    vkWriteDescriptorSet_array[0].descriptorCount = 1;
    vkWriteDescriptorSet_array[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkWriteDescriptorSet_array[0].pBufferInfo = &vkDescriptorBufferInfo;
    vkWriteDescriptorSet_array[0].pImageInfo = NULL;
    vkWriteDescriptorSet_array[0].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[0].dstBinding = 0; //where to bind in shader, and our uniform is at binding 0 index in shader
    
    //for texture image & sampler
    vkWriteDescriptorSet_array[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[1].dstSet = vkDescriptorSet_uranus;
    vkWriteDescriptorSet_array[1].dstArrayElement = 0;
    vkWriteDescriptorSet_array[1].descriptorCount = 1;
    vkWriteDescriptorSet_array[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkWriteDescriptorSet_array[1].pBufferInfo = NULL;
    vkWriteDescriptorSet_array[1].pImageInfo = &vkDescriptorImageInfo;
    vkWriteDescriptorSet_array[1].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[1].dstBinding = 1; //where to bind in shader, and our uniform is at binding 1 index in frag shader
    
    
    vkUpdateDescriptorSets(vkDevice, _ARRAYSIZE(vkWriteDescriptorSet_array), vkWriteDescriptorSet_array, 0, NULL);    
    fprintf(gpFile, "createDescriptorSet() --> vkUpdateDescriptorSets() is succedded\n");
        fflush(gpFile);
    
    /*******************************************************neptune*****************************************************************************/
    

    //neptune
    vkResult = vkAllocateDescriptorSets(vkDevice, &vkDescriptorSetAllocateInfo, &vkDescriptorSet_neptune);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is failed for neptune & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createDescriptorSet() --> vkAllocateDescriptorSets() is succedded\n");
        fflush(gpFile);
    }
    
    //Describe whether we want buffer as uniform or image as uniform
    //For Buffer Uniform
    memset((void*)&vkDescriptorBufferInfo, 0, sizeof(VkDescriptorBufferInfo));
    vkDescriptorBufferInfo.buffer = uniformData_neptune.vkBuffer;
    vkDescriptorBufferInfo.offset = 0;
    vkDescriptorBufferInfo.range = sizeof(MyUniformData);
    
    
    //for Texture image & sampler
    memset((void*)&vkDescriptorImageInfo, 0, sizeof(VkDescriptorImageInfo));
    vkDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    vkDescriptorImageInfo.imageView = vkImageView_texture_neptune;
    vkDescriptorImageInfo.sampler = vkSampler_texture_neptune;
    
   
    
    //now update the above descriptor set directly to shader
    //There are two ways to update -->driectly writing in shader or copying from one shader to another shader
    //we will be using writing to shader option, this require initilaization of following structure
    //2 VkWriteDescriptorSet for above two steructure
    memset((void*)vkWriteDescriptorSet_array, 0, sizeof(VkWriteDescriptorSet) * _ARRAYSIZE(vkWriteDescriptorSet_array));

    //for MVP
    vkWriteDescriptorSet_array[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[0].dstSet = vkDescriptorSet_neptune;
    vkWriteDescriptorSet_array[0].dstArrayElement = 0;
    vkWriteDescriptorSet_array[0].descriptorCount = 1;
    vkWriteDescriptorSet_array[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    vkWriteDescriptorSet_array[0].pBufferInfo = &vkDescriptorBufferInfo;
    vkWriteDescriptorSet_array[0].pImageInfo = NULL;
    vkWriteDescriptorSet_array[0].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[0].dstBinding = 0; //where to bind in shader, and our uniform is at binding 0 index in shader
    
    //for texture image & sampler
    vkWriteDescriptorSet_array[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vkWriteDescriptorSet_array[1].dstSet = vkDescriptorSet_neptune;
    vkWriteDescriptorSet_array[1].dstArrayElement = 0;
    vkWriteDescriptorSet_array[1].descriptorCount = 1;
    vkWriteDescriptorSet_array[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    vkWriteDescriptorSet_array[1].pBufferInfo = NULL;
    vkWriteDescriptorSet_array[1].pImageInfo = &vkDescriptorImageInfo;
    vkWriteDescriptorSet_array[1].pTexelBufferView = NULL;
    vkWriteDescriptorSet_array[1].dstBinding = 1; //where to bind in shader, and our uniform is at binding 1 index in frag shader
    
    
    vkUpdateDescriptorSets(vkDevice, _ARRAYSIZE(vkWriteDescriptorSet_array), vkWriteDescriptorSet_array, 0, NULL);    
    fprintf(gpFile, "createDescriptorSet() --> vkUpdateDescriptorSets() is succedded\n");
        fflush(gpFile);
    
    return (vkResult);
}

VkResult createRenderPass(void)
{
    //variable
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //step1:
    VkAttachmentDescription vkAttachmentDescription_array[2];  //for both color and depth
    memset((void*)vkAttachmentDescription_array, 0, sizeof(VkAttachmentDescription) * _ARRAYSIZE(vkAttachmentDescription_array));
    
    //for color
    vkAttachmentDescription_array[0].flags = 0; //For embedded devices
    vkAttachmentDescription_array[0].format = vkFormat_color;
    vkAttachmentDescription_array[0].samples = VK_SAMPLE_COUNT_1_BIT;
    vkAttachmentDescription_array[0].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    vkAttachmentDescription_array[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    vkAttachmentDescription_array[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    vkAttachmentDescription_array[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    vkAttachmentDescription_array[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    vkAttachmentDescription_array[0].finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
    
    //for depth
    vkAttachmentDescription_array[1].flags = 0; //For embedded devices
    vkAttachmentDescription_array[1].format = vkFormat_depth;
    vkAttachmentDescription_array[1].samples = VK_SAMPLE_COUNT_1_BIT;
    vkAttachmentDescription_array[1].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    vkAttachmentDescription_array[1].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    vkAttachmentDescription_array[1].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    vkAttachmentDescription_array[1].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    vkAttachmentDescription_array[1].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    vkAttachmentDescription_array[1].finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
    

    //Step2:
    //for color attachment
    VkAttachmentReference vkAttachmentReference_color;
    memset((void*)&vkAttachmentReference_color, 0, sizeof(VkAttachmentReference));
    
    vkAttachmentReference_color.attachment = 0;  //index number
    vkAttachmentReference_color.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; //how to keep/desires/use the layout of image
    
    //for depth attachment
    VkAttachmentReference vkAttachmentReference_depth;
    memset((void*)&vkAttachmentReference_depth, 0, sizeof(VkAttachmentReference));
    
    vkAttachmentReference_depth.attachment = 1;  //index number
    vkAttachmentReference_depth.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL; //how to keep/desires/use the layout of image
    
    
    //step3:
    VkSubpassDescription vkSubpassDescription;
    memset((void*)&vkSubpassDescription, 0, sizeof(VkSubpassDescription));
    
    vkSubpassDescription.flags = 0;
    vkSubpassDescription.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    vkSubpassDescription.inputAttachmentCount = 0;
    vkSubpassDescription.pInputAttachments = NULL;
    // vkSubpassDescription.colorAttachmentCount = _ARRAYSIZE(vkAttachmentDescription_array);  // earlier code
    vkSubpassDescription.colorAttachmentCount = 1;  //Recommended change for Depth:: This count should be of count vkAttachmentReference of color count
    vkSubpassDescription.pColorAttachments = &vkAttachmentReference_color;
    vkSubpassDescription.pResolveAttachments = NULL;
    vkSubpassDescription.pDepthStencilAttachment = &vkAttachmentReference_depth;
    vkSubpassDescription.preserveAttachmentCount = 0;
    vkSubpassDescription.pPreserveAttachments = NULL;
    
    //step4:
    VkRenderPassCreateInfo vkRenderPassCreateInfo;
    memset((void*)&vkRenderPassCreateInfo, 0, sizeof(VkRenderPassCreateInfo));
    
    vkRenderPassCreateInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    vkRenderPassCreateInfo.pNext = NULL;
    vkRenderPassCreateInfo.flags = 0;
    vkRenderPassCreateInfo.attachmentCount = _ARRAYSIZE(vkAttachmentDescription_array);
    vkRenderPassCreateInfo.pAttachments = vkAttachmentDescription_array;
    vkRenderPassCreateInfo.subpassCount = 1;
    vkRenderPassCreateInfo.pSubpasses = &vkSubpassDescription;
    vkRenderPassCreateInfo.dependencyCount = 0;
    vkRenderPassCreateInfo.pDependencies = NULL;
    
    
    //step5:
    vkResult = vkCreateRenderPass(vkDevice, 
                                  &vkRenderPassCreateInfo,
                                  NULL,
                                  &vkRenderPass);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createRenderPass() --> vkCreateRenderPass() is failed & error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createRenderPass() --> vkCreateRenderPass() is succedded\n");
        fflush(gpFile);
    }
    
    return (vkResult);
}

VkResult createPipeline(void)
{
    //variables
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //#1: vertex input state
    VkVertexInputBindingDescription vkVertexInputBindingDescription_array[3];  //for position, normal texcoord
    memset((void*)vkVertexInputBindingDescription_array, 0, sizeof(VkVertexInputBindingDescription) * _ARRAYSIZE(vkVertexInputBindingDescription_array));
    //position
    vkVertexInputBindingDescription_array[0].binding = 0;
    vkVertexInputBindingDescription_array[0].stride = sizeof(float) * 3;
    vkVertexInputBindingDescription_array[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    
    //for normal
    vkVertexInputBindingDescription_array[1].binding = 1;
    vkVertexInputBindingDescription_array[1].stride = sizeof(float) * 3;
    vkVertexInputBindingDescription_array[1].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    
    //for texcoord
    vkVertexInputBindingDescription_array[2].binding = 2;
    vkVertexInputBindingDescription_array[2].stride = sizeof(float) * 2;
    vkVertexInputBindingDescription_array[2].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

    
    VkVertexInputAttributeDescription vkVertexInputAttributeDescription_array[3]; //position, normal, texcoord
    memset((void*)vkVertexInputAttributeDescription_array, 0, sizeof(VkVertexInputAttributeDescription) * _ARRAYSIZE(vkVertexInputAttributeDescription_array));
    
    //position
    vkVertexInputAttributeDescription_array[0].binding = 0;
    vkVertexInputAttributeDescription_array[0].location = 0;
    vkVertexInputAttributeDescription_array[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    vkVertexInputAttributeDescription_array[0].offset = 0;
    
    //normal
    vkVertexInputAttributeDescription_array[1].binding = 1;
    vkVertexInputAttributeDescription_array[1].location = 1;
    vkVertexInputAttributeDescription_array[1].format = VK_FORMAT_R32G32B32_SFLOAT;
    vkVertexInputAttributeDescription_array[1].offset = 0;
    
    //texcoord
    vkVertexInputAttributeDescription_array[2].binding = 2;
    vkVertexInputAttributeDescription_array[2].location = 2;
    vkVertexInputAttributeDescription_array[2].format = VK_FORMAT_R32G32_SFLOAT;
    vkVertexInputAttributeDescription_array[2].offset = 0;
    
    
    
    
    VkPipelineVertexInputStateCreateInfo vkPipelineVertexInputStateCreateInfo;
    memset((void*)&vkPipelineVertexInputStateCreateInfo, 0, sizeof(VkPipelineVertexInputStateCreateInfo));
    vkPipelineVertexInputStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vkPipelineVertexInputStateCreateInfo.pNext = NULL;
    vkPipelineVertexInputStateCreateInfo.flags = 0;
    vkPipelineVertexInputStateCreateInfo.vertexBindingDescriptionCount = _ARRAYSIZE(vkVertexInputBindingDescription_array);
    vkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions = vkVertexInputBindingDescription_array;
    vkPipelineVertexInputStateCreateInfo.vertexAttributeDescriptionCount = _ARRAYSIZE(vkVertexInputAttributeDescription_array);
    vkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions = vkVertexInputAttributeDescription_array;
    
    
    //#2: Input assembly State
    VkPipelineInputAssemblyStateCreateInfo vkPipelineInputAssemblyStateCreateInfo;
    memset((void*)&vkPipelineInputAssemblyStateCreateInfo, 0, sizeof(VkPipelineInputAssemblyStateCreateInfo));
    vkPipelineInputAssemblyStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    vkPipelineInputAssemblyStateCreateInfo.pNext = NULL;
    vkPipelineInputAssemblyStateCreateInfo.flags = 0;
    vkPipelineInputAssemblyStateCreateInfo.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    vkPipelineInputAssemblyStateCreateInfo.primitiveRestartEnable = 0;
    
    
    //#3: Rasterizer state
    VkPipelineRasterizationStateCreateInfo vkPipelineRasterizationStateCreateInfo;
    memset((void*)&vkPipelineRasterizationStateCreateInfo, 0, sizeof(VkPipelineRasterizationStateCreateInfo));
    vkPipelineRasterizationStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    vkPipelineRasterizationStateCreateInfo.pNext = NULL;
    vkPipelineRasterizationStateCreateInfo.flags = 0;
    vkPipelineRasterizationStateCreateInfo.polygonMode = VK_POLYGON_MODE_FILL;
    vkPipelineRasterizationStateCreateInfo.cullMode = VK_CULL_MODE_NONE;
    vkPipelineRasterizationStateCreateInfo.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    vkPipelineRasterizationStateCreateInfo.lineWidth = 1.0f;
    
    //#4: Color Blend State
    VkPipelineColorBlendAttachmentState vkPipelineColorBlendAttachmentState_array[1];
    memset((void*)vkPipelineColorBlendAttachmentState_array, 0, sizeof(VkPipelineColorBlendAttachmentState) * _ARRAYSIZE(vkPipelineColorBlendAttachmentState_array));
    vkPipelineColorBlendAttachmentState_array[0].blendEnable = VK_FALSE;
    vkPipelineColorBlendAttachmentState_array[0].colorWriteMask = 0xF;
    
    VkPipelineColorBlendStateCreateInfo vkPipelineColorBlendStateCreateInfo;
    memset((void*)&vkPipelineColorBlendStateCreateInfo, 0, sizeof(VkPipelineColorBlendStateCreateInfo));
    vkPipelineColorBlendStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    vkPipelineColorBlendStateCreateInfo.pNext = NULL;
    vkPipelineColorBlendStateCreateInfo.flags = 0;
    vkPipelineColorBlendStateCreateInfo.attachmentCount = _ARRAYSIZE(vkPipelineColorBlendAttachmentState_array);
    vkPipelineColorBlendStateCreateInfo.pAttachments = vkPipelineColorBlendAttachmentState_array;
    
    //#5: viewport sciessor state
    VkPipelineViewportStateCreateInfo vkPipelineViewportStateCreateInfo;
    memset((void*)&vkPipelineViewportStateCreateInfo, 0, sizeof(VkPipelineViewportStateCreateInfo));
    vkPipelineViewportStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    vkPipelineViewportStateCreateInfo.pNext = NULL;
    vkPipelineViewportStateCreateInfo.flags = 0;
    vkPipelineViewportStateCreateInfo.viewportCount = 1; //Means we can specify multiple viewport
    
    memset((void*)&vkViewport, 0, sizeof(VkViewport));
    vkViewport.x = 0;
    vkViewport.y = 0;
    vkViewport.width = (float)vkExtent2D_swapchain.width;
    vkViewport.height = (float)vkExtent2D_swapchain.height;
    vkViewport.minDepth = 0.0f;
    vkViewport.maxDepth = 1.0f;
    
    vkPipelineViewportStateCreateInfo.pViewports = &vkViewport;
    vkPipelineViewportStateCreateInfo.scissorCount = 1;
    
    memset((void*)&vkRect2D_scissor, 0, sizeof(VkRect2D));
    vkRect2D_scissor.offset.x = 0;
    vkRect2D_scissor.offset.y = 0;
    vkRect2D_scissor.extent.width = (float)vkExtent2D_swapchain.width;
    vkRect2D_scissor.extent.height = (float)vkExtent2D_swapchain.height;
    
    vkPipelineViewportStateCreateInfo.pScissors = &vkRect2D_scissor;
    
    //#6: Depth Stencil state
    //THIS STATE CAN BE OMMITTED AS WE DONT HAVE THE DEPTH
    VkPipelineDepthStencilStateCreateInfo vkPipelineDepthStencilStateCreateInfo;
    memset((void*)&vkPipelineDepthStencilStateCreateInfo, 0, sizeof(VkPipelineDepthStencilStateCreateInfo));
    vkPipelineDepthStencilStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    vkPipelineDepthStencilStateCreateInfo.depthTestEnable = VK_TRUE;
    vkPipelineDepthStencilStateCreateInfo.depthWriteEnable = VK_TRUE;
    vkPipelineDepthStencilStateCreateInfo.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    vkPipelineDepthStencilStateCreateInfo.depthBoundsTestEnable = VK_FALSE;
    vkPipelineDepthStencilStateCreateInfo.back.failOp = VK_STENCIL_OP_KEEP;
    vkPipelineDepthStencilStateCreateInfo.back.passOp = VK_STENCIL_OP_KEEP;
    vkPipelineDepthStencilStateCreateInfo.back.compareOp = VK_COMPARE_OP_ALWAYS;
    vkPipelineDepthStencilStateCreateInfo.front = vkPipelineDepthStencilStateCreateInfo.back;
    vkPipelineDepthStencilStateCreateInfo.stencilTestEnable = VK_FALSE;    
    
    //#7: Dynamic State
    //THIS STATE CAN BE OMMITTED AS WE DONT HAVE ANY DYNAMIC STATE
    
    //#8: Multi Sample State(needed for fragment shader)
    VkPipelineMultisampleStateCreateInfo vkPipelineMultisampleStateCreateInfo;
    memset((void*)&vkPipelineMultisampleStateCreateInfo, 0, sizeof(VkPipelineMultisampleStateCreateInfo));
    vkPipelineMultisampleStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    vkPipelineMultisampleStateCreateInfo.pNext = NULL;
    vkPipelineMultisampleStateCreateInfo.flags = 0;
    vkPipelineMultisampleStateCreateInfo.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
    
    //#9: Shader State
    VkPipelineShaderStageCreateInfo vkPipelineShaderStageCreateInfo_array[2];
    memset((void*)vkPipelineShaderStageCreateInfo_array, 0, sizeof(VkPipelineShaderStageCreateInfo) * _ARRAYSIZE(vkPipelineShaderStageCreateInfo_array));
    //Vertex Shader
    vkPipelineShaderStageCreateInfo_array[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vkPipelineShaderStageCreateInfo_array[0].pNext = NULL;
    vkPipelineShaderStageCreateInfo_array[0].flags = 0;
    vkPipelineShaderStageCreateInfo_array[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
    vkPipelineShaderStageCreateInfo_array[0].module = vkShaderModule_vertex_shader;
    vkPipelineShaderStageCreateInfo_array[0].pName = "main";
    vkPipelineShaderStageCreateInfo_array[0].pSpecializationInfo = NULL;
    
    //fragment Shader
    vkPipelineShaderStageCreateInfo_array[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vkPipelineShaderStageCreateInfo_array[1].pNext = NULL;
    vkPipelineShaderStageCreateInfo_array[1].flags = 0;
    vkPipelineShaderStageCreateInfo_array[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    vkPipelineShaderStageCreateInfo_array[1].module = vkShaderModule_fragment_shader;
    vkPipelineShaderStageCreateInfo_array[1].pName = "main";
    vkPipelineShaderStageCreateInfo_array[1].pSpecializationInfo = NULL;
    
    //#10: Tessellation State
    //THIS STATE CAN BE OMMITTED AS WE DONT HAVE ANY TESSELLATION SHADER
    
    
    //As pipeline are created from pipeline cache, we will create the pipeline cache object
    VkPipelineCacheCreateInfo vkPipelineCacheCreateInfo;
    memset((void*)&vkPipelineCacheCreateInfo, 0, sizeof(VkPipelineCacheCreateInfo));
    vkPipelineCacheCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
    vkPipelineCacheCreateInfo.pNext = NULL;
    vkPipelineCacheCreateInfo.flags = 0;
    
    
    VkPipelineCache vkPipelineCache = VK_NULL_HANDLE; 
    vkResult = vkCreatePipelineCache(vkDevice, &vkPipelineCacheCreateInfo, NULL, &vkPipelineCache);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createPipeline() --> vkCreatePipelineCache() is failed error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createPipeline() --> vkCreatePipelineCache() is succedded\n");
        fflush(gpFile);
    }
    
    //create the actual graphics pipeline
    VkGraphicsPipelineCreateInfo vkGraphicsPipelineCreateInfo;
    memset((void*)&vkGraphicsPipelineCreateInfo, 0, sizeof(VkGraphicsPipelineCreateInfo));
    vkGraphicsPipelineCreateInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    vkGraphicsPipelineCreateInfo.pNext = NULL;
    vkGraphicsPipelineCreateInfo.flags = 0;
    vkGraphicsPipelineCreateInfo.pVertexInputState = &vkPipelineVertexInputStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pInputAssemblyState = &vkPipelineInputAssemblyStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pRasterizationState = &vkPipelineRasterizationStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pColorBlendState = &vkPipelineColorBlendStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pViewportState = &vkPipelineViewportStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pDepthStencilState = &vkPipelineDepthStencilStateCreateInfo;
    vkGraphicsPipelineCreateInfo.pDynamicState = NULL;
    vkGraphicsPipelineCreateInfo.pMultisampleState = &vkPipelineMultisampleStateCreateInfo;
    vkGraphicsPipelineCreateInfo.stageCount = _ARRAYSIZE(vkPipelineShaderStageCreateInfo_array);
    vkGraphicsPipelineCreateInfo.pStages = vkPipelineShaderStageCreateInfo_array;
    vkGraphicsPipelineCreateInfo.pTessellationState = NULL;
    vkGraphicsPipelineCreateInfo.layout = vkPipelineLayout;
    vkGraphicsPipelineCreateInfo.renderPass = vkRenderPass;
    vkGraphicsPipelineCreateInfo.subpass = 0; //as we have only one renderpass
    vkGraphicsPipelineCreateInfo.basePipelineHandle = VK_NULL_HANDLE;
    vkGraphicsPipelineCreateInfo.basePipelineIndex = 0;
    
    //Now create the pipeline
    vkResult = vkCreateGraphicsPipelines(vkDevice,
                                         vkPipelineCache,
                                         1,
                                         &vkGraphicsPipelineCreateInfo,
                                         NULL,
                                         &vkPipeline);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createPipeline() --> vkCreateGraphicsPipelines() is failed error code is %d\n", vkResult);
        fflush(gpFile);
        vkDestroyPipelineCache(vkDevice, vkPipelineCache, NULL);
        vkPipelineCache = VK_NULL_HANDLE;
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createPipeline() --> vkCreateGraphicsPipelines() is succedded\n");
        fflush(gpFile);
    }
    
    //we ar done with pipeline cache so destroy it
    vkDestroyPipelineCache(vkDevice, vkPipelineCache, NULL);
    vkPipelineCache = VK_NULL_HANDLE;
    
    return (vkResult);
}



VkResult createFrameBuffers(void)
{
    //variables
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //step1
    VkImageView vkImageView_attachment_array[1];
    memset((void*)vkImageView_attachment_array, 0, sizeof(VkImageView) * _ARRAYSIZE(vkImageView_attachment_array));
    
    // step2
    VkFramebufferCreateInfo vkFramebufferCreateInfo;
    memset((void*)&vkFramebufferCreateInfo, 0, sizeof(VkFramebufferCreateInfo));
    
    vkFramebufferCreateInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    vkFramebufferCreateInfo.pNext = NULL;
    vkFramebufferCreateInfo.flags = 0;
    vkFramebufferCreateInfo.renderPass = vkRenderPass;
    vkFramebufferCreateInfo.attachmentCount = _ARRAYSIZE(vkImageView_attachment_array);
    vkFramebufferCreateInfo.pAttachments = vkImageView_attachment_array;
    vkFramebufferCreateInfo.width = vkExtent2D_swapchain.width;
    vkFramebufferCreateInfo.height = vkExtent2D_swapchain.height;
    vkFramebufferCreateInfo.layers = 1;
    
    //step3:
    vkFrameBuffer_array = (VkFramebuffer*)malloc(sizeof(VkFramebuffer) * swapchainImageCount);
    //check for malloc
    
    //step4:
    
    for(uint32_t i = 0; i < swapchainImageCount; i++)
    {
        // Recommended Change for depth
        /*********************************************************************************************************************/
        VkImageView vkImageView_attachment_array[2]; //for color and depth
        memset((void*)vkImageView_attachment_array, 0, sizeof(VkImageView) * _ARRAYSIZE(vkImageView_attachment_array));
        
        //step2
        VkFramebufferCreateInfo vkFramebufferCreateInfo;
        memset((void*)&vkFramebufferCreateInfo, 0, sizeof(VkFramebufferCreateInfo));
        
        vkFramebufferCreateInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        vkFramebufferCreateInfo.pNext = NULL;
        vkFramebufferCreateInfo.flags = 0;
        vkFramebufferCreateInfo.renderPass = vkRenderPass;
        vkFramebufferCreateInfo.attachmentCount = _ARRAYSIZE(vkImageView_attachment_array);
        vkFramebufferCreateInfo.pAttachments = vkImageView_attachment_array;
        vkFramebufferCreateInfo.width = vkExtent2D_swapchain.width;
        vkFramebufferCreateInfo.height = vkExtent2D_swapchain.height;
        vkFramebufferCreateInfo.layers = 1;
        
        /*********************************************************************************************************************/
        
        vkImageView_attachment_array[0] = swapchainImageView_array[i];
        vkImageView_attachment_array[1] = vkImageView_depth;
        
        vkResult = vkCreateFramebuffer(vkDevice, 
                                       &vkFramebufferCreateInfo,
                                       NULL,
                                       &vkFrameBuffer_array[i]);
        if(vkResult != VK_SUCCESS)
        {
            fprintf(gpFile, "createFrameBuffers() --> vkCreateFramebuffer() is failed for %d iteration and error code is %d\n",i, vkResult);
        fflush(gpFile);
            return vkResult;
        }
        else
        {
            fprintf(gpFile, "createFrameBuffers() --> vkCreateFramebuffer() is succedded for iteration %d\n", i);
        fflush(gpFile);
        }
    }
    
    return vkResult;
}


VkResult createSemaphores(void)
{
    //variables
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //step1
    VkSemaphoreCreateInfo vkSemaphoreCreateInfo;
    memset((void*)&vkSemaphoreCreateInfo, 0, sizeof(VkSemaphoreCreateInfo));
    
    vkSemaphoreCreateInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
    vkSemaphoreCreateInfo.pNext = NULL;  //Binary and Timeline Semaphore info, bydefault it is Binary
    vkSemaphoreCreateInfo.flags = 0; //RESERVED: must be zero
    
    //backBuffer Semaphore
    vkResult = vkCreateSemaphore(vkDevice, 
                                 &vkSemaphoreCreateInfo,
                                 NULL,
                                 &vkSemaphore_backBuffer);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createSemaphores() --> vkCreateSemaphore() is failed for vkSemaphore_backBuffer and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createSemaphores() --> vkCreateSemaphore() is succedded for vkSemaphore_backBuffer\n");
        fflush(gpFile);
    }
    
    
    //renderComplete Semaphore
    vkResult = vkCreateSemaphore(vkDevice, 
                                 &vkSemaphoreCreateInfo,
                                 NULL,
                                 &vkSemaphore_renderComplete);
    if(vkResult != VK_SUCCESS)
    {
        fprintf(gpFile, "createSemaphores() --> vkCreateSemaphore() is failed for vkSemaphore_renderComplete and error code is %d\n", vkResult);
        fflush(gpFile);
        return vkResult;
    }
    else
    {
        fprintf(gpFile, "createSemaphores() --> vkCreateSemaphore() is succedded for vkSemaphore_renderComplete\n");
        fflush(gpFile);
    }
    
    return vkResult;
    
}


VkResult createFences(void)
{
    //variables
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //step1
    VkFenceCreateInfo vkFenceCreateInfo;
    memset((void*)&vkFenceCreateInfo, 0, sizeof(VkFenceCreateInfo));
    
    vkFenceCreateInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    vkFenceCreateInfo.pNext = NULL;
    vkFenceCreateInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;
    
    vkFence_array = (VkFence*)malloc(sizeof(VkFence) * sizeof(swapchainImageCount));
    //malloc error checking to be done
    
    for(uint32_t i = 0; i < swapchainImageCount; i++)
    {
        vkResult = vkCreateFence(vkDevice, 
                                 &vkFenceCreateInfo,
                                 NULL,
                                 &vkFence_array[i]);
        if(vkResult != VK_SUCCESS)
        {
            fprintf(gpFile, "createFences() --> vkCreateFence() is failed for %d iteration and error code is %d\n", i, vkResult);
        fflush(gpFile);
            return vkResult;
        }
        else
        {
            fprintf(gpFile, "createFences() --> vkCreateFence() is succedded for %d iteration\n", i);
        fflush(gpFile);
        }
    }

    return vkResult;
}


VkResult buildCommandBuffers(void)
{
    //variables
    VkResult vkResult = VK_SUCCESS;
    
    //code
    //step1
    //Loop per swapchainImagecount
    for(uint32_t i = 0; i < swapchainImageCount; i++)
    {
        //ResetCommandBuffers
        vkResult = vkResetCommandBuffer(vkCommandBuffer_array[i], 0);  // second parameetr: this command buffer is created from command pool, so dont release the resouces created by this comand buffer
        if(vkResult != VK_SUCCESS)
        {
            fprintf(gpFile, "buildCommandBuffers() --> vkResetCommandBuffer() is failed for %d iteration and error code is %d\n", i, vkResult);
        fflush(gpFile);
            return vkResult;
        }
        else
        {
            fprintf(gpFile, "buildCommandBuffers() --> vkResetCommandBuffer() is succedded for %d iteration\n", i);
        fflush(gpFile);
        }
        
        VkCommandBufferBeginInfo vkCommandBufferBeginInfo;
        memset((void*)&vkCommandBufferBeginInfo, 0, sizeof(VkCommandBufferBeginInfo));
        
        vkCommandBufferBeginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        vkCommandBufferBeginInfo.pNext = NULL;
        vkCommandBufferBeginInfo.flags = 0;  //1. we will use only primary command buffers, 2. we are not going to use this command buffer simultaneoulsy between multipple threads
        
        vkResult = vkBeginCommandBuffer(vkCommandBuffer_array[i], &vkCommandBufferBeginInfo);
        if(vkResult != VK_SUCCESS)
        {
            fprintf(gpFile, "buildCommandBuffers() --> vkBeginCommandBuffer() is failed for %d iteration and error code is %d\n", i, vkResult);
        fflush(gpFile);
            return vkResult;
        }
        else
        {
            fprintf(gpFile, "buildCommandBuffers() --> vkBeginCommandBuffer() is succedded for %d iteration\n", i);
        fflush(gpFile);
        }
        
        //SetClearValues
        VkClearValue vkClearValue_array[2];
        memset((void*)vkClearValue_array, 0, (sizeof(VkClearValue) * _ARRAYSIZE(vkClearValue_array)));
        
        vkClearValue_array[0].color = vkClearColorValue;
        vkClearValue_array[1].depthStencil = vkClearDepthStencilValue;
        
        //Fill REnderpass 
        VkRenderPassBeginInfo vkRenderPassBeginInfo;
        memset((void*)&vkRenderPassBeginInfo, 0, sizeof(VkRenderPassBeginInfo));
        
        vkRenderPassBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        vkRenderPassBeginInfo.pNext = NULL;
        vkRenderPassBeginInfo.renderPass = vkRenderPass;
        vkRenderPassBeginInfo.renderArea.offset.x = 0;
        vkRenderPassBeginInfo.renderArea.offset.y = 0;
        vkRenderPassBeginInfo.renderArea.extent.width = vkExtent2D_swapchain.width;
        vkRenderPassBeginInfo.renderArea.extent.height = vkExtent2D_swapchain.height;
        vkRenderPassBeginInfo.clearValueCount = _ARRAYSIZE(vkClearValue_array);
        vkRenderPassBeginInfo.pClearValues = vkClearValue_array;
        vkRenderPassBeginInfo.framebuffer = vkFrameBuffer_array[i];
        
        //BeginRenderPass
        vkCmdBeginRenderPass(vkCommandBuffer_array[i], 
                             &vkRenderPassBeginInfo, 
                             VK_SUBPASS_CONTENTS_INLINE);

        //Bind with the pipeline
        vkCmdBindPipeline(vkCommandBuffer_array[i],
                          VK_PIPELINE_BIND_POINT_GRAPHICS,
                          vkPipeline);
                          
        //Sun
        //Bind our descriptor set with the pipeline
        vkCmdBindDescriptorSets(vkCommandBuffer_array[i],
                                VK_PIPELINE_BIND_POINT_GRAPHICS,
                                vkPipelineLayout,
                                0,
                                1,
                                &vkDescriptorSet_sun,
                                0, 
                                NULL);
        
        //bind vertex position buffer
        VkDeviceSize vkDeviceSize_offset_position[1];
        memset((void*)vkDeviceSize_offset_position, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_position));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               0, //binding point
                               1, //how many buffer
                               &vertexData_position_sun.vkBuffer, //which buffer
                               vkDeviceSize_offset_position);
        
        //bind with the vertex normal buffer
        VkDeviceSize vkDeviceSize_offset_normal[1];
        memset((void*)vkDeviceSize_offset_normal, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_normal));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               1,
                               1, //how many buffer
                               &vertexData_normal_sun.vkBuffer, //which buffer
                               vkDeviceSize_offset_normal);

        //bind with the vertex texcoord buffer
        VkDeviceSize vkDeviceSize_offset_texcoord[1];
        memset((void*)vkDeviceSize_offset_texcoord, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_texcoord));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               2,
                               1, //how many buffer
                               &vertexData_texcoord_sun.vkBuffer, //which buffer
                               vkDeviceSize_offset_texcoord);                               
                              
        //bind index buffer
        vkCmdBindIndexBuffer(vkCommandBuffer_array[i],
                             vertexData_index_sun.vkBuffer,
                             0,
                             VK_INDEX_TYPE_UINT16 //4th parameter is matching with globally declared triangle_position_indices array type
                             );
                             
        //Here we should call vulkan drawing functions
        vkCmdDrawIndexed(vkCommandBuffer_array[i],
                         numElements,
                         1,
                         0,
                         0,
                         0);
                         
                         
        //Mercury
        //Bind our descriptor set with the pipeline
        vkCmdBindDescriptorSets(vkCommandBuffer_array[i],
                                VK_PIPELINE_BIND_POINT_GRAPHICS,
                                vkPipelineLayout,
                                0,
                                1,
                                &vkDescriptorSet_mercury,
                                0, 
                                NULL);
        
        //bind vertex position buffer
        
        memset((void*)vkDeviceSize_offset_position, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_position));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               0, //binding point
                               1, //how many buffer
                               &vertexData_position_mercury.vkBuffer, //which buffer
                               vkDeviceSize_offset_position);
        
        //bind with the vertex normal buffer
        
        memset((void*)vkDeviceSize_offset_normal, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_normal));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               1,
                               1, //how many buffer
                               &vertexData_normal_mercury.vkBuffer, //which buffer
                               vkDeviceSize_offset_normal);

        //bind with the vertex texcoord buffer
        
        memset((void*)vkDeviceSize_offset_texcoord, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_texcoord));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               2,
                               1, //how many buffer
                               &vertexData_texcoord_mercury.vkBuffer, //which buffer
                               vkDeviceSize_offset_texcoord);                               
                              
        //bind index buffer
        vkCmdBindIndexBuffer(vkCommandBuffer_array[i],
                             vertexData_index_mercury.vkBuffer,
                             0,
                             VK_INDEX_TYPE_UINT16 //4th parameter is matching with globally declared triangle_position_indices array type
                             );
                             
        //Here we should call vulkan drawing functions
        vkCmdDrawIndexed(vkCommandBuffer_array[i],
                         numElements,
                         1,
                         0,
                         0,
                         0);
        
        //Venus
        //Bind our descriptor set with the pipeline
        vkCmdBindDescriptorSets(vkCommandBuffer_array[i],
                                VK_PIPELINE_BIND_POINT_GRAPHICS,
                                vkPipelineLayout,
                                0,
                                1,
                                &vkDescriptorSet_venus,
                                0, 
                                NULL);
        
        //bind vertex position buffer
        
        memset((void*)vkDeviceSize_offset_position, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_position));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               0, //binding point
                               1, //how many buffer
                               &vertexData_position_venus.vkBuffer, //which buffer
                               vkDeviceSize_offset_position);
        
        //bind with the vertex normal buffer
        
        memset((void*)vkDeviceSize_offset_normal, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_normal));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               1,
                               1, //how many buffer
                               &vertexData_normal_venus.vkBuffer, //which buffer
                               vkDeviceSize_offset_normal);

        //bind with the vertex texcoord buffer
        
        memset((void*)vkDeviceSize_offset_texcoord, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_texcoord));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               2,
                               1, //how many buffer
                               &vertexData_texcoord_venus.vkBuffer, //which buffer
                               vkDeviceSize_offset_texcoord);                               
                              
        //bind index buffer
        vkCmdBindIndexBuffer(vkCommandBuffer_array[i],
                             vertexData_index_venus.vkBuffer,
                             0,
                             VK_INDEX_TYPE_UINT16 //4th parameter is matching with globally declared triangle_position_indices array type
                             );
                             
        //Here we should call vulkan drawing functions
        vkCmdDrawIndexed(vkCommandBuffer_array[i],
                         numElements,
                         1,
                         0,
                         0,
                         0);
                         
        //earth
        //Bind our descriptor set with the pipeline
        vkCmdBindDescriptorSets(vkCommandBuffer_array[i],
                                VK_PIPELINE_BIND_POINT_GRAPHICS,
                                vkPipelineLayout,
                                0,
                                1,
                                &vkDescriptorSet_earth,
                                0, 
                                NULL);
        
        //bind vertex position buffer
        
        memset((void*)vkDeviceSize_offset_position, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_position));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               0, //binding point
                               1, //how many buffer
                               &vertexData_position_earth.vkBuffer, //which buffer
                               vkDeviceSize_offset_position);
        
        //bind with the vertex normal buffer
        
        memset((void*)vkDeviceSize_offset_normal, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_normal));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               1,
                               1, //how many buffer
                               &vertexData_normal_earth.vkBuffer, //which buffer
                               vkDeviceSize_offset_normal);

        //bind with the vertex texcoord buffer
        
        memset((void*)vkDeviceSize_offset_texcoord, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_texcoord));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               2,
                               1, //how many buffer
                               &vertexData_texcoord_earth.vkBuffer, //which buffer
                               vkDeviceSize_offset_texcoord);                               
                              
        //bind index buffer
        vkCmdBindIndexBuffer(vkCommandBuffer_array[i],
                             vertexData_index_earth.vkBuffer,
                             0,
                             VK_INDEX_TYPE_UINT16 //4th parameter is matching with globally declared triangle_position_indices array type
                             );
                             
        //Here we should call vulkan drawing functions
        vkCmdDrawIndexed(vkCommandBuffer_array[i],
                         numElements,
                         1,
                         0,
                         0,
                         0);
                         
        //mars
        //Bind our descriptor set with the pipeline
        vkCmdBindDescriptorSets(vkCommandBuffer_array[i],
                                VK_PIPELINE_BIND_POINT_GRAPHICS,
                                vkPipelineLayout,
                                0,
                                1,
                                &vkDescriptorSet_mars,
                                0, 
                                NULL);
        
        //bind vertex position buffer
        
        memset((void*)vkDeviceSize_offset_position, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_position));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               0, //binding point
                               1, //how many buffer
                               &vertexData_position_mars.vkBuffer, //which buffer
                               vkDeviceSize_offset_position);
        
        //bind with the vertex normal buffer
        
        memset((void*)vkDeviceSize_offset_normal, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_normal));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               1,
                               1, //how many buffer
                               &vertexData_normal_mars.vkBuffer, //which buffer
                               vkDeviceSize_offset_normal);

        //bind with the vertex texcoord buffer
        
        memset((void*)vkDeviceSize_offset_texcoord, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_texcoord));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               2,
                               1, //how many buffer
                               &vertexData_texcoord_mars.vkBuffer, //which buffer
                               vkDeviceSize_offset_texcoord);                               
                              
        //bind index buffer
        vkCmdBindIndexBuffer(vkCommandBuffer_array[i],
                             vertexData_index_mars.vkBuffer,
                             0,
                             VK_INDEX_TYPE_UINT16 //4th parameter is matching with globally declared triangle_position_indices array type
                             );
                             
        //Here we should call vulkan drawing functions
        vkCmdDrawIndexed(vkCommandBuffer_array[i],
                         numElements,
                         1,
                         0,
                         0,
                         0);
                         
        //jupitor
        //Bind our descriptor set with the pipeline
        vkCmdBindDescriptorSets(vkCommandBuffer_array[i],
                                VK_PIPELINE_BIND_POINT_GRAPHICS,
                                vkPipelineLayout,
                                0,
                                1,
                                &vkDescriptorSet_jupitor,
                                0, 
                                NULL);
        
        //bind vertex position buffer
        
        memset((void*)vkDeviceSize_offset_position, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_position));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               0, //binding point
                               1, //how many buffer
                               &vertexData_position_jupitor.vkBuffer, //which buffer
                               vkDeviceSize_offset_position);
        
        //bind with the vertex normal buffer
        
        memset((void*)vkDeviceSize_offset_normal, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_normal));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               1,
                               1, //how many buffer
                               &vertexData_normal_jupitor.vkBuffer, //which buffer
                               vkDeviceSize_offset_normal);

        //bind with the vertex texcoord buffer
        
        memset((void*)vkDeviceSize_offset_texcoord, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_texcoord));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               2,
                               1, //how many buffer
                               &vertexData_texcoord_jupitor.vkBuffer, //which buffer
                               vkDeviceSize_offset_texcoord);                               
                              
        //bind index buffer
        vkCmdBindIndexBuffer(vkCommandBuffer_array[i],
                             vertexData_index_jupitor.vkBuffer,
                             0,
                             VK_INDEX_TYPE_UINT16 //4th parameter is matching with globally declared triangle_position_indices array type
                             );
                             
        //Here we should call vulkan drawing functions
        vkCmdDrawIndexed(vkCommandBuffer_array[i],
                         numElements,
                         1,
                         0,
                         0,
                         0);
                         
        //saturn
        //Bind our descriptor set with the pipeline
        vkCmdBindDescriptorSets(vkCommandBuffer_array[i],
                                VK_PIPELINE_BIND_POINT_GRAPHICS,
                                vkPipelineLayout,
                                0,
                                1,
                                &vkDescriptorSet_saturn,
                                0, 
                                NULL);
        
        //bind vertex position buffer
        
        memset((void*)vkDeviceSize_offset_position, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_position));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               0, //binding point
                               1, //how many buffer
                               &vertexData_position_saturn.vkBuffer, //which buffer
                               vkDeviceSize_offset_position);
        
        //bind with the vertex normal buffer
        
        memset((void*)vkDeviceSize_offset_normal, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_normal));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               1,
                               1, //how many buffer
                               &vertexData_normal_saturn.vkBuffer, //which buffer
                               vkDeviceSize_offset_normal);

        //bind with the vertex texcoord buffer
        
        memset((void*)vkDeviceSize_offset_texcoord, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_texcoord));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               2,
                               1, //how many buffer
                               &vertexData_texcoord_saturn.vkBuffer, //which buffer
                               vkDeviceSize_offset_texcoord);                               
                              
        //bind index buffer
        vkCmdBindIndexBuffer(vkCommandBuffer_array[i],
                             vertexData_index_saturn.vkBuffer,
                             0,
                             VK_INDEX_TYPE_UINT16 //4th parameter is matching with globally declared triangle_position_indices array type
                             );
                             
        //Here we should call vulkan drawing functions
        vkCmdDrawIndexed(vkCommandBuffer_array[i],
                         numElements,
                         1,
                         0,
                         0,
                         0);
                         
        //uranus
        //Bind our descriptor set with the pipeline
        vkCmdBindDescriptorSets(vkCommandBuffer_array[i],
                                VK_PIPELINE_BIND_POINT_GRAPHICS,
                                vkPipelineLayout,
                                0,
                                1,
                                &vkDescriptorSet_uranus,
                                0, 
                                NULL);
        
        //bind vertex position buffer
        
        memset((void*)vkDeviceSize_offset_position, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_position));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               0, //binding point
                               1, //how many buffer
                               &vertexData_position_uranus.vkBuffer, //which buffer
                               vkDeviceSize_offset_position);
        
        //bind with the vertex normal buffer
        
        memset((void*)vkDeviceSize_offset_normal, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_normal));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               1,
                               1, //how many buffer
                               &vertexData_normal_uranus.vkBuffer, //which buffer
                               vkDeviceSize_offset_normal);

        //bind with the vertex texcoord buffer
        
        memset((void*)vkDeviceSize_offset_texcoord, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_texcoord));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               2,
                               1, //how many buffer
                               &vertexData_texcoord_uranus.vkBuffer, //which buffer
                               vkDeviceSize_offset_texcoord);                               
                              
        //bind index buffer
        vkCmdBindIndexBuffer(vkCommandBuffer_array[i],
                             vertexData_index_uranus.vkBuffer,
                             0,
                             VK_INDEX_TYPE_UINT16 //4th parameter is matching with globally declared triangle_position_indices array type
                             );
                             
        //Here we should call vulkan drawing functions
        vkCmdDrawIndexed(vkCommandBuffer_array[i],
                         numElements,
                         1,
                         0,
                         0,
                         0);
                         
        //neptune
        //Bind our descriptor set with the pipeline
        vkCmdBindDescriptorSets(vkCommandBuffer_array[i],
                                VK_PIPELINE_BIND_POINT_GRAPHICS,
                                vkPipelineLayout,
                                0,
                                1,
                                &vkDescriptorSet_neptune,
                                0, 
                                NULL);
        
        //bind vertex position buffer
        
        memset((void*)vkDeviceSize_offset_position, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_position));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               0, //binding point
                               1, //how many buffer
                               &vertexData_position_neptune.vkBuffer, //which buffer
                               vkDeviceSize_offset_position);
        
        //bind with the vertex normal buffer
        
        memset((void*)vkDeviceSize_offset_normal, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_normal));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               1,
                               1, //how many buffer
                               &vertexData_normal_neptune.vkBuffer, //which buffer
                               vkDeviceSize_offset_normal);

        //bind with the vertex texcoord buffer
        
        memset((void*)vkDeviceSize_offset_texcoord, 0, sizeof(VkDeviceSize) * _ARRAYSIZE(vkDeviceSize_offset_texcoord));
        vkCmdBindVertexBuffers(vkCommandBuffer_array[i], 
                               2,
                               1, //how many buffer
                               &vertexData_texcoord_neptune.vkBuffer, //which buffer
                               vkDeviceSize_offset_texcoord);                               
                              
        //bind index buffer
        vkCmdBindIndexBuffer(vkCommandBuffer_array[i],
                             vertexData_index_neptune.vkBuffer,
                             0,
                             VK_INDEX_TYPE_UINT16 //4th parameter is matching with globally declared triangle_position_indices array type
                             );
                             
        //Here we should call vulkan drawing functions
        vkCmdDrawIndexed(vkCommandBuffer_array[i],
                         numElements,
                         1,
                         0,
                         0,
                         0);
                         
                         
        
        
        //EndRenderPass
        vkCmdEndRenderPass(vkCommandBuffer_array[i]);
        
        //End Command Buffer recording
        vkResult = vkEndCommandBuffer(vkCommandBuffer_array[i]);
        if(vkResult != VK_SUCCESS)
        {
            fprintf(gpFile, "buildCommandBuffers() --> vkEndCommandBuffer() is failed for %d iteration and error code is %d\n", i, vkResult);
        fflush(gpFile);
            return vkResult;
        }
        else
        {
            fprintf(gpFile, "buildCommandBuffers() --> vkEndCommandBuffer() is succedded for %d iteration\n", i);
        fflush(gpFile);
        }
    }
    
    return vkResult;
}


 VKAPI_ATTR VkBool32 VKAPI_CALL debugReportCallback(VkDebugReportFlagsEXT vkDebugReportFlagsEXT, 
                                                   VkDebugReportObjectTypeEXT vkDebugReportObjectTypeEXT,
                                                   uint64_t object,
                                                   size_t location,
                                                   int32_t messageCode,
                                                   const char* pLayerPrefix,
                                                   const char* pMessage,
                                                   void* pUserData)
{
    //code
    fprintf(gpFile, "SSA_Validation: debugReportCallback() --> %s (%d) = %s\n", pLayerPrefix, messageCode, pMessage);
        fflush(gpFile);
    
    return(VK_FALSE);
}
